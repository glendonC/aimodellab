"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/performance.ts":
/*!**********************************!*\
  !*** ./lib/model/performance.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceCalculator: function() { return /* binding */ PerformanceCalculator; }\n/* harmony export */ });\n// Polars-like DataFrame implementation for browser\nclass DataFrame {\n    select(column) {\n        if (!this.data.length) {\n            return {\n                sum: ()=>0,\n                mean: ()=>0\n            };\n        }\n        return {\n            sum: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0),\n            mean: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0) / this.data.length\n        };\n    }\n    static fromRecords(records) {\n        return new DataFrame(records || []);\n    }\n    constructor(data){\n        this.data = data || []; // Ensure data is never undefined\n    }\n}\nclass PerformanceCalculator {\n    calculateWithPolars(analysisResult) {\n        const { layers = [] } = analysisResult.graph || {};\n        try {\n            const totalFlops = layers.reduce((sum, layer)=>sum + (layer.flops || 0), 0);\n            const totalMemory = layers.reduce((sum, layer)=>sum + (layer.memory || 0), 0);\n            const totalParams = layers.reduce((sum, layer)=>sum + (layer.parameters || 0), 0);\n            // Scale utilization based on actual model complexity\n            const utilizationScale = Math.max(25, Math.min(95, totalFlops / 1e9 * 0.8));\n            return {\n                fps: Math.min(60, 1000 / Math.max(1, totalFlops / 1e9)),\n                latency: Math.max(2.0, totalFlops / 1e9),\n                memory: Math.max(1.5, totalMemory / (1024 * 1024 * 1024)),\n                utilization: utilizationScale,\n                efficiency: totalFlops / (totalParams || 1),\n                memoryEfficiency: totalMemory / (totalParams * 4 || 1),\n                totalFlops,\n                totalMemory,\n                totalParams\n            };\n        } catch (e) {\n            console.error(\"Layer calculation failed:\", e);\n            return {\n                fps: 0,\n                latency: 0,\n                memory: 0,\n                utilization: 0,\n                efficiency: 0,\n                memoryEfficiency: 0,\n                totalFlops: 0,\n                totalMemory: 0,\n                totalParams: 0\n            };\n        }\n    }\n    getModelCharacteristics(modelId, totalFlops, totalMemory) {\n        var _modelId_toLowerCase;\n        const id = (_modelId_toLowerCase = modelId === null || modelId === void 0 ? void 0 : modelId.toLowerCase()) !== null && _modelId_toLowerCase !== void 0 ? _modelId_toLowerCase : \"default\";\n        const flopsInTFlops = totalFlops / 1e12;\n        const memoryInGB = totalMemory / 1024 / 1024 / 1024;\n        // Base characteristics that scale with model size\n        const baseCharacteristics = {\n            minUtilization: Math.max(15, flopsInTFlops * 10),\n            tensorCoreUsage: Math.max(12, flopsInTFlops * 15),\n            memoryBandwidth: Math.max(0.3, flopsInTFlops * 0.5),\n            baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.cnn, memoryInGB * 1.2)\n        };\n        if (id.includes(\"yolo\")) {\n            return {\n                type: \"detection\",\n                batchSize: 16,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.detection, baseCharacteristics.minUtilization),\n                speedupFactor: 2.8,\n                memoryScale: 1.3,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.2,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.4,\n                features: [\n                    \"INT8 Quantization\",\n                    \"CUDA Graph Acceleration\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.detection, baseCharacteristics.baseMemory)\n            };\n        }\n        if (id.includes(\"stable\")) {\n            return {\n                type: \"generation\",\n                batchSize: 1,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.generation, baseCharacteristics.minUtilization),\n                speedupFactor: 2.2,\n                memoryScale: 1.5,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.5,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.8,\n                features: [\n                    \"FP16 Mixed Precision\",\n                    \"Attention Optimization\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.generation, baseCharacteristics.baseMemory)\n            };\n        }\n        // Default CNN characteristics with realistic minimums\n        return {\n            type: \"cnn\",\n            batchSize: 32,\n            baseUtilization: Math.max(this.GPU_SPECS.minUtilization.cnn, baseCharacteristics.minUtilization),\n            speedupFactor: 2.2,\n            memoryScale: 1.2,\n            tensorCoreUsage: baseCharacteristics.tensorCoreUsage,\n            memoryBandwidth: baseCharacteristics.memoryBandwidth,\n            features: [\n                \"TensorRT Inference\",\n                \"Kernel Fusion\"\n            ],\n            baseMemory: baseCharacteristics.baseMemory\n        };\n    }\n    calculateMetrics(analysisResult, gpuEnabled) {\n        if (!(analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.graph)) {\n            return this.getDefaultMetrics();\n        }\n        const baseMetrics = this.calculateWithPolars(analysisResult);\n        const characteristics = this.getModelCharacteristics(analysisResult.graph.metadata.modelId, baseMetrics.totalFlops, baseMetrics.totalMemory);\n        const cpuMetrics = {\n            fps: baseMetrics.fps,\n            latency: baseMetrics.latency,\n            memory: baseMetrics.memory,\n            utilization: baseMetrics.utilization\n        };\n        // Return only CPU metrics when GPU is disabled\n        if (!gpuEnabled) {\n            return {\n                cpuMetrics,\n                gpuMetrics: null,\n                nvOptimizations: {\n                    speedup: \"\".concat(characteristics.speedupFactor.toFixed(1), \"x\"),\n                    batchSize: characteristics.batchSize\n                }\n            };\n        }\n        // Full GPU metrics when enabled\n        const gpuMetrics = {\n            fps: cpuMetrics.fps * characteristics.speedupFactor,\n            latency: cpuMetrics.latency / characteristics.speedupFactor,\n            memory: cpuMetrics.memory * characteristics.memoryScale,\n            utilization: Math.min(85, baseMetrics.utilization * 0.6)\n        };\n        return {\n            cpuMetrics,\n            gpuMetrics,\n            nvOptimizations: {\n                tensorCoreUsage: \"\".concat(characteristics.tensorCoreUsage.toFixed(1), \"%\"),\n                memoryBandwidth: \"\".concat(characteristics.memoryBandwidth.toFixed(1), \" TB/s\"),\n                speedup: \"\".concat(characteristics.speedupFactor.toFixed(1), \"x\"),\n                batchSize: characteristics.batchSize\n            }\n        };\n    }\n    getDefaultMetrics() {\n        const defaultMetrics = {\n            fps: 0,\n            latency: 0,\n            memory: 0,\n            utilization: 0\n        };\n        return {\n            cpuMetrics: defaultMetrics,\n            gpuMetrics: null,\n            nvOptimizations: null\n        };\n    }\n    constructor(){\n        this.GPU_SPECS = {\n            peakTflops: 312,\n            memoryBandwidth: 2048,\n            tensorCores: 432,\n            maxBatchSize: 32,\n            // Minimum utilization for active models\n            minUtilization: {\n                cnn: 15,\n                transformer: 25,\n                detection: 20,\n                generation: 35 // Stable Diffusion etc\n            },\n            // Minimum memory requirements\n            minMemoryGB: {\n                cnn: 1.5,\n                transformer: 2.8,\n                detection: 2.2,\n                generation: 3.5 // Stable Diffusion etc\n            }\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBSUEsbURBQW1EO0FBQ25ELE1BQU1BO0lBT0pDLE9BQU9DLE1BQTBCLEVBQUU7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7WUFDckIsT0FBTztnQkFDTEMsS0FBSyxJQUFNO2dCQUNYQyxNQUFNLElBQU07WUFDZDtRQUNGO1FBRUEsT0FBTztZQUNMRCxLQUFLLElBQU0sSUFBSSxDQUFDRixJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJO1lBQ3BFSSxNQUFNLElBQU0sSUFBSSxDQUFDSCxJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU07UUFDNUY7SUFDRjtJQUVBLE9BQU9NLFlBQVlDLE9BQW1DLEVBQUU7UUFDdEQsT0FBTyxJQUFJWCxVQUFVVyxXQUFXLEVBQUU7SUFDcEM7SUFwQkFDLFlBQVlULElBQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLFFBQVEsRUFBRSxFQUFHLGlDQUFpQztJQUM1RDtBQW1CRjtBQWNPLE1BQU1VO0lBc0JIQyxvQkFBb0JDLGNBQThCLEVBQWdCO1FBQ3hFLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEVBQUUsR0FBR0QsZUFBZUUsS0FBSyxJQUFJLENBQUM7UUFFakQsSUFBSTtZQUNGLE1BQU1DLGFBQWFGLE9BQU9ULE1BQU0sQ0FBQyxDQUFDRixLQUFLYyxRQUFVZCxNQUFPYyxDQUFBQSxNQUFNQyxLQUFLLElBQUksSUFBSTtZQUMzRSxNQUFNQyxjQUFjTCxPQUFPVCxNQUFNLENBQUMsQ0FBQ0YsS0FBS2MsUUFBVWQsTUFBT2Ms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QUs7Z0JBQ0x5QixhQUFhO2dCQUNicEIsV0FBVztnQkFDWEksWUFBWSxJQUFJLHVCQUF1QjtZQUN6QztRQUNGOztBQStKRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9kZWwvcGVyZm9ybWFuY2UudHM/ZGI1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwbCBmcm9tICdub2RlanMtcG9sYXJzJztcbmltcG9ydCB7IENQVV9CRU5DSE1BUktTLCBOVklESUFfQkVOQ0hNQVJLUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgQW5hbHlzaXNSZXN1bHQsIExheWVyTWV0cmljcyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBQb2xhcnMtbGlrZSBEYXRhRnJhbWUgaW1wbGVtZW50YXRpb24gZm9yIGJyb3dzZXJcbmNsYXNzIERhdGFGcmFtZSB7XG4gIHByaXZhdGUgZGF0YTogTGF5ZXJNZXRyaWNzW107XG5cbiAgY29uc3RydWN0b3IoZGF0YTogTGF5ZXJNZXRyaWNzW10pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IFtdOyAgLy8gRW5zdXJlIGRhdGEgaXMgbmV2ZXIgdW5kZWZpbmVkXG4gIH1cblxuICBzZWxlY3QoY29sdW1uOiBrZXlvZiBMYXllck1ldHJpY3MpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1bTogKCkgPT4gMCxcbiAgICAgICAgbWVhbjogKCkgPT4gMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VtOiAoKSA9PiB0aGlzLmRhdGEucmVkdWNlKChhY2MsIHJvdykgPT4gYWNjICsgKHJvd1tjb2x1bW5dIHx8IDApLCAwKSxcbiAgICAgIG1lYW46ICgpID0+IHRoaXMuZGF0YS5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgKyAocm93W2NvbHVtbl0gfHwgMCksIDApIC8gdGhpcy5kYXRhLmxlbmd0aFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlY29yZHMocmVjb3JkczogTGF5ZXJNZXRyaWNzW10gfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IERhdGFGcmFtZShyZWNvcmRzIHx8IFtdKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgTW9kZWxNZXRyaWNzIHtcbiAgZnBzOiBudW1iZXI7XG4gIGxhdGVuY3k6IG51bWJlcjtcbiAgbWVtb3J5OiBudW1iZXI7XG4gIHV0aWxpemF0aW9uOiBudW1iZXI7XG4gIGVmZmljaWVuY3k6IG51bWJlcjtcbiAgbWVtb3J5RWZmaWNpZW5jeTogbnVtYmVyO1xuICB0b3RhbEZsb3BzOiBudW1iZXI7XG4gIHRvdGFsTWVtb3J5OiBudW1iZXI7XG4gIHRvdGFsUGFyYW1zOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZUNhbGN1bGF0b3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IEdQVV9TUEVDUyA9IHtcbiAgICBwZWFrVGZsb3BzOiAzMTIsICAgICAgICAgIC8vIEExMDAgRlAxNlxuICAgIG1lbW9yeUJhbmR3aWR0aDogMjA0OCwgICAgLy8gR0Ivc1xuICAgIHRlbnNvckNvcmVzOiA0MzIsXG4gICAgbWF4QmF0Y2hTaXplOiAzMixcbiAgICAvLyBNaW5pbXVtIHV0aWxpemF0aW9uIGZvciBhY3RpdmUgbW9kZWxzXG4gICAgbWluVXRpbGl6YXRpb246IHtcbiAgICAgIGNubjogMTUsICAgICAgICAvLyBFZmZpY2llbnQgQ05Oc1xuICAgICAgdHJhbnNmb3JtZXI6IDI1LCAvLyBUcmFuc2Zvcm1lciBtb2RlbHNcbiAgICAgIGRldGVjdGlvbjogMjAsICAvLyBZT0xPIGV0Y1xuICAgICAgZ2VuZXJhdGlvbjogMzUgIC8vIFN0YWJsZSBEaWZmdXNpb24gZXRjXG4gICAgfSxcbiAgICAvLyBNaW5pbXVtIG1lbW9yeSByZXF1aXJlbWVudHNcbiAgICBtaW5NZW1vcnlHQjoge1xuICAgICAgY25uOiAxLjUsICAgICAgIC8vIEJhc2ljIENOTnNcbiAgICAgIHRyYW5zZm9ybWVyOiAyLjgsLy8gVHJhbnNmb3JtZXIgbW9kZWxzXG4gICAgICBkZXRlY3Rpb246IDIuMiwgLy8gWU9MTyBldGNcbiAgICAgIGdlbmVyYXRpb246IDMuNSAvLyBTdGFibGUgRGlmZnVzaW9uIGV0Y1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGNhbGN1bGF0ZVdpdGhQb2xhcnMoYW5hbHlzaXNSZXN1bHQ6IEFuYWx5c2lzUmVzdWx0KTogTW9kZWxNZXRyaWNzIHtcbiAgICBjb25zdCB7IGxheWVycyA9IFtdIH0gPSBhbmFseXNpc1Jlc3VsdC5ncmFwaCB8fCB7fTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgdG90YWxGbG9wcyA9IGxheWVycy5yZWR1Y2UoKHN1bSwgbGF5ZXIpID0+IHN1bSArIChsYXllci5mbG9wcyB8fCAwKSwgMCk7XG4gICAgICBjb25zdCB0b3RhbE1lbW9yeSA9IGxheWVycy5yZWR1Y2UoKHN1bSwgbGF5ZXIpID0+IHN1bSArIChsYXllci5tZW1vcnkgfHwgMCksIDApO1xuICAgICAgY29uc3QgdG90YWxQYXJhbXMgPSBsYXllcnMucmVkdWNlKChzdW0sIGxheWVyKSA9PiBzdW0gKyAobGF5ZXIucGFyYW1ldGVycyB8fCAwKSwgMCk7XG5cbiAgICAgIC8vIFNjYWxlIHV0aWxpemF0aW9uIGJhc2VkIG9uIGFjdHVhbCBtb2RlbCBjb21wbGV4aXR5XG4gICAgICBjb25zdCB1dGlsaXphdGlvblNjYWxlID0gTWF0aC5tYXgoMjUsIE1hdGgubWluKDk1LCAodG90YWxGbG9wcyAvIDFlOSkgKiAwLjgpKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnBzOiBNYXRoLm1pbig2MCwgMTAwMCAvIE1hdGgubWF4KDEsIHRvdGFsRmxvcHMgLyAxZTkpKSxcbiAgICAgICAgbGF0ZW5jeTogTWF0aC5tYXgoMi4wLCB0b3RhbEZsb3BzIC8gMWU5KSxcbiAgICAgICAgbWVtb3J5OiBNYXRoLm1heCgxLjUsIHRvdGFsTWVtb3J5IC8gKDEwMjQgKiAxMDI0ICogMTAyNCkpLFxuICAgICAgICB1dGlsaXphdGlvbjogdXRpbGl6YXRpb25TY2FsZSxcbiAgICAgICAgZWZmaWNpZW5jeTogdG90YWxGbG9wcyAvICh0b3RhbFBhcmFtcyB8fCAxKSxcbiAgICAgICAgbWVtb3J5RWZmaWNpZW5jeTogdG90YWxNZW1vcnkgLyAodG90YWxQYXJhbXMgKiA0IHx8IDEpLFxuICAgICAgICB0b3RhbEZsb3BzLFxuICAgICAgICB0b3RhbE1lbW9yeSxcbiAgICAgICAgdG90YWxQYXJhbXNcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignTGF5ZXIgY2FsY3VsYXRpb24gZmFpbGVkOicsIGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnBzOiAwLFxuICAgICAgICBsYXRlbmN5OiAwLFxuICAgICAgICBtZW1vcnk6IDAsXG4gICAgICAgIHV0aWxpemF0aW9uOiAwLFxuICAgICAgICBlZmZpY2llbmN5OiAwLFxuICAgICAgICBtZW1vcnlFZmZpY2llbmN5OiAwLFxuICAgICAgICB0b3RhbEZsb3BzOiAwLFxuICAgICAgICB0b3RhbE1lbW9yeTogMCxcbiAgICAgICAgdG90YWxQYXJhbXM6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNb2RlbENoYXJhY3RlcmlzdGljcyhtb2RlbElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHRvdGFsRmxvcHM6IG51bWJlciwgdG90YWxNZW1vcnk6IG51bWJlcikge1xuICAgIGNvbnN0IGlkID0gbW9kZWxJZD8udG9Mb3dlckNhc2UoKSA/PyAnZGVmYXVsdCc7XG4gICAgY29uc3QgZmxvcHNJblRGbG9wcyA9IHRvdGFsRmxvcHMgLyAxZTEyO1xuICAgIGNvbnN0IG1lbW9yeUluR0IgPSB0b3RhbE1lbW9yeSAvIDEwMjQgLyAxMDI0IC8gMTAyNDtcblxuICAgIC8vIEJhc2UgY2hhcmFjdGVyaXN0aWNzIHRoYXQgc2NhbGUgd2l0aCBtb2RlbCBzaXplXG4gICAgY29uc3QgYmFzZUNoYXJhY3RlcmlzdGljcyA9IHtcbiAgICAgIG1pblV0aWxpemF0aW9uOiBNYXRoLm1heCgxNSwgZmxvcHNJblRGbG9wcyAqIDEwKSxcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogTWF0aC5tYXgoMTIsIGZsb3BzSW5URmxvcHMgKiAxNSksXG4gICAgICBtZW1vcnlCYW5kd2lkdGg6IE1hdGgubWF4KDAuMywgZmxvcHNJblRGbG9wcyAqIDAuNSksXG4gICAgICBiYXNlTWVtb3J5OiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5NZW1vcnlHQi5jbm4sIG1lbW9yeUluR0IgKiAxLjIpXG4gICAgfTtcblxuICAgIGlmIChpZC5pbmNsdWRlcygneW9sbycpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGV0ZWN0aW9uJyxcbiAgICAgICAgYmF0Y2hTaXplOiAxNixcbiAgICAgICAgYmFzZVV0aWxpemF0aW9uOiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5VdGlsaXphdGlvbi5kZXRlY3Rpb24sIGJhc2VDaGFyYWN0ZXJpc3RpY3MubWluVXRpbGl6YXRpb24pLFxuICAgICAgICBzcGVlZHVwRmFjdG9yOiAyLjgsXG4gICAgICAgIG1lbW9yeVNjYWxlOiAxLjMsXG4gICAgICAgIHRlbnNvckNvcmVVc2FnZTogYmFzZUNoYXJhY3RlcmlzdGljcy50ZW5zb3JDb3JlVXNhZ2UgKiAxLjIsXG4gICAgICAgIG1lbW9yeUJhbmR3aWR0aDogYmFzZUNoYXJhY3RlcmlzdGljcy5tZW1vcnlCYW5kd2lkdGggKiAxLjQsXG4gICAgICAgIGZlYXR1cmVzOiBbJ0lOVDggUXVhbnRpemF0aW9uJywgJ0NVREEgR3JhcGggQWNjZWxlcmF0aW9uJ10sXG4gICAgICAgIGJhc2VNZW1vcnk6IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pbk1lbW9yeUdCLmRldGVjdGlvbiwgYmFzZUNoYXJhY3RlcmlzdGljcy5iYXNlTWVtb3J5KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaWQuaW5jbHVkZXMoJ3N0YWJsZScpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZ2VuZXJhdGlvbicsXG4gICAgICAgIGJhdGNoU2l6ZTogMSxcbiAgICAgICAgYmFzZVV0aWxpemF0aW9uOiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5VdGlsaXphdGlvbi5nZW5lcmF0aW9uLCBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1pblV0aWxpemF0aW9uKSxcbiAgICAgICAgc3BlZWR1cEZhY3RvcjogMi4yLFxuICAgICAgICBtZW1vcnlTY2FsZTogMS41LFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGJhc2VDaGFyYWN0ZXJpc3RpY3MudGVuc29yQ29yZVVzYWdlICogMS41LFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6IGJhc2VDaGFyYWN0ZXJpc3RpY3MubWVtb3J5QmFuZHdpZHRoICogMS44LFxuICAgICAgICBmZWF0dXJlczogWydGUDE2IE1peGVkIFByZWNpc2lvbicsICdBdHRlbnRpb24gT3B0aW1pemF0aW9uJ10sXG4gICAgICAgIGJhc2VNZW1vcnk6IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pbk1lbW9yeUdCLmdlbmVyYXRpb24sIGJhc2VDaGFyYWN0ZXJpc3RpY3MuYmFzZU1lbW9yeSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBDTk4gY2hhcmFjdGVyaXN0aWNzIHdpdGggcmVhbGlzdGljIG1pbmltdW1zXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjbm4nLFxuICAgICAgYmF0Y2hTaXplOiAzMixcbiAgICAgIGJhc2VVdGlsaXphdGlvbjogTWF0aC5tYXgodGhpcy5HUFVfU1BFQ1MubWluVXRpbGl6YXRpb24uY25uLCBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1pblV0aWxpemF0aW9uKSxcbiAgICAgIHNwZWVkdXBGYWN0b3I6IDIuMixcbiAgICAgIG1lbW9yeVNjYWxlOiAxLjIsXG4gICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGJhc2VDaGFyYWN0ZXJpc3RpY3MudGVuc29yQ29yZVVzYWdlLFxuICAgICAgbWVtb3J5QmFuZHdpZHRoOiBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1lbW9yeUJhbmR3aWR0aCxcbiAgICAgIGZlYXR1cmVzOiBbJ1RlbnNvclJUIEluZmVyZW5jZScsICdLZXJuZWwgRnVzaW9uJ10sXG4gICAgICBiYXNlTWVtb3J5OiBiYXNlQ2hhcmFjdGVyaXN0aWNzLmJhc2VNZW1vcnlcbiAgICB9O1xuICB9XG5cbiAgY2FsY3VsYXRlTWV0cmljcyhhbmFseXNpc1Jlc3VsdDogQW5hbHlzaXNSZXN1bHQgfCBudWxsLCBncHVFbmFibGVkOiBib29sZWFuKSB7XG4gICAgaWYgKCFhbmFseXNpc1Jlc3VsdD8uZ3JhcGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRNZXRyaWNzKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZU1ldHJpY3MgPSB0aGlzLmNhbGN1bGF0ZVdpdGhQb2xhcnMoYW5hbHlzaXNSZXN1bHQpO1xuICAgIGNvbnN0IGNoYXJhY3RlcmlzdGljcyA9IHRoaXMuZ2V0TW9kZWxDaGFyYWN0ZXJpc3RpY3MoXG4gICAgICBhbmFseXNpc1Jlc3VsdC5ncmFwaC5tZXRhZGF0YS5tb2RlbElkLFxuICAgICAgYmFzZU1ldHJpY3MudG90YWxGbG9wcyxcbiAgICAgIGJhc2VNZXRyaWNzLnRvdGFsTWVtb3J5XG4gICAgKTtcblxuICAgIGNvbnN0IGNwdU1ldHJpY3MgPSB7XG4gICAgICBmcHM6IGJhc2VNZXRyaWNzLmZwcyxcbiAgICAgIGxhdGVuY3k6IGJhc2VNZXRyaWNzLmxhdGVuY3ksXG4gICAgICBtZW1vcnk6IGJhc2VNZXRyaWNzLm1lbW9yeSxcbiAgICAgIHV0aWxpemF0aW9uOiBiYXNlTWV0cmljcy51dGlsaXphdGlvblxuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gb25seSBDUFUgbWV0cmljcyB3aGVuIEdQVSBpcyBkaXNhYmxlZFxuICAgIGlmICghZ3B1RW5hYmxlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3B1TWV0cmljcyxcbiAgICAgICAgZ3B1TWV0cmljczogbnVsbCwgLy8gVGhpcyB3aWxsIG1ha2UgdGhlIEdQVSBzZWN0aW9uIG5vdCByZW5kZXJcbiAgICAgICAgbnZPcHRpbWl6YXRpb25zOiB7XG4gICAgICAgICAgc3BlZWR1cDogYCR7Y2hhcmFjdGVyaXN0aWNzLnNwZWVkdXBGYWN0b3IudG9GaXhlZCgxKX14YCwgLy8gS2VlcCBzaG93aW5nIHBvdGVudGlhbCBzcGVlZHVwXG4gICAgICAgICAgYmF0Y2hTaXplOiBjaGFyYWN0ZXJpc3RpY3MuYmF0Y2hTaXplXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRnVsbCBHUFUgbWV0cmljcyB3aGVuIGVuYWJsZWRcbiAgICBjb25zdCBncHVNZXRyaWNzID0ge1xuICAgICAgZnBzOiBjcHVNZXRyaWNzLmZwcyAqIGNoYXJhY3RlcmlzdGljcy5zcGVlZHVwRmFjdG9yLFxuICAgICAgbGF0ZW5jeTogY3B1TWV0cmljcy5sYXRlbmN5IC8gY2hhcmFjdGVyaXN0aWNzLnNwZWVkdXBGYWN0b3IsXG4gICAgICBtZW1vcnk6IGNwdU1ldHJpY3MubWVtb3J5ICogY2hhcmFjdGVyaXN0aWNzLm1lbW9yeVNjYWxlLFxuICAgICAgdXRpbGl6YXRpb246IE1hdGgubWluKDg1LCBiYXNlTWV0cmljcy51dGlsaXphdGlvbiAqIDAuNilcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNwdU1ldHJpY3MsXG4gICAgICBncHVNZXRyaWNzLFxuICAgICAgbnZPcHRpbWl6YXRpb25zOiB7XG4gICAgICAgIHRlbnNvckNvcmVVc2FnZTogYCR7Y2hhcmFjdGVyaXN0aWNzLnRlbnNvckNvcmVVc2FnZS50b0ZpeGVkKDEpfSVgLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6IGAke2NoYXJhY3RlcmlzdGljcy5tZW1vcnlCYW5kd2lkdGgudG9GaXhlZCgxKX0gVEIvc2AsXG4gICAgICAgIHNwZWVkdXA6IGAke2NoYXJhY3RlcmlzdGljcy5zcGVlZHVwRmFjdG9yLnRvRml4ZWQoMSl9eGAsXG4gICAgICAgIGJhdGNoU2l6ZTogY2hhcmFjdGVyaXN0aWNzLmJhdGNoU2l6ZVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldERlZmF1bHRNZXRyaWNzKCkge1xuICAgIGNvbnN0IGRlZmF1bHRNZXRyaWNzID0ge1xuICAgICAgZnBzOiAwLFxuICAgICAgbGF0ZW5jeTogMCxcbiAgICAgIG1lbW9yeTogMCxcbiAgICAgIHV0aWxpemF0aW9uOiAwXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgY3B1TWV0cmljczogZGVmYXVsdE1ldHJpY3MsXG4gICAgICBncHVNZXRyaWNzOiBudWxsLFxuICAgICAgbnZPcHRpbWl6YXRpb25zOiBudWxsXG4gICAgfTtcbiAgfVxufSAiXSwibmFtZXMiOlsiRGF0YUZyYW1lIiwic2VsZWN0IiwiY29sdW1uIiwiZGF0YSIsImxlbmd0aCIsInN1bSIsIm1lYW4iLCJyZWR1Y2UiLCJhY2MiLCJyb3ciLCJmcm9tUmVjb3JkcyIsInJlY29yZHMiLCJjb25zdHJ1Y3RvciIsIlBlcmZvcm1hbmNlQ2FsY3VsYXRvciIsImNhbGN1bGF0ZVdpdGhQb2xhcnMiLCJhbmFseXNpc1Jlc3VsdCIsImxheWVycyIsImdyYXBoIiwidG90YWxGbG9wcyIsImxheWVyIiwiZmxvcHMiLCJ0b3RhbE1lbW9yeSIsIm1lbW9yeSIsInRvdGFsUGFyYW1zIiwicGFyYW1ldGVycyIsInV0aWxpemF0aW9uU2NhbGUiLCJNYXRoIiwibWF4IiwibWluIiwiZnBzIiwibGF0ZW5jeSIsInV0aWxpemF0aW9uIiwiZWZmaWNpZW5jeSIsIm1lbW9yeUVmZmljaWVuY3kiLCJlIiwiY29uc29sZSIsImVycm9yIiwiZ2V0TW9kZWxDaGFyYWN0ZXJpc3RpY3MiLCJtb2RlbElkIiwiaWQiLCJ0b0xvd2VyQ2FzZSIsImZsb3BzSW5URmxvcHMiLCJtZW1vcnlJbkdCIiwiYmFzZUNoYXJhY3RlcmlzdGljcyIsIm1pblV0aWxpemF0aW9uIiwidGVuc29yQ29yZVVzYWdlIiwibWVtb3J5QmFuZHdpZHRoIiwiYmFzZU1lbW9yeSIsIkdQVV9TUEVDUyIsIm1pbk1lbW9yeUdCIiwiY25uIiwiaW5jbHVkZXMiLCJ0eXBlIiwiYmF0Y2hTaXplIiwiYmFzZVV0aWxpemF0aW9uIiwiZGV0ZWN0aW9uIiwic3BlZWR1cEZhY3RvciIsIm1lbW9yeVNjYWxlIiwiZmVhdHVyZXMiLCJnZW5lcmF0aW9uIiwiY2FsY3VsYXRlTWV0cmljcyIsImdwdUVuYWJsZWQiLCJnZXREZWZhdWx0TWV0cmljcyIsImJhc2VNZXRyaWNzIiwiY2hhcmFjdGVyaXN0aWNzIiwibWV0YWRhdGEiLCJjcHVNZXRyaWNzIiwiZ3B1TWV0cmljcyIsIm52T3B0aW1pemF0aW9ucyIsInNwZWVkdXAiLCJ0b0ZpeGVkIiwiZGVmYXVsdE1ldHJpY3MiLCJwZWFrVGZsb3BzIiwidGVuc29yQ29yZXMiLCJtYXhCYXRjaFNpemUiLCJ0cmFuc2Zvcm1lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/performance.ts\n"));

/***/ })

});