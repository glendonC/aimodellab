"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/performance.ts":
/*!**********************************!*\
  !*** ./lib/model/performance.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceCalculator: function() { return /* binding */ PerformanceCalculator; }\n/* harmony export */ });\n// Polars-like DataFrame implementation for browser\nclass DataFrame {\n    select(column) {\n        if (!this.data.length) {\n            return {\n                sum: ()=>0,\n                mean: ()=>0\n            };\n        }\n        return {\n            sum: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0),\n            mean: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0) / this.data.length\n        };\n    }\n    static fromRecords(records) {\n        return new DataFrame(records || []);\n    }\n    constructor(data){\n        this.data = data || []; // Ensure data is never undefined\n    }\n}\nclass PerformanceCalculator {\n    calculateWithPolars(analysisResult) {\n        const { metadata, layers = [] } = analysisResult.graph || {};\n        // Create DataFrame with layer metrics and handle missing data\n        const df = DataFrame.fromRecords(layers);\n        // Calculate aggregated metrics with safe fallbacks\n        const metrics = {\n            totalFlops: df.select(\"flops\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) || 0,\n            meanFlops: df.select(\"flops\").mean(),\n            totalMemory: df.select(\"memory\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0,\n            paramsPerLayer: df.select(\"parameters\").mean()\n        };\n        // Calculate CPU performance metrics with safe values\n        return {\n            fps: Math.min(120, 1000 / Math.max(1, metrics.totalFlops / 1e9)),\n            latency: Math.max(0.5, metrics.totalFlops / 1e9 * 2),\n            memory: Math.max(0.1, metrics.totalMemory / (1024 * 1024 * 1024)),\n            utilization: Math.min(95, metrics.totalFlops / 1e9 * 0.45)\n        };\n    }\n    getTensorRTOptimizations(modelId, totalFlops) {\n        var _modelId_toLowerCase;\n        const id = (_modelId_toLowerCase = modelId === null || modelId === void 0 ? void 0 : modelId.toLowerCase()) !== null && _modelId_toLowerCase !== void 0 ? _modelId_toLowerCase : \"default\";\n        // TensorRT optimization profiles based on model type\n        if (id.includes(\"yolo\")) {\n            return {\n                speedup: 5.5,\n                tensorCoreUsage: Math.min(95, totalFlops / 1e12 * 35),\n                memoryBandwidth: totalFlops / 1e12 * 1.2,\n                optimizations: [\n                    \"INT8 Quantization\",\n                    \"CUDA Graph Acceleration\",\n                    \"Layer Fusion\"\n                ]\n            };\n        }\n        if (id.includes(\"stable\")) {\n            return {\n                speedup: 4.2,\n                tensorCoreUsage: Math.min(90, totalFlops / 1e12 * 40),\n                memoryBandwidth: totalFlops / 1e12 * 1.8,\n                optimizations: [\n                    \"FP16 Mixed Precision\",\n                    \"Attention Optimization\",\n                    \"Dynamic Batching\"\n                ]\n            };\n        }\n        // Default optimizations for CNNs\n        return {\n            speedup: 4.0,\n            tensorCoreUsage: Math.min(85, totalFlops / 1e12 * 30),\n            memoryBandwidth: totalFlops / 1e12 * 0.9,\n            optimizations: [\n                \"TensorRT Inference\",\n                \"Kernel Autotuning\",\n                \"Layer Fusion\"\n            ]\n        };\n    }\n    calculateMetrics(analysisResult, gpuEnabled) {\n        var _analysisResult_graph_metadata, _analysisResult_graph_metadata1;\n        if (!(analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.graph)) {\n            const defaultMetrics = {\n                fps: 0,\n                latency: 0,\n                memory: 0,\n                utilization: 0\n            };\n            return {\n                cpuMetrics: defaultMetrics,\n                gpuMetrics: defaultMetrics,\n                nvOptimizations: null\n            };\n        }\n        // Calculate base metrics using our Polars-like implementation\n        const cpuMetrics = this.calculateWithPolars(analysisResult);\n        if (!gpuEnabled) {\n            return {\n                cpuMetrics,\n                gpuMetrics: cpuMetrics,\n                nvOptimizations: null\n            };\n        }\n        // Get TensorRT optimizations with safe values\n        const trt = this.getTensorRTOptimizations((_analysisResult_graph_metadata = analysisResult.graph.metadata) === null || _analysisResult_graph_metadata === void 0 ? void 0 : _analysisResult_graph_metadata.modelId, ((_analysisResult_graph_metadata1 = analysisResult.graph.metadata) === null || _analysisResult_graph_metadata1 === void 0 ? void 0 : _analysisResult_graph_metadata1.totalFlops) || 0);\n        // Apply GPU acceleration\n        const gpuMetrics = {\n            fps: Math.min(2000, cpuMetrics.fps * trt.speedup),\n            latency: Math.max(0.1, cpuMetrics.latency / trt.speedup),\n            memory: cpuMetrics.memory * 0.6,\n            utilization: Math.min(85, trt.tensorCoreUsage * 0.8)\n        };\n        const nvOptimizations = {\n            tensorCoreUsage: \"\".concat(trt.tensorCoreUsage.toFixed(1), \"%\"),\n            memoryBandwidth: \"\".concat(trt.memoryBandwidth.toFixed(1), \" TB/s\"),\n            speedup: \"\".concat(trt.speedup.toFixed(1), \"x\"),\n            features: trt.optimizations\n        };\n        return {\n            cpuMetrics,\n            gpuMetrics,\n            nvOptimizations\n        };\n    }\n    constructor(){\n        // Hardware specs based on NVIDIA A100\n        this.GPU_SPECS = {\n            peakTflops: 312,\n            memoryBandwidth: 2048,\n            tensorCores: 432,\n            maxBatchSize: 32\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsbURBQW1EO0FBQ25ELE1BQU1BO0lBT0pDLE9BQU9DLE1BQTBCLEVBQUU7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7WUFDckIsT0FBTztnQkFDTEMsS0FBSyxJQUFNO2dCQUNYQyxNQUFNLElBQU07WUFDZDtRQUNGO1FBRUEsT0FBTztZQUNMRCxLQUFLLElBQU0sSUFBSSxDQUFDRixJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJO1lBQ3BFSSxNQUFNLElBQU0sSUFBSSxDQUFDSCxJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU07UUFDNUY7SUFDRjtJQUVBLE9BQU9NLFlBQVlDLE9BQW1DLEVBQUU7UUFDdEQsT0FBTyxJQUFJWCxVQUFVVyxXQUFXLEVBQUU7SUFDcEM7SUFwQkFDLFlBQVlULElBQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLFFBQVEsRUFBRSxFQUFHLGlDQUFpQztJQUM1RDtBQW1CRjtBQUVPLE1BQU1VO0lBU0hDLG9CQUFvQkMsY0FBOEIsRUFBRTtRQUMxRCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEVBQUUsR0FBR0YsZUFBZUcsS0FBSyxJQUFJLENBQUM7UUFFM0QsOERBQThEO1FBQzlELE1BQU1DLEtBQUtuQixVQUFVVSxXQUFXLENBQUNPO1FBRWpDLG1EQUFtRDtRQUNuRCxNQUFNRyxVQUFVO1lBQ2RDLFlBQVlGLEdBQUdsQixNQUFNLENBQUMsU0FBU0ksR0FBRyxPQUFNVyxxQkFBQUEsK0JBQUFBLFNBQVVL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QUFHa0IsSUFBSVYsT0FBTztZQUN2RFAsUUFBUWMsV0FBV2QsTUFBTSxHQUFHO1lBQzVCQyxhQUFhTCxLQUFLQyxHQUFHLENBQUMsSUFBSW9CLElBQUlULGVBQWUsR0FBRztRQUNsRDtRQUVBLE1BQU1RLGtCQUFrQjtZQUN0QlIsaUJBQWlCLEdBQWtDLE9BQS9CUyxJQUFJVCxlQUFlLENBQUNVLE9BQU8sQ0FBQyxJQUFHO1lBQ25EVCxpQkFBaUIsR0FBa0MsT0FBL0JRLElBQUlSLGVBQWUsQ0FBQ1MsT0FBTyxDQUFDLElBQUc7WUFDbkRYLFNBQVMsR0FBMEIsT0FBdkJVLElBQUlWLE9BQU8sQ0FBQ1csT0FBTyxDQUFDLElBQUc7WUFDbkNDLFVBQVVGLElBQUlQLGFBQWE7UUFDN0I7UUFFQSxPQUFPO1lBQUVJO1lBQVlDO1lBQVlDO1FBQWdCO0lBQ25EOztRQXRIQSxzQ0FBc0M7YUFDckJJLFlBQVk7WUFDM0JDLFlBQVk7WUFDWlosaUJBQWlCO1lBQ2pCYSxhQUFhO1lBQ2JDLGNBQWM7UUFDaEI7O0FBaUhGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cz9kYjU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQW5hbHlzaXNSZXN1bHQsIExheWVyTWV0cmljcyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBQb2xhcnMtbGlrZSBEYXRhRnJhbWUgaW1wbGVtZW50YXRpb24gZm9yIGJyb3dzZXJcbmNsYXNzIERhdGFGcmFtZSB7XG4gIHByaXZhdGUgZGF0YTogTGF5ZXJNZXRyaWNzW107XG5cbiAgY29uc3RydWN0b3IoZGF0YTogTGF5ZXJNZXRyaWNzW10pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IFtdOyAgLy8gRW5zdXJlIGRhdGEgaXMgbmV2ZXIgdW5kZWZpbmVkXG4gIH1cblxuICBzZWxlY3QoY29sdW1uOiBrZXlvZiBMYXllck1ldHJpY3MpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1bTogKCkgPT4gMCxcbiAgICAgICAgbWVhbjogKCkgPT4gMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VtOiAoKSA9PiB0aGlzLmRhdGEucmVkdWNlKChhY2MsIHJvdykgPT4gYWNjICsgKHJvd1tjb2x1bW5dIHx8IDApLCAwKSxcbiAgICAgIG1lYW46ICgpID0+IHRoaXMuZGF0YS5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgKyAocm93W2NvbHVtbl0gfHwgMCksIDApIC8gdGhpcy5kYXRhLmxlbmd0aFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlY29yZHMocmVjb3JkczogTGF5ZXJNZXRyaWNzW10gfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IERhdGFGcmFtZShyZWNvcmRzIHx8IFtdKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VDYWxjdWxhdG9yIHtcbiAgLy8gSGFyZHdhcmUgc3BlY3MgYmFzZWQgb24gTlZJRElBIEExMDBcbiAgcHJpdmF0ZSByZWFkb25seSBHUFVfU1BFQ1MgPSB7XG4gICAgcGVha1RmbG9wczogMzEyLCAgICAgICAgICAvLyAzMTIgVEZMT1BTIEZQMTZcbiAgICBtZW1vcnlCYW5kd2lkdGg6IDIwNDgsICAgIC8vIDIgVEIvcyB3aXRoIE5WTGlua1xuICAgIHRlbnNvckNvcmVzOiA0MzIsXG4gICAgbWF4QmF0Y2hTaXplOiAzMlxuICB9O1xuXG4gIHByaXZhdGUgY2FsY3VsYXRlV2l0aFBvbGFycyhhbmFseXNpc1Jlc3VsdDogQW5hbHlzaXNSZXN1bHQpIHtcbiAgICBjb25zdCB7IG1ldGFkYXRhLCBsYXllcnMgPSBbXSB9ID0gYW5hbHlzaXNSZXN1bHQuZ3JhcGggfHwge307XG4gICAgXG4gICAgLy8gQ3JlYXRlIERhdGFGcmFtZSB3aXRoIGxheWVyIG1ldHJpY3MgYW5kIGhhbmRsZSBtaXNzaW5nIGRhdGFcbiAgICBjb25zdCBkZiA9IERhdGFGcmFtZS5mcm9tUmVjb3JkcyhsYXllcnMpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGFnZ3JlZ2F0ZWQgbWV0cmljcyB3aXRoIHNhZmUgZmFsbGJhY2tzXG4gICAgY29uc3QgbWV0cmljcyA9IHtcbiAgICAgIHRvdGFsRmxvcHM6IGRmLnNlbGVjdCgnZmxvcHMnKS5zdW0oKSB8fCBtZXRhZGF0YT8udG90YWxGbG9wcyB8fCAwLFxuICAgICAgbWVhbkZsb3BzOiBkZi5zZWxlY3QoJ2Zsb3BzJykubWVhbigpLFxuICAgICAgdG90YWxNZW1vcnk6IGRmLnNlbGVjdCgnbWVtb3J5Jykuc3VtKCkgfHwgbWV0YWRhdGE/LnRvdGFsTWVtb3J5IHx8IDAsXG4gICAgICBwYXJhbXNQZXJMYXllcjogZGYuc2VsZWN0KCdwYXJhbWV0ZXJzJykubWVhbigpXG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSBDUFUgcGVyZm9ybWFuY2UgbWV0cmljcyB3aXRoIHNhZmUgdmFsdWVzXG4gICAgcmV0dXJuIHtcbiAgICAgIGZwczogTWF0aC5taW4oMTIwLCAxMDAwIC8gTWF0aC5tYXgoMSwgbWV0cmljcy50b3RhbEZsb3BzIC8gMWU5KSksXG4gICAgICBsYXRlbmN5OiBNYXRoLm1heCgwLjUsIChtZXRyaWNzLnRvdGFsRmxvcHMgLyAxZTkpICogMiksXG4gICAgICBtZW1vcnk6IE1hdGgubWF4KDAuMSwgbWV0cmljcy50b3RhbE1lbW9yeSAvICgxMDI0ICogMTAyNCAqIDEwMjQpKSxcbiAgICAgIHV0aWxpemF0aW9uOiBNYXRoLm1pbig5NSwgKG1ldHJpY3MudG90YWxGbG9wcyAvIDFlOSkgKiAwLjQ1KVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldFRlbnNvclJUT3B0aW1pemF0aW9ucyhtb2RlbElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHRvdGFsRmxvcHM6IG51bWJlcikge1xuICAgIGNvbnN0IGlkID0gbW9kZWxJZD8udG9Mb3dlckNhc2UoKSA/PyAnZGVmYXVsdCc7XG4gICAgXG4gICAgLy8gVGVuc29yUlQgb3B0aW1pemF0aW9uIHByb2ZpbGVzIGJhc2VkIG9uIG1vZGVsIHR5cGVcbiAgICBpZiAoaWQuaW5jbHVkZXMoJ3lvbG8nKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BlZWR1cDogNS41LFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IE1hdGgubWluKDk1LCAodG90YWxGbG9wcyAvIDFlMTIpICogMzUpLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6ICh0b3RhbEZsb3BzIC8gMWUxMikgKiAxLjIsXG4gICAgICAgIG9wdGltaXphdGlvbnM6IFtcbiAgICAgICAgICAnSU5UOCBRdWFudGl6YXRpb24nLFxuICAgICAgICAgICdDVURBIEdyYXBoIEFjY2VsZXJhdGlvbicsXG4gICAgICAgICAgJ0xheWVyIEZ1c2lvbidcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGlkLmluY2x1ZGVzKCdzdGFibGUnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BlZWR1cDogNC4yLFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IE1hdGgubWluKDkwLCAodG90YWxGbG9wcyAvIDFlMTIpICogNDApLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6ICh0b3RhbEZsb3BzIC8gMWUxMikgKiAxLjgsXG4gICAgICAgIG9wdGltaXphdGlvbnM6IFtcbiAgICAgICAgICAnRlAxNiBNaXhlZCBQcmVjaXNpb24nLFxuICAgICAgICAgICdBdHRlbnRpb24gT3B0aW1pemF0aW9uJyxcbiAgICAgICAgICAnRHluYW1pYyBCYXRjaGluZydcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gRGVmYXVsdCBvcHRpbWl6YXRpb25zIGZvciBDTk5zXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwZWVkdXA6IDQuMCxcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogTWF0aC5taW4oODUsICh0b3RhbEZsb3BzIC8gMWUxMikgKiAzMCksXG4gICAgICBtZW1vcnlCYW5kd2lkdGg6ICh0b3RhbEZsb3BzIC8gMWUxMikgKiAwLjksXG4gICAgICBvcHRpbWl6YXRpb25zOiBbXG4gICAgICAgICdUZW5zb3JSVCBJbmZlcmVuY2UnLFxuICAgICAgICAnS2VybmVsIEF1dG90dW5pbmcnLFxuICAgICAgICAnTGF5ZXIgRnVzaW9uJ1xuICAgICAgXVxuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVNZXRyaWNzKGFuYWx5c2lzUmVzdWx0OiBBbmFseXNpc1Jlc3VsdCB8IG51bGwsIGdwdUVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoIWFuYWx5c2lzUmVzdWx0Py5ncmFwaCkge1xuICAgICAgY29uc3QgZGVmYXVsdE1ldHJpY3MgPSB7XG4gICAgICAgIGZwczogMCxcbiAgICAgICAgbGF0ZW5jeTogMCxcbiAgICAgICAgbWVtb3J5OiAwLFxuICAgICAgICB1dGlsaXphdGlvbjogMFxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNwdU1ldHJpY3M6IGRlZmF1bHRNZXRyaWNzLFxuICAgICAgICBncHVNZXRyaWNzOiBkZWZhdWx0TWV0cmljcyxcbiAgICAgICAgbnZPcHRpbWl6YXRpb25zOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBiYXNlIG1ldHJpY3MgdXNpbmcgb3VyIFBvbGFycy1saWtlIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgY3B1TWV0cmljcyA9IHRoaXMuY2FsY3VsYXRlV2l0aFBvbGFycyhhbmFseXNpc1Jlc3VsdCk7XG5cbiAgICBpZiAoIWdwdUVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7IGNwdU1ldHJpY3MsIGdwdU1ldHJpY3M6IGNwdU1ldHJpY3MsIG52T3B0aW1pemF0aW9uczogbnVsbCB9O1xuICAgIH1cblxuICAgIC8vIEdldCBUZW5zb3JSVCBvcHRpbWl6YXRpb25zIHdpdGggc2FmZSB2YWx1ZXNcbiAgICBjb25zdCB0cnQgPSB0aGlzLmdldFRlbnNvclJUT3B0aW1pemF0aW9ucyhcbiAgICAgIGFuYWx5c2lzUmVzdWx0LmdyYXBoLm1ldGFkYXRhPy5tb2RlbElkLFxuICAgICAgYW5hbHlzaXNSZXN1bHQuZ3JhcGgubWV0YWRhdGE/LnRvdGFsRmxvcHMgfHwgMFxuICAgICk7XG5cbiAgICAvLyBBcHBseSBHUFUgYWNjZWxlcmF0aW9uXG4gICAgY29uc3QgZ3B1TWV0cmljcyA9IHtcbiAgICAgIGZwczogTWF0aC5taW4oMjAwMCwgY3B1TWV0cmljcy5mcHMgKiB0cnQuc3BlZWR1cCksXG4gICAgICBsYXRlbmN5OiBNYXRoLm1heCgwLjEsIGNwdU1ldHJpY3MubGF0ZW5jeSAvIHRydC5zcGVlZHVwKSxcbiAgICAgIG1lbW9yeTogY3B1TWV0cmljcy5tZW1vcnkgKiAwLjYsXG4gICAgICB1dGlsaXphdGlvbjogTWF0aC5taW4oODUsIHRydC50ZW5zb3JDb3JlVXNhZ2UgKiAwLjgpXG4gICAgfTtcblxuICAgIGNvbnN0IG52T3B0aW1pemF0aW9ucyA9IHtcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogYCR7dHJ0LnRlbnNvckNvcmVVc2FnZS50b0ZpeGVkKDEpfSVgLFxuICAgICAgbWVtb3J5QmFuZHdpZHRoOiBgJHt0cnQubWVtb3J5QmFuZHdpZHRoLnRvRml4ZWQoMSl9IFRCL3NgLFxuICAgICAgc3BlZWR1cDogYCR7dHJ0LnNwZWVkdXAudG9GaXhlZCgxKX14YCxcbiAgICAgIGZlYXR1cmVzOiB0cnQub3B0aW1pemF0aW9uc1xuICAgIH07XG5cbiAgICByZXR1cm4geyBjcHVNZXRyaWNzLCBncHVNZXRyaWNzLCBudk9wdGltaXphdGlvbnMgfTtcbiAgfVxufSAiXSwibmFtZXMiOlsiRGF0YUZyYW1lIiwic2VsZWN0IiwiY29sdW1uIiwiZGF0YSIsImxlbmd0aCIsInN1bSIsIm1lYW4iLCJyZWR1Y2UiLCJhY2MiLCJyb3ciLCJmcm9tUmVjb3JkcyIsInJlY29yZHMiLCJjb25zdHJ1Y3RvciIsIlBlcmZvcm1hbmNlQ2FsY3VsYXRvciIsImNhbGN1bGF0ZVdpdGhQb2xhcnMiLCJhbmFseXNpc1Jlc3VsdCIsIm1ldGFkYXRhIiwibGF5ZXJzIiwiZ3JhcGgiLCJkZiIsIm1ldHJpY3MiLCJ0b3RhbEZsb3BzIiwibWVhbkZsb3BzIiwidG90YWxNZW1vcnkiLCJwYXJhbXNQZXJMYXllciIsImZwcyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJsYXRlbmN5IiwibWVtb3J5IiwidXRpbGl6YXRpb24iLCJnZXRUZW5zb3JSVE9wdGltaXphdGlvbnMiLCJtb2RlbElkIiwiaWQiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic3BlZWR1cCIsInRlbnNvckNvcmVVc2FnZSIsIm1lbW9yeUJhbmR3aWR0aCIsIm9wdGltaXphdGlvbnMiLCJjYWxjdWxhdGVNZXRyaWNzIiwiZ3B1RW5hYmxlZCIsImRlZmF1bHRNZXRyaWNzIiwiY3B1TWV0cmljcyIsImdwdU1ldHJpY3MiLCJudk9wdGltaXphdGlvbnMiLCJ0cnQiLCJ0b0ZpeGVkIiwiZmVhdHVyZXMiLCJHUFVfU1BFQ1MiLCJwZWFrVGZsb3BzIiwidGVuc29yQ29yZXMiLCJtYXhCYXRjaFNpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/performance.ts\n"));

/***/ })

});