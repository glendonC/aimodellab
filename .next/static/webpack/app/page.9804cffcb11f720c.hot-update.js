"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model-architectures.ts":
/*!************************************!*\
  !*** ./lib/model-architectures.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateBioBERTArchitecture: function() { return /* binding */ generateBioBERTArchitecture; },\n/* harmony export */   generateDINOv2Architecture: function() { return /* binding */ generateDINOv2Architecture; },\n/* harmony export */   generateDefaultArchitecture: function() { return /* binding */ generateDefaultArchitecture; },\n/* harmony export */   generateGPT2Architecture: function() { return /* binding */ generateGPT2Architecture; },\n/* harmony export */   generateLlama2Architecture: function() { return /* binding */ generateLlama2Architecture; },\n/* harmony export */   generateResNetArchitecture: function() { return /* binding */ generateResNetArchitecture; },\n/* harmony export */   generateStableDiffusionArchitecture: function() { return /* binding */ generateStableDiffusionArchitecture; },\n/* harmony export */   generateTransformerArchitecture: function() { return /* binding */ generateTransformerArchitecture; },\n/* harmony export */   generateViTArchitecture: function() { return /* binding */ generateViTArchitecture; },\n/* harmony export */   generateWhisperArchitecture: function() { return /* binding */ generateWhisperArchitecture; },\n/* harmony export */   generateYOLOv8Architecture: function() { return /* binding */ generateYOLOv8Architecture; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ generateResNetArchitecture,generateTransformerArchitecture,generateViTArchitecture,generateYOLOv8Architecture,generateStableDiffusionArchitecture,generateLlama2Architecture,generateGPT2Architecture,generateWhisperArchitecture,generateBioBERTArchitecture,generateDINOv2Architecture,generateDefaultArchitecture auto */ function generateResNetArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Initial convolution\n    nodes.push({\n        id: \"conv1\",\n        type: \"cnn\",\n        name: \"Conv1\",\n        params: 9408,\n        flops: 118013952,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"conv1\"\n    });\n    prevId = \"conv1\";\n    // ResNet blocks\n    const blocks = [\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\"\n    ];\n    blocks.forEach((block, i)=>{\n        // Each block has multiple residual units\n        for(let unit = 0; unit < 3; unit++){\n            const blockId = \"res\".concat(block, \"_\").concat(unit);\n            nodes.push({\n                id: blockId,\n                type: \"residual\",\n                name: \"ResBlock \".concat(block, \".\").concat(unit),\n                params: 1024 * 1024 * (i + 1),\n                flops: 5 * 1024 * 1024 * (i + 1),\n                memoryUsage: 3 * 1024 * 1024 * (i + 1)\n            });\n            edges.push({\n                source: prevId,\n                target: blockId\n            });\n            prevId = blockId;\n        }\n    });\n    // Final layers\n    nodes.push({\n        id: \"pool\",\n        type: \"mlp\",\n        name: \"Global Pool\",\n        params: 2048,\n        flops: 2048,\n        memoryUsage: 1024 * 512\n    });\n    edges.push({\n        source: prevId,\n        target: \"pool\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"FC 1000\",\n        params: 2048000,\n        flops: 2048000,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"pool\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateTransformerArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Encoder layers\n    for(let i = 0; i < 6; i++){\n        const attentionId = \"enc_attn_\".concat(i);\n        const ffnId = \"enc_ffn_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"attention\",\n            name: \"Encoder Self-Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: ffnId,\n            type: \"mlp\",\n            name: \"Encoder FFN \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Layer Norm \".concat(i),\n            params: 1024,\n            flops: 2048,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: ffnId\n        });\n        edges.push({\n            source: ffnId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    // Output projection\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Projection\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateViTArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Patch Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Patch embedding\n    nodes.push({\n        id: \"patch_embed\",\n        type: \"cnn\",\n        name: \"Patch Embedding\",\n        params: 590592,\n        flops: 47185920,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"patch_embed\"\n    });\n    prevId = \"patch_embed\";\n    // Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attentionId = \"transformer_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"transformer\",\n            name: \"Transformer Block \".concat(i),\n            params: 7 * 1024 * 1024,\n            flops: 28 * 1024 * 1024,\n            memoryUsage: 14 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: mlpId\n        });\n        prevId = mlpId;\n    }\n    // Classification head\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Classification Head\",\n        params: 768000,\n        flops: 768000,\n        memoryUsage: 1024 * 768\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateYOLOv8Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Image\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Backbone layers\n    const backboneLayers = [\n        \"P3\",\n        \"P4\",\n        \"P5\"\n    ];\n    backboneLayers.forEach((layer, i)=>{\n        const convId = \"backbone_\".concat(layer);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Backbone \".concat(layer),\n            params: 256 * 256 * (i + 1),\n            flops: 1024 * 1024 * (i + 1),\n            memoryUsage: 2 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    });\n    // FPN layers with residual connections\n    backboneLayers.forEach((layer, i)=>{\n        const fpnId = \"fpn_\".concat(layer);\n        nodes.push({\n            id: fpnId,\n            type: \"residual\",\n            name: \"FPN \".concat(layer),\n            params: 256 * 256,\n            flops: 512 * 512,\n            memoryUsage: 1024 * 1024\n        });\n        edges.push({\n            source: \"backbone_\".concat(layer),\n            target: fpnId\n        });\n    });\n    // Detection heads\n    [\n        \"small\",\n        \"medium\",\n        \"large\"\n    ].forEach((size, i)=>{\n        const headId = \"head_\".concat(size);\n        const detectionId = \"detection_\".concat(size);\n        nodes.push({\n            id: headId,\n            type: \"graph\",\n            name: \"\".concat(size, \" Detection Head\"),\n            params: 256 * (80 + 4),\n            flops: 512 * 512,\n            memoryUsage: 1024 * 1024\n        });\n        edges.push({\n            source: \"fpn_\".concat(backboneLayers[i]),\n            target: headId\n        });\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Detection Output\",\n        params: 1000,\n        flops: 1000,\n        memoryUsage: 512 * 1024\n    });\n    edges.push({\n        source: \"head_large\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Stable Diffusion\nfunction generateStableDiffusionArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Text + Noise Input\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Text encoder (CLIP)\n    nodes.push({\n        id: \"text_encoder\",\n        type: \"transformer\",\n        name: \"CLIP Text Encoder\",\n        params: 123 * 1024 * 1024,\n        flops: 246 * 1024 * 1024,\n        memoryUsage: 512 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"text_encoder\"\n    });\n    // UNet blocks with attention\n    const blockNames = [\n        \"Down_1\",\n        \"Down_2\",\n        \"Mid\",\n        \"Up_1\",\n        \"Up_2\"\n    ];\n    blockNames.forEach((block, i)=>{\n        const blockId = \"unet_\".concat(block.toLowerCase());\n        const attnId = \"attn_\".concat(block.toLowerCase());\n        nodes.push({\n            id: blockId,\n            type: \"residual\",\n            name: \"UNet \".concat(block),\n            params: 512 * 512,\n            flops: 1024 * 1024,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Cross Attention \".concat(block),\n            params: 512 * 512,\n            flops: 1024 * 1024,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        edges.push({\n            source: i === 0 ? \"text_encoder\" : prevId,\n            target: blockId\n        });\n        edges.push({\n            source: blockId,\n            target: attnId\n        });\n        prevId = attnId;\n    });\n    // VAE decoder\n    nodes.push({\n        id: \"vae_decoder\",\n        type: \"cnn\",\n        name: \"VAE Decoder\",\n        params: 256 * 1024,\n        flops: 512 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"vae_decoder\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Generated Image\",\n        params: 3 * 1024 * 1024,\n        flops: 6 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"vae_decoder\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Llama 2\nfunction generateLlama2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token Embedding\",\n        params: 32000 * 4096,\n        flops: 4096,\n        memoryUsage: 4 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // Transformer Blocks\n    for(let i = 0; i < 32; i++){\n        const attnId = \"attn_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId = \"norm_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 4 * 4096 * 4096,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 4096 * 11008,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"RMSNorm \".concat(i),\n            params: 4096,\n            flops: 4096,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 4096 * 32000,\n        flops: 4096 * 32000,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateGPT2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token Embedding\",\n        params: 50257 * 768,\n        flops: 768,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // 12 Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attnId = \"attn_\".concat(i);\n        const normId1 = \"norm1_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId2 = \"norm2_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 3 * 768 * 768,\n            flops: 12 * 1024 * 1024,\n            memoryUsage: 6 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId1,\n            type: \"normalization\",\n            name: \"Layer Norm 1 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 768 * 3072 + 3072 * 768,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId2,\n            type: \"normalization\",\n            name: \"Layer Norm 2 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: normId1\n        });\n        edges.push({\n            source: normId1,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId2\n        });\n        prevId = normId2;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 768 * 50257,\n        flops: 768 * 50257,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateWhisperArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Audio Input\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Conv Frontend\n    for(let i = 0; i < 2; i++){\n        const convId = \"conv_\".concat(i);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Conv Block \".concat(i),\n            params: 512 * 512 * 3 * 3,\n            flops: 512 * 512 * 3 * 3 * 80,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    }\n    // Encoder blocks (6 for base model)\n    for(let i = 0; i < 6; i++){\n        const attnId = \"enc_attn_\".concat(i);\n        const mlpId = \"enc_mlp_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Encoder Attention \".concat(i),\n            params: 3 * 512 * 512,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"Encoder MLP \".concat(i),\n            params: 512 * 2048 + 2048 * 512,\n            flops: 4 * 1024 * 1024,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Encoder Norm \".concat(i),\n            params: 2 * 512,\n            flops: 512,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 512 * 51865,\n        flops: 512 * 51865,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateBioBERTArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token & Position Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token + Position Embedding\",\n        params: 28996 * 768 + 512 * 768,\n        flops: 768 * 2,\n        memoryUsage: 3 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // 12 Transformer Encoder blocks\n    for(let i = 0; i < 12; i++){\n        const attnId = \"attn_\".concat(i);\n        const normId1 = \"norm1_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId2 = \"norm2_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Multi-Head Attention \".concat(i),\n            params: 768 * 768 * 4,\n            flops: 12 * 1024 * 1024,\n            memoryUsage: 6 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId1,\n            type: \"normalization\",\n            name: \"Layer Norm 1 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"Feed Forward \".concat(i),\n            params: 768 * 3072 + 3072 * 768,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId2,\n            type: \"normalization\",\n            name: \"Layer Norm 2 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: normId1\n        });\n        edges.push({\n            source: normId1,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId2\n        });\n        prevId = normId2;\n    }\n    // Pooler and Output\n    nodes.push({\n        id: \"pooler\",\n        type: \"mlp\",\n        name: \"Pooler\",\n        params: 768 * 768,\n        flops: 768 * 768,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"pooler\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 768 * 2,\n        flops: 768 * 2,\n        memoryUsage: 1024 * 64\n    });\n    edges.push({\n        source: \"pooler\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateDINOv2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Patch Embedding\n    nodes.push({\n        id: \"patch_embed\",\n        type: \"cnn\",\n        name: \"Patch Embedding\",\n        params: 384 * (14 * 14 * 3),\n        flops: 384 * 196 * 3,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"patch_embed\"\n    });\n    prevId = \"patch_embed\";\n    // 12 Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attnId = \"attn_\".concat(i);\n        const normId1 = \"norm1_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId2 = \"norm2_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 384 * 384 * 4,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId1,\n            type: \"normalization\",\n            name: \"Layer Norm 1 (\".concat(i, \")\"),\n            params: 2 * 384,\n            flops: 384,\n            memoryUsage: 1024 * 32\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 384 * 1536 + 1536 * 384,\n            flops: 6 * 1024 * 1024,\n            memoryUsage: 3 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId2,\n            type: \"normalization\",\n            name: \"Layer Norm 2 (\".concat(i, \")\"),\n            params: 2 * 384,\n            flops: 384,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: normId1\n        });\n        edges.push({\n            source: normId1,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId2\n        });\n        prevId = normId2;\n    }\n    // Projection head\n    nodes.push({\n        id: \"projection\",\n        type: \"mlp\",\n        name: \"Projection Head\",\n        params: 384 * 2048,\n        flops: 384 * 2048,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"projection\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Embeddings\",\n        params: 2048 * 256,\n        flops: 2048 * 256,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"projection\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateDefaultArchitecture() {\n    return generateResNetArchitecture();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC1hcmNoaXRlY3R1cmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OzBXQUlPLFNBQVNBO0lBQ2QsTUFBTUMsUUFBUTtRQUNaO1lBQ0VDLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLFFBQVE7WUFDUkMsT0FBTztZQUNQQyxhQUFhLE9BQU87UUFDdEI7S0FDRDtJQUVELE1BQU1DLFFBQVEsRUFBRTtJQUNoQixJQUFJQyxTQUFTO0lBRWIsc0JBQXNCO0lBQ3RCUixNQUFNUyxJQUFJLENBQUM7UUFDVFIsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLGFBQWEsSUFBSSxPQUFPO0lBQzFCO0lBQ0FDLE1BQU1FLElBQUksQ0FBQztRQUFFQyxRQUFRRjtRQUFRRyxRQUFRO0lBQVE7SUFDN0NILFNBQVM7SUFFVCxnQkFBZ0I7SUFDaEIsTUFBTUksU0FBUztRQUFDO1FBQUs7UUFBSztRQUFLO0tBQUk7SUFDbkNBLE9BQU9DLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUNyQix5Q0FBeUM7UUFDekMsSUFBSyxJQUFJQyxPQUFPLEdBQUdBLE9BQU8sR0FBR0EsT0FBUTtZQUNuQyxNQUFNQyxVQUFVLE1BQWVELE9BQVRGLE9BQU0sS0FBUSxPQUFMRTtZQUMvQmhCLE1BQU1TLElBQUksQ0FBQztnQkFDVFIsSUFBSWdCO2dCQUNKZixNQUFNO2dCQUNOQyxNQUFNLFlBQXFCYSxPQUFURixPQUFNLEtBQVEsT0FBTEU7Z0JBQzNCWixRQUFRLE9BQU8sT0FBUVcsQ0FBQUEsSUFBSTtnQkFDM0JWLE9BQU8sSUFBSSxPQUFPLE9BQVFVLENBQUFBLElBQUk7Z0JBQzlCVCxhQUFhLElBQUksT0FBTyxPQUFRUyxDQUFBQSxJQUFJO1lBQ3RDO1lBQ0FSLE1BQU1FLElBQUksQ0FBQztnQkFBRUMsUUFBUUY7Z0JBQVFHLFFBQVFNO1lBQVE7WUFDN0NULFNBQVNTO1FB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O1FBQUVYO1FBQU9PO0lBQU07QUFDeEI7QUFFTyxTQUFTb0M7SUFDZCxPQUFPNUM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9kZWwtYXJjaGl0ZWN0dXJlcy50cz84ZTBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBNb2RlbEFyY2hpdGVjdHVyZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gSW5pdGlhbCBjb252b2x1dGlvblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ2NvbnYxJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnQ29udjEnLFxuICAgIHBhcmFtczogOTQwOCxcbiAgICBmbG9wczogMTE4MDEzOTUyLFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnY29udjEnIH0pO1xuICBwcmV2SWQgPSAnY29udjEnO1xuXG4gIC8vIFJlc05ldCBibG9ja3NcbiAgY29uc3QgYmxvY2tzID0gWycyJywgJzMnLCAnNCcsICc1J107XG4gIGJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgIC8vIEVhY2ggYmxvY2sgaGFzIG11bHRpcGxlIHJlc2lkdWFsIHVuaXRzXG4gICAgZm9yIChsZXQgdW5pdCA9IDA7IHVuaXQgPCAzOyB1bml0KyspIHtcbiAgICAgIGNvbnN0IGJsb2NrSWQgPSBgcmVzJHtibG9ja31fJHt1bml0fWA7XG4gICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGJsb2NrSWQsXG4gICAgICAgIHR5cGU6ICdyZXNpZHVhbCcsXG4gICAgICAgIG5hbWU6IGBSZXNCbG9jayAke2Jsb2NrfS4ke3VuaXR9YCxcbiAgICAgICAgcGFyYW1zOiAxMDI0ICogMTAyNCAqIChpICsgMSksXG4gICAgICAgIGZsb3BzOiA1ICogMTAyNCAqIDEwMjQgKiAoaSArIDEpLFxuICAgICAgICBtZW1vcnlVc2FnZTogMyAqIDEwMjQgKiAxMDI0ICogKGkgKyAxKVxuICAgICAgfSk7XG4gICAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYmxvY2tJZCB9KTtcbiAgICAgIHByZXZJZCA9IGJsb2NrSWQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBGaW5hbCBsYXllcnNcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdwb29sJyxcbiAgICB0eXBlOiAnbWxwJyxcbiAgICBuYW1lOiAnR2xvYmFsIFBvb2wnLFxuICAgIHBhcmFtczogMjA0OCxcbiAgICBmbG9wczogMjA0OCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDUxMlxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwb29sJyB9KTtcblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0ZDIDEwMDAnLFxuICAgIHBhcmFtczogMjA0ODAwMCxcbiAgICBmbG9wczogMjA0ODAwMCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6ICdwb29sJywgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIEVuY29kZXIgbGF5ZXJzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgY29uc3QgYXR0ZW50aW9uSWQgPSBgZW5jX2F0dG5fJHtpfWA7XG4gICAgY29uc3QgZmZuSWQgPSBgZW5jX2Zmbl8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgZW5jX25vcm1fJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRlbnRpb25JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYEVuY29kZXIgU2VsZi1BdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogZmZuSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIEZGTiAke2l9YCxcbiAgICAgIHBhcmFtczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDMyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gJHtpfWAsXG4gICAgICBwYXJhbXM6IDEwMjQsXG4gICAgICBmbG9wczogMjA0OCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogNjRcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRlbnRpb25JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRlbnRpb25JZCwgdGFyZ2V0OiBmZm5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBmZm5JZCwgdGFyZ2V0OiBub3JtSWQgfSk7XG4gICAgcHJldklkID0gbm9ybUlkO1xuICB9XG5cbiAgLy8gT3V0cHV0IHByb2plY3Rpb25cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgUHJvamVjdGlvbicsXG4gICAgcGFyYW1zOiAxMDI0ICogMTAyNCxcbiAgICBmbG9wczogMiAqIDEwMjQgKiAxMDI0LFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFBhdGNoIGVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ3BhdGNoX2VtYmVkJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDU5MDU5MixcbiAgICBmbG9wczogNDcxODU5MjAsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwYXRjaF9lbWJlZCcgfSk7XG4gIHByZXZJZCA9ICdwYXRjaF9lbWJlZCc7XG5cbiAgLy8gVHJhbnNmb3JtZXIgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIGNvbnN0IGF0dGVudGlvbklkID0gYHRyYW5zZm9ybWVyXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dGVudGlvbklkLFxuICAgICAgdHlwZTogJ3RyYW5zZm9ybWVyJyxcbiAgICAgIG5hbWU6IGBUcmFuc2Zvcm1lciBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogNyAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDI4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTQgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbWxwSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBNTFAgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dGVudGlvbklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dGVudGlvbklkLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIHByZXZJZCA9IG1scElkO1xuICB9XG5cbiAgLy8gQ2xhc3NpZmljYXRpb24gaGVhZFxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0NsYXNzaWZpY2F0aW9uIEhlYWQnLFxuICAgIHBhcmFtczogNzY4MDAwLFxuICAgIGZsb3BzOiA3NjgwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiA3NjhcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IEltYWdlJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIEJhY2tib25lIGxheWVyc1xuICBjb25zdCBiYWNrYm9uZUxheWVycyA9IFsnUDMnLCAnUDQnLCAnUDUnXTtcbiAgYmFja2JvbmVMYXllcnMuZm9yRWFjaCgobGF5ZXIsIGkpID0+IHtcbiAgICBjb25zdCBjb252SWQgPSBgYmFja2JvbmVfJHtsYXllcn1gO1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGNvbnZJZCxcbiAgICAgIHR5cGU6ICdjbm4nLCAvLyBVc2luZyBDTk4gZm9yIGJhY2tib25lXG4gICAgICBuYW1lOiBgQmFja2JvbmUgJHtsYXllcn1gLFxuICAgICAgcGFyYW1zOiAyNTYgKiAyNTYgKiAoaSArIDEpLFxuICAgICAgZmxvcHM6IDEwMjQgKiAxMDI0ICogKGkgKyAxKSxcbiAgICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogY29udklkIH0pO1xuICAgIHByZXZJZCA9IGNvbnZJZDtcbiAgfSk7XG5cbiAgLy8gRlBOIGxheWVycyB3aXRoIHJlc2lkdWFsIGNvbm5lY3Rpb25zXG4gIGJhY2tib25lTGF5ZXJzLmZvckVhY2goKGxheWVyLCBpKSA9PiB7XG4gICAgY29uc3QgZnBuSWQgPSBgZnBuXyR7bGF5ZXJ9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBmcG5JZCxcbiAgICAgIHR5cGU6ICdyZXNpZHVhbCcsIC8vIFVzaW5nIHJlc2lkdWFsIGZvciBGUE5cbiAgICAgIG5hbWU6IGBGUE4gJHtsYXllcn1gLFxuICAgICAgcGFyYW1zOiAyNTYgKiAyNTYsXG4gICAgICBmbG9wczogNTEyICogNTEyLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYGJhY2tib25lXyR7bGF5ZXJ9YCwgdGFyZ2V0OiBmcG5JZCB9KTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0aW9uIGhlYWRzXG4gIFsnc21hbGwnLCAnbWVkaXVtJywgJ2xhcmdlJ10uZm9yRWFjaCgoc2l6ZSwgaSkgPT4ge1xuICAgIGNvbnN0IGhlYWRJZCA9IGBoZWFkXyR7c2l6ZX1gO1xuICAgIGNvbnN0IGRldGVjdGlvbklkID0gYGRldGVjdGlvbl8ke3NpemV9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGhlYWRJZCxcbiAgICAgIHR5cGU6ICdncmFwaCcsIC8vIFVzaW5nIGdyYXBoIGZvciBkZXRlY3Rpb24gaGVhZHNcbiAgICAgIG5hbWU6IGAke3NpemV9IERldGVjdGlvbiBIZWFkYCxcbiAgICAgIHBhcmFtczogMjU2ICogKDgwICsgNCksXG4gICAgICBmbG9wczogNTEyICogNTEyLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYGZwbl8ke2JhY2tib25lTGF5ZXJzW2ldfWAsIHRhcmdldDogaGVhZElkIH0pO1xuICB9KTtcblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0RldGVjdGlvbiBPdXRwdXQnLFxuICAgIHBhcmFtczogMTAwMCxcbiAgICBmbG9wczogMTAwMCxcbiAgICBtZW1vcnlVc2FnZTogNTEyICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogJ2hlYWRfbGFyZ2UnLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG4vLyBTdGFibGUgRGlmZnVzaW9uXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnVGV4dCArIE5vaXNlIElucHV0JyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFRleHQgZW5jb2RlciAoQ0xJUClcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICd0ZXh0X2VuY29kZXInLFxuICAgIHR5cGU6ICd0cmFuc2Zvcm1lcicsXG4gICAgbmFtZTogJ0NMSVAgVGV4dCBFbmNvZGVyJyxcbiAgICBwYXJhbXM6IDEyMyAqIDEwMjQgKiAxMDI0LFxuICAgIGZsb3BzOiAyNDYgKiAxMDI0ICogMTAyNCxcbiAgICBtZW1vcnlVc2FnZTogNTEyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAndGV4dF9lbmNvZGVyJyB9KTtcblxuICAvLyBVTmV0IGJsb2NrcyB3aXRoIGF0dGVudGlvblxuICBjb25zdCBibG9ja05hbWVzID0gWydEb3duXzEnLCAnRG93bl8yJywgJ01pZCcsICdVcF8xJywgJ1VwXzInXTtcbiAgYmxvY2tOYW1lcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgIGNvbnN0IGJsb2NrSWQgPSBgdW5ldF8ke2Jsb2NrLnRvTG93ZXJDYXNlKCl9YDtcbiAgICBjb25zdCBhdHRuSWQgPSBgYXR0bl8ke2Jsb2NrLnRvTG93ZXJDYXNlKCl9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGJsb2NrSWQsXG4gICAgICB0eXBlOiAncmVzaWR1YWwnLFxuICAgICAgbmFtZTogYFVOZXQgJHtibG9ja31gLFxuICAgICAgcGFyYW1zOiA1MTIgKiA1MTIsXG4gICAgICBmbG9wczogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBDcm9zcyBBdHRlbnRpb24gJHtibG9ja31gLFxuICAgICAgcGFyYW1zOiA1MTIgKiA1MTIsXG4gICAgICBmbG9wczogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBpID09PSAwID8gJ3RleHRfZW5jb2RlcicgOiBwcmV2SWQsIHRhcmdldDogYmxvY2tJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBibG9ja0lkLCB0YXJnZXQ6IGF0dG5JZCB9KTtcbiAgICBwcmV2SWQgPSBhdHRuSWQ7XG4gIH0pO1xuXG4gIC8vIFZBRSBkZWNvZGVyXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAndmFlX2RlY29kZXInLFxuICAgIHR5cGU6ICdjbm4nLFxuICAgIG5hbWU6ICdWQUUgRGVjb2RlcicsXG4gICAgcGFyYW1zOiAyNTYgKiAxMDI0LFxuICAgIGZsb3BzOiA1MTIgKiAxMDI0LFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICd2YWVfZGVjb2RlcicgfSk7XG5cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdHZW5lcmF0ZWQgSW1hZ2UnLFxuICAgIHBhcmFtczogMyAqIDEwMjQgKiAxMDI0LFxuICAgIGZsb3BzOiA2ICogMTAyNCAqIDEwMjQsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiAndmFlX2RlY29kZXInLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG4vLyBMbGFtYSAyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVMbGFtYTJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gVG9rZW4gRW1iZWRkaW5nXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnZW1iZWRkaW5nJyxcbiAgICB0eXBlOiAnZW1iZWRkaW5nJyxcbiAgICBuYW1lOiAnVG9rZW4gRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDMyMDAwICogNDA5NixcbiAgICBmbG9wczogNDA5NixcbiAgICBtZW1vcnlVc2FnZTogNCAqIDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ2VtYmVkZGluZycgfSk7XG4gIHByZXZJZCA9ICdlbWJlZGRpbmcnO1xuXG4gIC8vIFRyYW5zZm9ybWVyIEJsb2Nrc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBjb25zdCBhdHRuSWQgPSBgYXR0bl8ke2l9YDtcbiAgICBjb25zdCBtbHBJZCA9IGBtbHBfJHtpfWA7XG4gICAgY29uc3Qgbm9ybUlkID0gYG5vcm1fJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBTZWxmLUF0dGVudGlvbiAke2l9YCxcbiAgICAgIHBhcmFtczogNCAqIDQwOTYgKiA0MDk2LFxuICAgICAgZmxvcHM6IDE2ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogOCAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBtbHBJZCxcbiAgICAgIHR5cGU6ICdtbHAnLFxuICAgICAgbmFtZTogYE1MUCBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogNCAqIDQwOTYgKiAxMTAwOCxcbiAgICAgIGZsb3BzOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogNCAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBub3JtSWQsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgUk1TTm9ybSAke2l9YCxcbiAgICAgIHBhcmFtczogNDA5NixcbiAgICAgIGZsb3BzOiA0MDk2LFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiA2NFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dG5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRuSWQsIHRhcmdldDogbWxwSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogbWxwSWQsIHRhcmdldDogbm9ybUlkIH0pO1xuICAgIHByZXZJZCA9IG5vcm1JZDtcbiAgfVxuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDQwOTYgKiAzMjAwMCxcbiAgICBmbG9wczogNDA5NiAqIDMyMDAwLFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHUFQyQXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IExheWVyJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFRva2VuIEVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ2VtYmVkZGluZycsXG4gICAgdHlwZTogJ2VtYmVkZGluZycsXG4gICAgbmFtZTogJ1Rva2VuIEVtYmVkZGluZycsXG4gICAgcGFyYW1zOiA1MDI1NyAqIDc2OCwgLy8gVm9jYWIgc2l6ZSAqIGVtYmVkZGluZyBkaW1cbiAgICBmbG9wczogNzY4LFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnZW1iZWRkaW5nJyB9KTtcbiAgcHJldklkID0gJ2VtYmVkZGluZyc7XG5cbiAgLy8gMTIgVHJhbnNmb3JtZXIgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIGNvbnN0IGF0dG5JZCA9IGBhdHRuXyR7aX1gO1xuICAgIGNvbnN0IG5vcm1JZDEgPSBgbm9ybTFfJHtpfWA7XG4gICAgY29uc3QgbWxwSWQgPSBgbWxwXyR7aX1gO1xuICAgIGNvbnN0IG5vcm1JZDIgPSBgbm9ybTJfJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBTZWxmLUF0dGVudGlvbiAke2l9YCxcbiAgICAgIHBhcmFtczogMyAqIDc2OCAqIDc2OCwgLy8gMyA9IFEsSyxWIG1hdHJpY2VzXG4gICAgICBmbG9wczogMTIgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA2ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZDEsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgTGF5ZXIgTm9ybSAxICgke2l9KWAsXG4gICAgICBwYXJhbXM6IDIgKiA3NjgsXG4gICAgICBmbG9wczogNzY4LFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAzMlxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbWxwSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBNTFAgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDc2OCAqIDMwNzIgKyAzMDcyICogNzY4LFxuICAgICAgZmxvcHM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZDIsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgTGF5ZXIgTm9ybSAyICgke2l9KWAsXG4gICAgICBwYXJhbXM6IDIgKiA3NjgsXG4gICAgICBmbG9wczogNzY4LFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAzMlxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dG5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRuSWQsIHRhcmdldDogbm9ybUlkMSB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBub3JtSWQxLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IG1scElkLCB0YXJnZXQ6IG5vcm1JZDIgfSk7XG4gICAgcHJldklkID0gbm9ybUlkMjtcbiAgfVxuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDc2OCAqIDUwMjU3LFxuICAgIGZsb3BzOiA3NjggKiA1MDI1NyxcbiAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVdoaXNwZXJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnQXVkaW8gSW5wdXQnLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gQ29udiBGcm9udGVuZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGNvbnN0IGNvbnZJZCA9IGBjb252XyR7aX1gO1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGNvbnZJZCxcbiAgICAgIHR5cGU6ICdjbm4nLFxuICAgICAgbmFtZTogYENvbnYgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDUxMiAqIDUxMiAqIDMgKiAzLFxuICAgICAgZmxvcHM6IDUxMiAqIDUxMiAqIDMgKiAzICogODAsXG4gICAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGNvbnZJZCB9KTtcbiAgICBwcmV2SWQgPSBjb252SWQ7XG4gIH1cblxuICAvLyBFbmNvZGVyIGJsb2NrcyAoNiBmb3IgYmFzZSBtb2RlbClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICBjb25zdCBhdHRuSWQgPSBgZW5jX2F0dG5fJHtpfWA7XG4gICAgY29uc3QgbWxwSWQgPSBgZW5jX21scF8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgZW5jX25vcm1fJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIEF0dGVudGlvbiAke2l9YCxcbiAgICAgIHBhcmFtczogMyAqIDUxMiAqIDUxMixcbiAgICAgIGZsb3BzOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogNCAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBtbHBJZCxcbiAgICAgIHR5cGU6ICdtbHAnLFxuICAgICAgbmFtZTogYEVuY29kZXIgTUxQICR7aX1gLFxuICAgICAgcGFyYW1zOiA1MTIgKiAyMDQ4ICsgMjA0OCAqIDUxMixcbiAgICAgIGZsb3BzOiA0ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBub3JtSWQsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgRW5jb2RlciBOb3JtICR7aX1gLFxuICAgICAgcGFyYW1zOiAyICogNTEyLFxuICAgICAgZmxvcHM6IDUxMixcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMzJcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRuSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYXR0bklkLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IG1scElkLCB0YXJnZXQ6IG5vcm1JZCB9KTtcbiAgICBwcmV2SWQgPSBub3JtSWQ7XG4gIH1cblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ091dHB1dCBMYXllcicsXG4gICAgcGFyYW1zOiA1MTIgKiA1MTg2NSwgLy8gdm9jYWIgc2l6ZVxuICAgIGZsb3BzOiA1MTIgKiA1MTg2NSxcbiAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUJpb0JFUlRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gVG9rZW4gJiBQb3NpdGlvbiBFbWJlZGRpbmdcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdlbWJlZGRpbmcnLFxuICAgIHR5cGU6ICdlbWJlZGRpbmcnLFxuICAgIG5hbWU6ICdUb2tlbiArIFBvc2l0aW9uIEVtYmVkZGluZycsXG4gICAgcGFyYW1zOiAyODk5NiAqIDc2OCArIDUxMiAqIDc2OCwgLy8gdm9jYWJfc2l6ZSAqIGhpZGRlbl9kaW0gKyBtYXhfcG9zICogaGlkZGVuX2RpbVxuICAgIGZsb3BzOiA3NjggKiAyLFxuICAgIG1lbW9yeVVzYWdlOiAzICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnZW1iZWRkaW5nJyB9KTtcbiAgcHJldklkID0gJ2VtYmVkZGluZyc7XG5cbiAgLy8gMTIgVHJhbnNmb3JtZXIgRW5jb2RlciBibG9ja3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgY29uc3QgYXR0bklkID0gYGF0dG5fJHtpfWA7XG4gICAgY29uc3Qgbm9ybUlkMSA9IGBub3JtMV8ke2l9YDtcbiAgICBjb25zdCBtbHBJZCA9IGBtbHBfJHtpfWA7XG4gICAgY29uc3Qgbm9ybUlkMiA9IGBub3JtMl8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dG5JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYE11bHRpLUhlYWQgQXR0ZW50aW9uICR7aX1gLFxuICAgICAgcGFyYW1zOiA3NjggKiA3NjggKiA0LCAvLyA0ID0gUSxLLFYsTyBtYXRyaWNlc1xuICAgICAgZmxvcHM6IDEyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogNiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBub3JtSWQxLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gMSAoJHtpfSlgLFxuICAgICAgcGFyYW1zOiAyICogNzY4LFxuICAgICAgZmxvcHM6IDc2OCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMzJcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG1scElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgRmVlZCBGb3J3YXJkICR7aX1gLFxuICAgICAgcGFyYW1zOiA3NjggKiAzMDcyICsgMzA3MiAqIDc2OCxcbiAgICAgIGZsb3BzOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogNCAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBub3JtSWQyLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gMiAoJHtpfSlgLFxuICAgICAgcGFyYW1zOiAyICogNzY4LFxuICAgICAgZmxvcHM6IDc2OCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMzJcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRuSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYXR0bklkLCB0YXJnZXQ6IG5vcm1JZDEgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogbm9ybUlkMSwgdGFyZ2V0OiBtbHBJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBtbHBJZCwgdGFyZ2V0OiBub3JtSWQyIH0pO1xuICAgIHByZXZJZCA9IG5vcm1JZDI7XG4gIH1cblxuICAvLyBQb29sZXIgYW5kIE91dHB1dFxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ3Bvb2xlcicsXG4gICAgdHlwZTogJ21scCcsXG4gICAgbmFtZTogJ1Bvb2xlcicsXG4gICAgcGFyYW1zOiA3NjggKiA3NjgsXG4gICAgZmxvcHM6IDc2OCAqIDc2OCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAncG9vbGVyJyB9KTtcblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ091dHB1dCBMYXllcicsXG4gICAgcGFyYW1zOiA3NjggKiAyLCAvLyBiaW5hcnkgY2xhc3NpZmljYXRpb25cbiAgICBmbG9wczogNzY4ICogMixcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDY0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiAncG9vbGVyJywgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRElOT3YyQXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IExheWVyJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFBhdGNoIEVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ3BhdGNoX2VtYmVkJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDM4NCAqICgxNCAqIDE0ICogMyksIC8vIGhpZGRlbl9kaW0gKiBwYXRjaF9zaXplXjIgKiBjaGFubmVsc1xuICAgIGZsb3BzOiAzODQgKiAxOTYgKiAzLFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAncGF0Y2hfZW1iZWQnIH0pO1xuICBwcmV2SWQgPSAncGF0Y2hfZW1iZWQnO1xuXG4gIC8vIDEyIFRyYW5zZm9ybWVyIGJsb2Nrc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICBjb25zdCBhdHRuSWQgPSBgYXR0bl8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQxID0gYG5vcm0xXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQyID0gYG5vcm0yXyR7aX1gO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogYXR0bklkLFxuICAgICAgdHlwZTogJ2F0dGVudGlvbicsXG4gICAgICBuYW1lOiBgU2VsZi1BdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDM4NCAqIDM4NCAqIDQsXG4gICAgICBmbG9wczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDQgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkMSxcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBMYXllciBOb3JtIDEgKCR7aX0pYCxcbiAgICAgIHBhcmFtczogMiAqIDM4NCxcbiAgICAgIGZsb3BzOiAzODQsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDMyXG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBtbHBJZCxcbiAgICAgIHR5cGU6ICdtbHAnLFxuICAgICAgbmFtZTogYE1MUCBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogMzg0ICogMTUzNiArIDE1MzYgKiAzODQsXG4gICAgICBmbG9wczogNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDMgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkMixcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBMYXllciBOb3JtIDIgKCR7aX0pYCxcbiAgICAgIHBhcmFtczogMiAqIDM4NCxcbiAgICAgIGZsb3BzOiAzODQsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDMyXG4gICAgfSk7XG5cbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dG5JZCwgdGFyZ2V0OiBub3JtSWQxIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IG5vcm1JZDEsIHRhcmdldDogbWxwSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogbWxwSWQsIHRhcmdldDogbm9ybUlkMiB9KTtcbiAgICBwcmV2SWQgPSBub3JtSWQyO1xuICB9XG5cbiAgLy8gUHJvamVjdGlvbiBoZWFkXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAncHJvamVjdGlvbicsXG4gICAgdHlwZTogJ21scCcsXG4gICAgbmFtZTogJ1Byb2plY3Rpb24gSGVhZCcsXG4gICAgcGFyYW1zOiAzODQgKiAyMDQ4LFxuICAgIGZsb3BzOiAzODQgKiAyMDQ4LFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAncHJvamVjdGlvbicgfSk7XG5cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgRW1iZWRkaW5ncycsXG4gICAgcGFyYW1zOiAyMDQ4ICogMjU2LFxuICAgIGZsb3BzOiAyMDQ4ICogMjU2LFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogJ3Byb2plY3Rpb24nLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEZWZhdWx0QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgcmV0dXJuIGdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlKCk7XG59Il0sIm5hbWVzIjpbImdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlIiwibm9kZXMiLCJpZCIsInR5cGUiLCJuYW1lIiwicGFyYW1zIiwiZmxvcHMiLCJtZW1vcnlVc2FnZSIsImVkZ2VzIiwicHJldklkIiwicHVzaCIsInNvdXJjZSIsInRhcmdldCIsImJsb2NrcyIsImZvckVhY2giLCJibG9jayIsImkiLCJ1bml0IiwiYmxvY2tJZCIsImdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUiLCJhdHRlbnRpb25JZCIsImZmbklkIiwibm9ybUlkIiwiZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUiLCJtbHBJZCIsImdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlIiwiYmFja2JvbmVMYXllcnMiLCJsYXllciIsImNvbnZJZCIsImZwbklkIiwic2l6ZSIsImhlYWRJZCIsImRldGVjdGlvbklkIiwiZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUiLCJibG9ja05hbWVzIiwidG9Mb3dlckNhc2UiLCJhdHRuSWQiLCJnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlR1BUMkFyY2hpdGVjdHVyZSIsIm5vcm1JZDEiLCJub3JtSWQyIiwiZ2VuZXJhdGVXaGlzcGVyQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVCaW9CRVJUQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVESU5PdjJBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZURlZmF1bHRBcmNoaXRlY3R1cmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model-architectures.ts\n"));

/***/ })

});