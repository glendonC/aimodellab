"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/huggingface.ts":
/*!****************************!*\
  !*** ./lib/huggingface.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FEATURED_MODELS: function() { return /* binding */ FEATURED_MODELS; },\n/* harmony export */   generateGPT2Architecture: function() { return /* binding */ generateGPT2Architecture; },\n/* harmony export */   generateWhisperArchitecture: function() { return /* binding */ generateWhisperArchitecture; },\n/* harmony export */   getModelArchitecture: function() { return /* binding */ getModelArchitecture; },\n/* harmony export */   getModelInfo: function() { return /* binding */ getModelInfo; },\n/* harmony export */   searchModels: function() { return /* binding */ searchModels; }\n/* harmony export */ });\n/* harmony import */ var _model_architectures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model-architectures */ \"(app-pages-browser)/./lib/model-architectures.ts\");\nconst FEATURED_MODELS = [\n    // Vision Models (GPU-Intensive)\n    {\n        id: \"microsoft/resnet-50\",\n        name: \"ResNet-50\",\n        description: \"State-of-the-art image classification model with CUDA optimization\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"ResNet\",\n        size: \"98 MB\",\n        downloads: 2500000,\n        likes: 1200,\n        tags: [\n            \"computer-vision\",\n            \"classification\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"nvidia/stable-diffusion-v1.5\",\n        name: \"Stable Diffusion v1.5\",\n        description: \"Optimized for NVIDIA GPUs with tensor core acceleration\",\n        type: \"vision\",\n        task: \"text-to-image\",\n        architecture: \"Diffusion\",\n        size: \"7.7 GB\",\n        downloads: 5800000,\n        likes: 3200,\n        tags: [\n            \"generative-ai\",\n            \"text-to-image\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"yolov8\",\n        name: \"YOLOv8\",\n        description: \"Real-time object detection with CUDA acceleration\",\n        type: \"vision\",\n        task: \"object-detection\",\n        architecture: \"YOLO\",\n        size: \"108 MB\",\n        downloads: 4200000,\n        likes: 2800,\n        tags: [\n            \"object-detection\",\n            \"real-time\",\n            \"tensorrt\"\n        ]\n    },\n    // Large Language Models\n    {\n        id: \"meta-llama/llama-2-7b\",\n        name: \"Llama 2 (7B)\",\n        description: \"Efficient large language model with multi-GPU scaling\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"13.5 GB\",\n        downloads: 8500000,\n        likes: 4500,\n        tags: [\n            \"llm\",\n            \"multi-gpu\",\n            \"fp16-optimized\"\n        ]\n    },\n    {\n        id: \"openai/gpt-2\",\n        name: \"GPT-2 Small\",\n        description: \"Compact language model with GPU acceleration\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"1.5 GB\",\n        downloads: 3800000,\n        likes: 2100,\n        tags: [\n            \"nlp\",\n            \"text-generation\",\n            \"cuda\"\n        ]\n    },\n    // Specialized Models\n    {\n        id: \"facebook/bart-large-cnn\",\n        name: \"BART Large CNN\",\n        description: \"GPU-accelerated text summarization model\",\n        type: \"text\",\n        task: \"summarization\",\n        architecture: \"Transformer\",\n        size: \"1.6 GB\",\n        downloads: 1800000,\n        likes: 950,\n        tags: [\n            \"nlp\",\n            \"summarization\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"openai/whisper-base\",\n        name: \"Whisper Base\",\n        description: \"Speech recognition optimized for NVIDIA GPUs\",\n        type: \"audio\",\n        task: \"speech-recognition\",\n        architecture: \"Transformer\",\n        size: \"442 MB\",\n        downloads: 2900000,\n        likes: 1600,\n        tags: [\n            \"speech\",\n            \"audio\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"google/vit-base-patch16-224\",\n        name: \"ViT Base\",\n        description: \"Vision Transformer with tensor core acceleration\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"Transformer\",\n        size: \"346 MB\",\n        downloads: 3200000,\n        likes: 1500,\n        tags: [\n            \"vision\",\n            \"transformers\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"dmis-lab/biobert-base\",\n        name: \"BioBERT\",\n        description: \"Biomedical language model with GPU optimization\",\n        type: \"text\",\n        task: \"text-classification\",\n        architecture: \"BERT\",\n        size: \"412 MB\",\n        downloads: 890000,\n        likes: 720,\n        tags: [\n            \"healthcare\",\n            \"nlp\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"facebook/dinov2-base\",\n        name: \"DINOv2\",\n        description: \"Self-supervised vision model with NVIDIA acceleration\",\n        type: \"vision\",\n        task: \"self-supervised-learning\",\n        architecture: \"Transformer\",\n        size: \"384 MB\",\n        downloads: 1200000,\n        likes: 890,\n        tags: [\n            \"self-supervised\",\n            \"vision\",\n            \"cuda\"\n        ]\n    }\n];\nasync function searchModels(query) {\n    try {\n        const response = await fetch(\"https://huggingface.co/api/models?search=\".concat(encodeURIComponent(query)), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const text = await response.text();\n        if (!text) {\n            return [];\n        }\n        let data;\n        try {\n            data = JSON.parse(text);\n        } catch (e) {\n            console.error(\"Failed to parse response:\", e);\n            return [];\n        }\n        if (!Array.isArray(data)) {\n            console.error(\"Unexpected response format:\", data);\n            return [];\n        }\n        return data.map((model)=>{\n            var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n            return {\n                id: model.modelId || model.id,\n                name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n                description: model.description || \"No description available\",\n                type: determineModelType(model.pipeline_tag),\n                task: model.pipeline_tag || \"unknown\",\n                architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n                size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n                downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n                likes: model.likes || 0,\n                tags: [\n                    model.pipeline_tag,\n                    ...model.tags || [],\n                    model.library_name\n                ].filter(Boolean)\n            };\n        });\n    } catch (error) {\n        console.error(\"Failed to search models:\", error);\n        return [];\n    }\n}\nfunction determineModelType(pipelineTag) {\n    if (!pipelineTag) return \"vision\";\n    const visionTasks = [\n        \"image-classification\",\n        \"object-detection\",\n        \"image-segmentation\"\n    ];\n    const textTasks = [\n        \"text-classification\",\n        \"text-generation\",\n        \"translation\"\n    ];\n    const audioTasks = [\n        \"audio-classification\",\n        \"speech-recognition\"\n    ];\n    if (visionTasks.includes(pipelineTag)) return \"vision\";\n    if (textTasks.includes(pipelineTag)) return \"text\";\n    if (audioTasks.includes(pipelineTag)) return \"audio\";\n    return \"multimodal\";\n}\nfunction formatSize(bytes) {\n    if (bytes === 0) return \"0 B\";\n    const k = 1024;\n    const sizes = [\n        \"B\",\n        \"KB\",\n        \"MB\",\n        \"GB\",\n        \"TB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + \" \" + sizes[i];\n}\nasync function getModelInfo(modelId) {\n    try {\n        var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n        const response = await fetch(\"https://huggingface.co/api/models/\".concat(modelId), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Model not found\");\n        }\n        const model = await response.json();\n        return {\n            id: model.modelId || model.id,\n            name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n            description: model.description || \"No description available\",\n            type: determineModelType(model.pipeline_tag),\n            task: model.pipeline_tag || \"unknown\",\n            architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n            size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n            downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n            likes: model.likes || 0,\n            tags: [\n                model.pipeline_tag,\n                ...model.tags || [],\n                model.library_name\n            ].filter(Boolean)\n        };\n    } catch (error) {\n        console.error(\"Failed to get model info:\", error);\n        throw error;\n    }\n}\nfunction generateGPT2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token Embedding\",\n        params: 50257 * 768,\n        flops: 768,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // 12 Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attnId = \"attn_\".concat(i);\n        const normId1 = \"norm1_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId2 = \"norm2_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 3 * 768 * 768,\n            flops: 12 * 1024 * 1024,\n            memoryUsage: 6 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId1,\n            type: \"normalization\",\n            name: \"Layer Norm 1 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 768 * 3072 + 3072 * 768,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId2,\n            type: \"normalization\",\n            name: \"Layer Norm 2 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: normId1\n        });\n        edges.push({\n            source: normId1,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId2\n        });\n        prevId = normId2;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 768 * 50257,\n        flops: 768 * 50257,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateWhisperArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Audio Input\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Conv Frontend\n    for(let i = 0; i < 2; i++){\n        const convId = \"conv_\".concat(i);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Conv Block \".concat(i),\n            params: 512 * 512 * 3 * 3,\n            flops: 512 * 512 * 3 * 3 * 80,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    }\n    // Encoder blocks (6 for base model)\n    for(let i = 0; i < 6; i++){\n        const attnId = \"enc_attn_\".concat(i);\n        const mlpId = \"enc_mlp_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Encoder Attention \".concat(i),\n            params: 3 * 512 * 512,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"Encoder MLP \".concat(i),\n            params: 512 * 2048 + 2048 * 512,\n            flops: 4 * 1024 * 1024,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Encoder Norm \".concat(i),\n            params: 2 * 512,\n            flops: 512,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 512 * 51865,\n        flops: 512 * 51865,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nasync function getModelArchitecture(modelId) {\n    switch(modelId){\n        case \"microsoft/resnet-50\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateResNetArchitecture)();\n        case \"facebook/bart-large-cnn\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateTransformerArchitecture)();\n        case \"google/vit-base-patch16-224\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateViTArchitecture)();\n        case \"nvidia/stable-diffusion-v1.5\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateStableDiffusionArchitecture)();\n        case \"meta-llama/llama-2-7b\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateLlama2Architecture)();\n        case \"yolov8\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateYOLOv8Architecture)();\n        // case 'openai/gpt-2':\n        //   return generateGPT2Architecture();\n        // case 'openai/whisper-base':\n        //   return generateWhisperArchitecture();\n        // case 'dmis-lab/biobert-base':\n        //   return generateBioBERTArchitecture();\n        // case 'facebook/dinov2-base':\n        //   return generateDINOv2Architecture();\n        default:\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateDefaultArchitecture)();\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0lBQ1g7SUFFQWYsTUFBTU0sSUFBSSxDQUFDO1FBQ1RuRSxJQUFJO1FBQ0pHLE1BQU07UUFDTkYsTUFBTTtRQUNONkQsUUFBUSxNQUFNO1FBQ2RDLE9BQU8sTUFBTTtRQUNiQyxhQUFhLElBQUksT0FBTztJQUMxQjtJQUNBQyxNQUFNRSxJQUFJLENBQUM7UUFBRUMsUUFBUUY7UUFBUUcsUUFBUTtJQUFTO0lBRTlDLE9BQU87UUFBRVI7UUFBT0k7SUFBTTtBQUN4QjtBQUVPLGVBQWVZLHFCQUFxQi9DLE9BQWU7SUFDeEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBT2dELGdGQUEwQkE7UUFDbkMsS0FBSztZQUNILE9BQU9DLHFGQUErQkE7UUFDeEMsS0FBSztZQUNILE9BQU9DLDZFQUF1QkE7UUFDaEMsS0FBSztZQUNILE9BQU9DLHlGQUFtQ0E7UUFDNUMsS0FBSztZQUNILE9BQU9DLGdGQUEwQkE7UUFDbkMsS0FBSztZQUNILE9BQU9DLGdGQUEwQkE7UUFDbkMsdUJBQXVCO1FBQ3ZCLHVDQUF1QztRQUN2Qyw4QkFBOEI7UUFDOUIsMENBQTBDO1FBQzFDLGdDQUFnQztRQUNoQywwQ0FBMEM7UUFDMUMsK0JBQStCO1FBQy9CLHlDQUF5QztRQUN6QztZQUNFLE9BQU9DLGlGQUEyQkE7SUFDdEM7QUFDRjtBQVlnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaHVnZ2luZ2ZhY2UudHM/YTBmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIZkluZmVyZW5jZSB9IGZyb20gJ0BodWdnaW5nZmFjZS9pbmZlcmVuY2UnO1xuXG5leHBvcnQgdHlwZSBIRk1vZGVsID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHR5cGU6ICd2aXNpb24nIHwgJ3RleHQnIHwgJ2F1ZGlvJyB8ICdtdWx0aW1vZGFsJztcbiAgdGFzazogc3RyaW5nO1xuICBhcmNoaXRlY3R1cmU6IHN0cmluZztcbiAgc2l6ZTogc3RyaW5nO1xuICBkb3dubG9hZHM6IG51bWJlcjtcbiAgbGlrZXM6IG51bWJlcjtcbiAgdGFnczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBNb2RlbEFyY2hpdGVjdHVyZSA9IHtcbiAgbm9kZXM6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcGFyYW1zOiBudW1iZXI7XG4gICAgZmxvcHM6IG51bWJlcjtcbiAgICBtZW1vcnlVc2FnZTogbnVtYmVyO1xuICB9PjtcbiAgZWRnZXM6IEFycmF5PHtcbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICB0YXJnZXQ6IHN0cmluZztcbiAgfT47XG59O1xuXG5leHBvcnQgY29uc3QgRkVBVFVSRURfTU9ERUxTOiBIRk1vZGVsW10gPSBbXG4gIC8vIFZpc2lvbiBNb2RlbHMgKEdQVS1JbnRlbnNpdmUpXG4gIHtcbiAgICBpZDogJ21pY3Jvc29mdC9yZXNuZXQtNTAnLFxuICAgIG5hbWU6ICdSZXNOZXQtNTAnLFxuICAgIGRlc2NyaXB0aW9uOiAnU3RhdGUtb2YtdGhlLWFydCBpbWFnZSBjbGFzc2lmaWNhdGlvbiBtb2RlbCB3aXRoIENVREEgb3B0aW1pemF0aW9uJyxcbiAgICB0eXBlOiAndmlzaW9uJyxcbiAgICB0YXNrOiAnaW1hZ2UtY2xhc3NpZmljYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1Jlc05ldCcsXG4gICAgc2l6ZTogJzk4IE1CJyxcbiAgICBkb3dubG9hZHM6IDI1MDAwMDAsXG4gICAgbGlrZXM6IDEyMDAsXG4gICAgdGFnczogWydjb21wdXRlci12aXNpb24nLCAnY2xhc3NpZmljYXRpb24nLCAnY3VkYS1vcHRpbWl6ZWQnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdudmlkaWEvc3RhYmxlLWRpZmZ1c2lvbi12MS41JyxcbiAgICBuYW1lOiAnU3RhYmxlIERpZmZ1c2lvbiB2MS41JyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGltaXplZCBmb3IgTlZJRElBIEdQVXMgd2l0aCB0ZW5zb3IgY29yZSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICd0ZXh0LXRvLWltYWdlJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdEaWZmdXNpb24nLFxuICAgIHNpemU6ICc3LjcgR0InLFxuICAgIGRvd25sb2FkczogNTgwMDAwMCxcbiAgICBsaWtlczogMzIwMCxcbiAgICB0YWdzOiBbJ2dlbmVyYXRpdmUtYWknLCAndGV4dC10by1pbWFnZScsICd0ZW5zb3ItY29yZXMnXVxuICB9LFxuICB7XG4gICAgaWQ6ICd5b2xvdjgnLFxuICAgIG5hbWU6ICdZT0xPdjgnLFxuICAgIGRlc2NyaXB0aW9uOiAnUmVhbC10aW1lIG9iamVjdCBkZXRlY3Rpb24gd2l0aCBDVURBIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3Zpc2lvbicsXG4gICAgdGFzazogJ29iamVjdC1kZXRlY3Rpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1lPTE8nLFxuICAgIHNpemU6ICcxMDggTUInLFxuICAgIGRvd25sb2FkczogNDIwMDAwMCxcbiAgICBsaWtlczogMjgwMCxcbiAgICB0YWdzOiBbJ29iamVjdC1kZXRlY3Rpb24nLCAncmVhbC10aW1lJywgJ3RlbnNvcnJ0J11cbiAgfSxcbiAgXG4gIC8vIExhcmdlIExhbmd1YWdlIE1vZGVsc1xuICB7XG4gICAgaWQ6ICdtZXRhLWxsYW1hL2xsYW1hLTItN2InLFxuICAgIG5hbWU6ICdMbGFtYSAyICg3QiknLFxuICAgIGRlc2NyaXB0aW9uOiAnRWZmaWNpZW50IGxhcmdlIGxhbmd1YWdlIG1vZGVsIHdpdGggbXVsdGktR1BVIHNjYWxpbmcnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICB0YXNrOiAndGV4dC1nZW5lcmF0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzEzLjUgR0InLFxuICAgIGRvd25sb2FkczogODUwMDAwMCxcbiAgICBsaWtlczogNDUwMCxcbiAgICB0YWdzOiBbJ2xsbScsICdtdWx0aS1ncHUnLCAnZnAxNi1vcHRpbWl6ZWQnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdvcGVuYWkvZ3B0LTInLFxuICAgIG5hbWU6ICdHUFQtMiBTbWFsbCcsXG4gICAgZGVzY3JpcHRpb246ICdDb21wYWN0IGxhbmd1YWdlIG1vZGVsIHdpdGggR1BVIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3RleHQnLFxuICAgIHRhc2s6ICd0ZXh0LWdlbmVyYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnMS41IEdCJyxcbiAgICBkb3dubG9hZHM6IDM4MDAwMDAsXG4gICAgbGlrZXM6IDIxMDAsXG4gICAgdGFnczogWydubHAnLCAndGV4dC1nZW5lcmF0aW9uJywgJ2N1ZGEnXVxuICB9LFxuXG4gIC8vIFNwZWNpYWxpemVkIE1vZGVsc1xuICB7XG4gICAgaWQ6ICdmYWNlYm9vay9iYXJ0LWxhcmdlLWNubicsXG4gICAgbmFtZTogJ0JBUlQgTGFyZ2UgQ05OJyxcbiAgICBkZXNjcmlwdGlvbjogJ0dQVS1hY2NlbGVyYXRlZCB0ZXh0IHN1bW1hcml6YXRpb24gbW9kZWwnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICB0YXNrOiAnc3VtbWFyaXphdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICcxLjYgR0InLFxuICAgIGRvd25sb2FkczogMTgwMDAwMCxcbiAgICBsaWtlczogOTUwLFxuICAgIHRhZ3M6IFsnbmxwJywgJ3N1bW1hcml6YXRpb24nLCAnY3VkYSddXG4gIH0sXG4gIHtcbiAgICBpZDogJ29wZW5haS93aGlzcGVyLWJhc2UnLFxuICAgIG5hbWU6ICdXaGlzcGVyIEJhc2UnLFxuICAgIGRlc2NyaXB0aW9uOiAnU3BlZWNoIHJlY29nbml0aW9uIG9wdGltaXplZCBmb3IgTlZJRElBIEdQVXMnLFxuICAgIHR5cGU6ICdhdWRpbycsXG4gICAgdGFzazogJ3NwZWVjaC1yZWNvZ25pdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICc0NDIgTUInLFxuICAgIGRvd25sb2FkczogMjkwMDAwMCxcbiAgICBsaWtlczogMTYwMCxcbiAgICB0YWdzOiBbJ3NwZWVjaCcsICdhdWRpbycsICdjdWRhLW9wdGltaXplZCddXG4gIH0sXG4gIHtcbiAgICBpZDogJ2dvb2dsZS92aXQtYmFzZS1wYXRjaDE2LTIyNCcsXG4gICAgbmFtZTogJ1ZpVCBCYXNlJyxcbiAgICBkZXNjcmlwdGlvbjogJ1Zpc2lvbiBUcmFuc2Zvcm1lciB3aXRoIHRlbnNvciBjb3JlIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3Zpc2lvbicsXG4gICAgdGFzazogJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzM0NiBNQicsXG4gICAgZG93bmxvYWRzOiAzMjAwMDAwLFxuICAgIGxpa2VzOiAxNTAwLFxuICAgIHRhZ3M6IFsndmlzaW9uJywgJ3RyYW5zZm9ybWVycycsICd0ZW5zb3ItY29yZXMnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdkbWlzLWxhYi9iaW9iZXJ0LWJhc2UnLFxuICAgIG5hbWU6ICdCaW9CRVJUJyxcbiAgICBkZXNjcmlwdGlvbjogJ0Jpb21lZGljYWwgbGFuZ3VhZ2UgbW9kZWwgd2l0aCBHUFUgb3B0aW1pemF0aW9uJyxcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgdGFzazogJ3RleHQtY2xhc3NpZmljYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ0JFUlQnLFxuICAgIHNpemU6ICc0MTIgTUInLFxuICAgIGRvd25sb2FkczogODkwMDAwLFxuICAgIGxpa2VzOiA3MjAsXG4gICAgdGFnczogWydoZWFsdGhjYXJlJywgJ25scCcsICdjdWRhJ11cbiAgfSxcbiAge1xuICAgIGlkOiAnZmFjZWJvb2svZGlub3YyLWJhc2UnLFxuICAgIG5hbWU6ICdESU5PdjInLFxuICAgIGRlc2NyaXB0aW9uOiAnU2VsZi1zdXBlcnZpc2VkIHZpc2lvbiBtb2RlbCB3aXRoIE5WSURJQSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICdzZWxmLXN1cGVydmlzZWQtbGVhcm5pbmcnLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnMzg0IE1CJyxcbiAgICBkb3dubG9hZHM6IDEyMDAwMDAsXG4gICAgbGlrZXM6IDg5MCxcbiAgICB0YWdzOiBbJ3NlbGYtc3VwZXJ2aXNlZCcsICd2aXNpb24nLCAnY3VkYSddXG4gIH1cbl07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hNb2RlbHMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8SEZNb2RlbFtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS9tb2RlbHM/c2VhcmNoPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX1gLFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2U6JywgZSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdDonLCBkYXRhKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5tYXAoKG1vZGVsOiBhbnkpID0+ICh7XG4gICAgICBpZDogbW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCxcbiAgICAgIG5hbWU6IChtb2RlbC5tb2RlbElkIHx8IG1vZGVsLmlkKT8uc3BsaXQoJy8nKS5wb3AoKSB8fCAnVW5rbm93biBNb2RlbCcsXG4gICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZScsXG4gICAgICB0eXBlOiBkZXRlcm1pbmVNb2RlbFR5cGUobW9kZWwucGlwZWxpbmVfdGFnKSxcbiAgICAgIHRhc2s6IG1vZGVsLnBpcGVsaW5lX3RhZyB8fCAndW5rbm93bicsXG4gICAgICBhcmNoaXRlY3R1cmU6IG1vZGVsLmNvbmZpZz8uYXJjaGl0ZWN0dXJlcz8uWzBdIHx8ICd1bmtub3duJyxcbiAgICAgIHNpemU6IGZvcm1hdFNpemUobW9kZWwuZG93bmxvYWRzPy5iaW5hcnk/LnNpemUgfHwgMCksXG4gICAgICBkb3dubG9hZHM6IG1vZGVsLmRvd25sb2Fkcz8udG90YWwgfHwgMCxcbiAgICAgIGxpa2VzOiBtb2RlbC5saWtlcyB8fCAwLFxuICAgICAgdGFnczogW1xuICAgICAgICBtb2RlbC5waXBlbGluZV90YWcsXG4gICAgICAgIC4uLihtb2RlbC50YWdzIHx8IFtdKSxcbiAgICAgICAgbW9kZWwubGlicmFyeV9uYW1lXG4gICAgICBdLmZpbHRlcihCb29sZWFuKVxuICAgIH0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VhcmNoIG1vZGVsczonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1vZGVsVHlwZShwaXBlbGluZVRhZzogc3RyaW5nKTogSEZNb2RlbFsndHlwZSddIHtcbiAgaWYgKCFwaXBlbGluZVRhZykgcmV0dXJuICd2aXNpb24nO1xuICBcbiAgY29uc3QgdmlzaW9uVGFza3MgPSBbJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJywgJ29iamVjdC1kZXRlY3Rpb24nLCAnaW1hZ2Utc2VnbWVudGF0aW9uJ107XG4gIGNvbnN0IHRleHRUYXNrcyA9IFsndGV4dC1jbGFzc2lmaWNhdGlvbicsICd0ZXh0LWdlbmVyYXRpb24nLCAndHJhbnNsYXRpb24nXTtcbiAgY29uc3QgYXVkaW9UYXNrcyA9IFsnYXVkaW8tY2xhc3NpZmljYXRpb24nLCAnc3BlZWNoLXJlY29nbml0aW9uJ107XG4gIFxuICBpZiAodmlzaW9uVGFza3MuaW5jbHVkZXMocGlwZWxpbmVUYWcpKSByZXR1cm4gJ3Zpc2lvbic7XG4gIGlmICh0ZXh0VGFza3MuaW5jbHVkZXMocGlwZWxpbmVUYWcpKSByZXR1cm4gJ3RleHQnO1xuICBpZiAoYXVkaW9UYXNrcy5pbmNsdWRlcyhwaXBlbGluZVRhZykpIHJldHVybiAnYXVkaW8nO1xuICByZXR1cm4gJ211bHRpbW9kYWwnO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTaXplKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoYnl0ZXMgPT09IDApIHJldHVybiAnMCBCJztcbiAgY29uc3QgayA9IDEwMjQ7XG4gIGNvbnN0IHNpemVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ107XG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoMSkpICsgJyAnICsgc2l6ZXNbaV07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbEluZm8obW9kZWxJZDogc3RyaW5nKTogUHJvbWlzZTxIRk1vZGVsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvbW9kZWxzLyR7bW9kZWxJZH1gLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGVsID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogbW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCxcbiAgICAgIG5hbWU6IChtb2RlbC5tb2RlbElkIHx8IG1vZGVsLmlkKT8uc3BsaXQoJy8nKS5wb3AoKSB8fCAnVW5rbm93biBNb2RlbCcsXG4gICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZScsXG4gICAgICB0eXBlOiBkZXRlcm1pbmVNb2RlbFR5cGUobW9kZWwucGlwZWxpbmVfdGFnKSxcbiAgICAgIHRhc2s6IG1vZGVsLnBpcGVsaW5lX3RhZyB8fCAndW5rbm93bicsXG4gICAgICBhcmNoaXRlY3R1cmU6IG1vZGVsLmNvbmZpZz8uYXJjaGl0ZWN0dXJlcz8uWzBdIHx8ICd1bmtub3duJyxcbiAgICAgIHNpemU6IGZvcm1hdFNpemUobW9kZWwuZG93bmxvYWRzPy5iaW5hcnk/LnNpemUgfHwgMCksXG4gICAgICBkb3dubG9hZHM6IG1vZGVsLmRvd25sb2Fkcz8udG90YWwgfHwgMCxcbiAgICAgIGxpa2VzOiBtb2RlbC5saWtlcyB8fCAwLFxuICAgICAgdGFnczogW1xuICAgICAgICBtb2RlbC5waXBlbGluZV90YWcsXG4gICAgICAgIC4uLihtb2RlbC50YWdzIHx8IFtdKSxcbiAgICAgICAgbW9kZWwubGlicmFyeV9uYW1lXG4gICAgICBdLmZpbHRlcihCb29sZWFuKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBtb2RlbCBpbmZvOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHUFQyQXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IExheWVyJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFRva2VuIEVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ2VtYmVkZGluZycsXG4gICAgdHlwZTogJ2VtYmVkZGluZycsXG4gICAgbmFtZTogJ1Rva2VuIEVtYmVkZGluZycsXG4gICAgcGFyYW1zOiA1MDI1NyAqIDc2OCwgLy8gVm9jYWIgc2l6ZSAqIGVtYmVkZGluZyBkaW1cbiAgICBmbG9wczogNzY4LFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnZW1iZWRkaW5nJyB9KTtcbiAgcHJldklkID0gJ2VtYmVkZGluZyc7XG5cbiAgLy8gMTIgVHJhbnNmb3JtZXIgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIGNvbnN0IGF0dG5JZCA9IGBhdHRuXyR7aX1gO1xuICAgIGNvbnN0IG5vcm1JZDEgPSBgbm9ybTFfJHtpfWA7XG4gICAgY29uc3QgbWxwSWQgPSBgbWxwXyR7aX1gO1xuICAgIGNvbnN0IG5vcm1JZDIgPSBgbm9ybTJfJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBTZWxmLUF0dGVudGlvbiAke2l9YCxcbiAgICAgIHBhcmFtczogMyAqIDc2OCAqIDc2OCwgLy8gMyA9IFEsSyxWIG1hdHJpY2VzXG4gICAgICBmbG9wczogMTIgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA2ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZDEsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgTGF5ZXIgTm9ybSAxICgke2l9KWAsXG4gICAgICBwYXJhbXM6IDIgKiA3NjgsXG4gICAgICBmbG9wczogNzY4LFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAzMlxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbWxwSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBNTFAgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDc2OCAqIDMwNzIgKyAzMDcyICogNzY4LFxuICAgICAgZmxvcHM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZDIsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgTGF5ZXIgTm9ybSAyICgke2l9KWAsXG4gICAgICBwYXJhbXM6IDIgKiA3NjgsXG4gICAgICBmbG9wczogNzY4LFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAzMlxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dG5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRuSWQsIHRhcmdldDogbm9ybUlkMSB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBub3JtSWQxLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IG1scElkLCB0YXJnZXQ6IG5vcm1JZDIgfSk7XG4gICAgcHJldklkID0gbm9ybUlkMjtcbiAgfVxuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDc2OCAqIDUwMjU3LFxuICAgIGZsb3BzOiA3NjggKiA1MDI1NyxcbiAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVdoaXNwZXJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnQXVkaW8gSW5wdXQnLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gQ29udiBGcm9udGVuZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGNvbnN0IGNvbnZJZCA9IGBjb252XyR7aX1gO1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGNvbnZJZCxcbiAgICAgIHR5cGU6ICdjbm4nLFxuICAgICAgbmFtZTogYENvbnYgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDUxMiAqIDUxMiAqIDMgKiAzLFxuICAgICAgZmxvcHM6IDUxMiAqIDUxMiAqIDMgKiAzICogODAsXG4gICAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGNvbnZJZCB9KTtcbiAgICBwcmV2SWQgPSBjb252SWQ7XG4gIH1cblxuICAvLyBFbmNvZGVyIGJsb2NrcyAoNiBmb3IgYmFzZSBtb2RlbClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICBjb25zdCBhdHRuSWQgPSBgZW5jX2F0dG5fJHtpfWA7XG4gICAgY29uc3QgbWxwSWQgPSBgZW5jX21scF8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgZW5jX25vcm1fJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIEF0dGVudGlvbiAke2l9YCxcbiAgICAgIHBhcmFtczogMyAqIDUxMiAqIDUxMixcbiAgICAgIGZsb3BzOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogNCAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBtbHBJZCxcbiAgICAgIHR5cGU6ICdtbHAnLFxuICAgICAgbmFtZTogYEVuY29kZXIgTUxQICR7aX1gLFxuICAgICAgcGFyYW1zOiA1MTIgKiAyMDQ4ICsgMjA0OCAqIDUxMixcbiAgICAgIGZsb3BzOiA0ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBub3JtSWQsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgRW5jb2RlciBOb3JtICR7aX1gLFxuICAgICAgcGFyYW1zOiAyICogNTEyLFxuICAgICAgZmxvcHM6IDUxMixcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMzJcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRuSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYXR0bklkLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IG1scElkLCB0YXJnZXQ6IG5vcm1JZCB9KTtcbiAgICBwcmV2SWQgPSBub3JtSWQ7XG4gIH1cblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ091dHB1dCBMYXllcicsXG4gICAgcGFyYW1zOiA1MTIgKiA1MTg2NSwgLy8gdm9jYWIgc2l6ZVxuICAgIGZsb3BzOiA1MTIgKiA1MTg2NSxcbiAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbEFyY2hpdGVjdHVyZShtb2RlbElkOiBzdHJpbmcpOiBQcm9taXNlPE1vZGVsQXJjaGl0ZWN0dXJlPiB7XG4gIHN3aXRjaCAobW9kZWxJZCkge1xuICAgIGNhc2UgJ21pY3Jvc29mdC9yZXNuZXQtNTAnOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAnZmFjZWJvb2svYmFydC1sYXJnZS1jbm4nOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUoKTtcbiAgICBjYXNlICdnb29nbGUvdml0LWJhc2UtcGF0Y2gxNi0yMjQnOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlVmlUQXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAnbnZpZGlhL3N0YWJsZS1kaWZmdXNpb24tdjEuNSc6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUoKTtcbiAgICBjYXNlICdtZXRhLWxsYW1hL2xsYW1hLTItN2InOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlTGxhbWEyQXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAneW9sb3Y4JzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVlPTE92OEFyY2hpdGVjdHVyZSgpO1xuICAgIC8vIGNhc2UgJ29wZW5haS9ncHQtMic6XG4gICAgLy8gICByZXR1cm4gZ2VuZXJhdGVHUFQyQXJjaGl0ZWN0dXJlKCk7XG4gICAgLy8gY2FzZSAnb3BlbmFpL3doaXNwZXItYmFzZSc6XG4gICAgLy8gICByZXR1cm4gZ2VuZXJhdGVXaGlzcGVyQXJjaGl0ZWN0dXJlKCk7XG4gICAgLy8gY2FzZSAnZG1pcy1sYWIvYmlvYmVydC1iYXNlJzpcbiAgICAvLyAgIHJldHVybiBnZW5lcmF0ZUJpb0JFUlRBcmNoaXRlY3R1cmUoKTtcbiAgICAvLyBjYXNlICdmYWNlYm9vay9kaW5vdjItYmFzZSc6XG4gICAgLy8gICByZXR1cm4gZ2VuZXJhdGVESU5PdjJBcmNoaXRlY3R1cmUoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdlbmVyYXRlRGVmYXVsdEFyY2hpdGVjdHVyZSgpO1xuICB9XG59XG5cbi8vIEltcG9ydCBhcmNoaXRlY3R1cmUgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbmltcG9ydCB7IE1vZGVsQXJjaGl0ZWN0dXJlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZURlZmF1bHRBcmNoaXRlY3R1cmUsXG4gIGdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVRyYW5zZm9ybWVyQXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVZpVEFyY2hpdGVjdHVyZSxcbiAgZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUsXG4gIGdlbmVyYXRlTGxhbWEyQXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVlPTE92OEFyY2hpdGVjdHVyZSxcbiAgXG4gfSBmcm9tICcuL21vZGVsLWFyY2hpdGVjdHVyZXMnO1xuIl0sIm5hbWVzIjpbIkZFQVRVUkVEX01PREVMUyIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwidHlwZSIsInRhc2siLCJhcmNoaXRlY3R1cmUiLCJzaXplIiwiZG93bmxvYWRzIiwibGlrZXMiLCJ0YWdzIiwic2VhcmNoTW9kZWxzIiwicXVlcnkiLCJyZXNwb25zZSIsImZldGNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaGVhZGVycyIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJ0ZXh0IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJtb2RlbCIsIm1vZGVsSWQiLCJzcGxpdCIsInBvcCIsImRldGVybWluZU1vZGVsVHlwZSIsInBpcGVsaW5lX3RhZyIsImNvbmZpZyIsImFyY2hpdGVjdHVyZXMiLCJmb3JtYXRTaXplIiwiYmluYXJ5IiwidG90YWwiLCJsaWJyYXJ5X25hbWUiLCJmaWx0ZXIiLCJCb29sZWFuIiwicGlwZWxpbmVUYWciLCJ2aXNpb25UYXNrcyIsInRleHRUYXNrcyIsImF1ZGlvVGFza3MiLCJpbmNsdWRlcyIsImJ5dGVzIiwiayIsInNpemVzIiwiaSIsIk1hdGgiLCJmbG9vciIsImxvZyIsInBhcnNlRmxvYXQiLCJwb3ciLCJ0b0ZpeGVkIiwiZ2V0TW9kZWxJbmZvIiwianNvbiIsImdlbmVyYXRlR1BUMkFyY2hpdGVjdHVyZSIsIm5vZGVzIiwicGFyYW1zIiwiZmxvcHMiLCJtZW1vcnlVc2FnZSIsImVkZ2VzIiwicHJldklkIiwicHVzaCIsInNvdXJjZSIsInRhcmdldCIsImF0dG5JZCIsIm5vcm1JZDEiLCJtbHBJZCIsIm5vcm1JZDIiLCJnZW5lcmF0ZVdoaXNwZXJBcmNoaXRlY3R1cmUiLCJjb252SWQiLCJub3JtSWQiLCJnZXRNb2RlbEFyY2hpdGVjdHVyZSIsImdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVUcmFuc2Zvcm1lckFyY2hpdGVjdHVyZSIsImdlbmVyYXRlVmlUQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVEZWZhdWx0QXJjaGl0ZWN0dXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/huggingface.ts\n"));

/***/ })

});