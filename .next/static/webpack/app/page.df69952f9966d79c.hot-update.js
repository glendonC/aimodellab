"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/huggingface.ts":
/*!****************************!*\
  !*** ./lib/huggingface.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FEATURED_MODELS: function() { return /* binding */ FEATURED_MODELS; },\n/* harmony export */   getModelArchitecture: function() { return /* binding */ getModelArchitecture; },\n/* harmony export */   getModelInfo: function() { return /* binding */ getModelInfo; },\n/* harmony export */   searchModels: function() { return /* binding */ searchModels; }\n/* harmony export */ });\nconst FEATURED_MODELS = [\n    // Vision Models (GPU-Intensive)\n    {\n        id: \"microsoft/resnet-50\",\n        name: \"ResNet-50\",\n        description: \"State-of-the-art image classification model with CUDA optimization\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"ResNet\",\n        size: \"98 MB\",\n        downloads: 2500000,\n        likes: 1200,\n        tags: [\n            \"computer-vision\",\n            \"classification\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"nvidia/stable-diffusion-v1.5\",\n        name: \"Stable Diffusion v1.5\",\n        description: \"Optimized for NVIDIA GPUs with tensor core acceleration\",\n        type: \"vision\",\n        task: \"text-to-image\",\n        architecture: \"Diffusion\",\n        size: \"7.7 GB\",\n        downloads: 5800000,\n        likes: 3200,\n        tags: [\n            \"generative-ai\",\n            \"text-to-image\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"yolov8\",\n        name: \"YOLOv8\",\n        description: \"Real-time object detection with CUDA acceleration\",\n        type: \"vision\",\n        task: \"object-detection\",\n        architecture: \"YOLO\",\n        size: \"108 MB\",\n        downloads: 4200000,\n        likes: 2800,\n        tags: [\n            \"object-detection\",\n            \"real-time\",\n            \"tensorrt\"\n        ]\n    },\n    // Large Language Models\n    {\n        id: \"meta-llama/llama-2-7b\",\n        name: \"Llama 2 (7B)\",\n        description: \"Efficient large language model with multi-GPU scaling\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"13.5 GB\",\n        downloads: 8500000,\n        likes: 4500,\n        tags: [\n            \"llm\",\n            \"multi-gpu\",\n            \"fp16-optimized\"\n        ]\n    },\n    {\n        id: \"openai/gpt-2\",\n        name: \"GPT-2 Small\",\n        description: \"Compact language model with GPU acceleration\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"1.5 GB\",\n        downloads: 3800000,\n        likes: 2100,\n        tags: [\n            \"nlp\",\n            \"text-generation\",\n            \"cuda\"\n        ]\n    },\n    // Specialized Models\n    {\n        id: \"facebook/bart-large-cnn\",\n        name: \"BART Large CNN\",\n        description: \"GPU-accelerated text summarization model\",\n        type: \"text\",\n        task: \"summarization\",\n        architecture: \"Transformer\",\n        size: \"1.6 GB\",\n        downloads: 1800000,\n        likes: 950,\n        tags: [\n            \"nlp\",\n            \"summarization\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"openai/whisper-base\",\n        name: \"Whisper Base\",\n        description: \"Speech recognition optimized for NVIDIA GPUs\",\n        type: \"audio\",\n        task: \"speech-recognition\",\n        architecture: \"Transformer\",\n        size: \"442 MB\",\n        downloads: 2900000,\n        likes: 1600,\n        tags: [\n            \"speech\",\n            \"audio\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"google/vit-base-patch16-224\",\n        name: \"ViT Base\",\n        description: \"Vision Transformer with tensor core acceleration\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"Transformer\",\n        size: \"346 MB\",\n        downloads: 3200000,\n        likes: 1500,\n        tags: [\n            \"vision\",\n            \"transformers\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"dmis-lab/biobert-base\",\n        name: \"BioBERT\",\n        description: \"Biomedical language model with GPU optimization\",\n        type: \"text\",\n        task: \"text-classification\",\n        architecture: \"BERT\",\n        size: \"412 MB\",\n        downloads: 890000,\n        likes: 720,\n        tags: [\n            \"healthcare\",\n            \"nlp\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"facebook/dinov2-base\",\n        name: \"DINOv2\",\n        description: \"Self-supervised vision model with NVIDIA acceleration\",\n        type: \"vision\",\n        task: \"self-supervised-learning\",\n        architecture: \"Transformer\",\n        size: \"384 MB\",\n        downloads: 1200000,\n        likes: 890,\n        tags: [\n            \"self-supervised\",\n            \"vision\",\n            \"cuda\"\n        ]\n    }\n];\nasync function searchModels(query) {\n    try {\n        const response = await fetch(\"https://huggingface.co/api/models?search=\".concat(encodeURIComponent(query)), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const text = await response.text();\n        if (!text) {\n            return [];\n        }\n        let data;\n        try {\n            data = JSON.parse(text);\n        } catch (e) {\n            console.error(\"Failed to parse response:\", e);\n            return [];\n        }\n        if (!Array.isArray(data)) {\n            console.error(\"Unexpected response format:\", data);\n            return [];\n        }\n        return data.map((model)=>{\n            var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n            return {\n                id: model.modelId || model.id,\n                name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n                description: model.description || \"No description available\",\n                type: determineModelType(model.pipeline_tag),\n                task: model.pipeline_tag || \"unknown\",\n                architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n                size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n                downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n                likes: model.likes || 0,\n                tags: [\n                    model.pipeline_tag,\n                    ...model.tags || [],\n                    model.library_name\n                ].filter(Boolean)\n            };\n        });\n    } catch (error) {\n        console.error(\"Failed to search models:\", error);\n        return [];\n    }\n}\nfunction determineModelType(pipelineTag) {\n    if (!pipelineTag) return \"vision\";\n    const visionTasks = [\n        \"image-classification\",\n        \"object-detection\",\n        \"image-segmentation\"\n    ];\n    const textTasks = [\n        \"text-classification\",\n        \"text-generation\",\n        \"translation\"\n    ];\n    const audioTasks = [\n        \"audio-classification\",\n        \"speech-recognition\"\n    ];\n    if (visionTasks.includes(pipelineTag)) return \"vision\";\n    if (textTasks.includes(pipelineTag)) return \"text\";\n    if (audioTasks.includes(pipelineTag)) return \"audio\";\n    return \"multimodal\";\n}\nfunction formatSize(bytes) {\n    if (bytes === 0) return \"0 B\";\n    const k = 1024;\n    const sizes = [\n        \"B\",\n        \"KB\",\n        \"MB\",\n        \"GB\",\n        \"TB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + \" \" + sizes[i];\n}\nasync function getModelInfo(modelId) {\n    try {\n        var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n        const response = await fetch(\"https://huggingface.co/api/models/\".concat(modelId), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Model not found\");\n        }\n        const model = await response.json();\n        return {\n            id: model.modelId || model.id,\n            name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n            description: model.description || \"No description available\",\n            type: determineModelType(model.pipeline_tag),\n            task: model.pipeline_tag || \"unknown\",\n            architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n            size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n            downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n            likes: model.likes || 0,\n            tags: [\n                model.pipeline_tag,\n                ...model.tags || [],\n                model.library_name\n            ].filter(Boolean)\n        };\n    } catch (error) {\n        console.error(\"Failed to get model info:\", error);\n        throw error;\n    }\n}\nasync function getModelArchitecture(modelId) {\n    switch(modelId){\n        case \"microsoft/resnet-50\":\n            return generateResNetArchitecture();\n        case \"facebook/bart-large-cnn\":\n            return generateTransformerArchitecture();\n        case \"google/vit-base-patch16-224\":\n            return generateViTArchitecture();\n        case \"nvidia/stable-diffusion-v1.5\":\n            return generateStableDiffusionArchitecture();\n        case \"meta-llama/llama-2-7b\":\n            return generateLlama2Architecture();\n        case \"yolov8\":\n            return generateYOLOv8Architecture();\n        // Add more cases as we implement them\n        default:\n            return generateDefaultArchitecture();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9odWdnaW5nZmFjZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBOEJPLE1BQU1BLGtCQUE2QjtJQUN4QyxnQ0FBZ0M7SUFDaEM7UUFDRUMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsTUFBTTtZQUFDO1lBQW1CO1lBQWtCO1NBQWlCO0lBQy9EO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsTUFBTTtZQUFDO1lBQWlCO1lBQWlCO1NBQWU7SUFDMUQ7SUFDQTtRQUNFVCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsY0FBYztRQUNkQyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxNQUFNO1lBQUM7WUFBb0I7WUFBYTtTQUFXO0lBQ3JEO0lBRUEsd0JBQXdCO0lBQ3hCO1FBQ0VULElBQUk7UUFDSkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxjQUFjO1FBQ2RDLE1BQU07UUFDTkMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLE1BQU07WUFBQztZQUFPO1lBQWE7U0FBaUI7SUFDOUM7SUFDQTtRQUNFVCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsY0FBYztRQUNkQyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxNQUFNO1lBQUM7WUFBTztZQUFtQjtTQUFPO0lBQzFDO0lBRUEscUJBQXFCO0lBQ3JCO1FBQ0VULElBQUk7UUFDSkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLE1B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Q0Y7QUFFTyxlQUFlbUMscUJBQXFCOUIsT0FBZTtJQUN4RCxPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPK0I7UUFDVCxLQUFLO1lBQ0gsT0FBT0M7UUFDVCxLQUFLO1lBQ0gsT0FBT0M7UUFDVCxLQUFLO1lBQ0gsT0FBT0M7UUFDVCxLQUFLO1lBQ0gsT0FBT0M7UUFDVCxLQUFLO1lBQ0gsT0FBT0M7UUFDVCxzQ0FBc0M7UUFDdEM7WUFDRSxPQUFPQztJQUNYO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2h1Z2dpbmdmYWNlLnRzP2EwZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGZJbmZlcmVuY2UgfSBmcm9tICdAaHVnZ2luZ2ZhY2UvaW5mZXJlbmNlJztcblxuZXhwb3J0IHR5cGUgSEZNb2RlbCA9IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICB0eXBlOiAndmlzaW9uJyB8ICd0ZXh0JyB8ICdhdWRpbycgfCAnbXVsdGltb2RhbCc7XG4gIHRhc2s6IHN0cmluZztcbiAgYXJjaGl0ZWN0dXJlOiBzdHJpbmc7XG4gIHNpemU6IHN0cmluZztcbiAgZG93bmxvYWRzOiBudW1iZXI7XG4gIGxpa2VzOiBudW1iZXI7XG4gIHRhZ3M6IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IHR5cGUgTW9kZWxBcmNoaXRlY3R1cmUgPSB7XG4gIG5vZGVzOiBBcnJheTx7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHBhcmFtczogbnVtYmVyO1xuICAgIGZsb3BzOiBudW1iZXI7XG4gICAgbWVtb3J5VXNhZ2U6IG51bWJlcjtcbiAgfT47XG4gIGVkZ2VzOiBBcnJheTx7XG4gICAgc291cmNlOiBzdHJpbmc7XG4gICAgdGFyZ2V0OiBzdHJpbmc7XG4gIH0+O1xufTtcblxuZXhwb3J0IGNvbnN0IEZFQVRVUkVEX01PREVMUzogSEZNb2RlbFtdID0gW1xuICAvLyBWaXNpb24gTW9kZWxzIChHUFUtSW50ZW5zaXZlKVxuICB7XG4gICAgaWQ6ICdtaWNyb3NvZnQvcmVzbmV0LTUwJyxcbiAgICBuYW1lOiAnUmVzTmV0LTUwJyxcbiAgICBkZXNjcmlwdGlvbjogJ1N0YXRlLW9mLXRoZS1hcnQgaW1hZ2UgY2xhc3NpZmljYXRpb24gbW9kZWwgd2l0aCBDVURBIG9wdGltaXphdGlvbicsXG4gICAgdHlwZTogJ3Zpc2lvbicsXG4gICAgdGFzazogJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdSZXNOZXQnLFxuICAgIHNpemU6ICc5OCBNQicsXG4gICAgZG93bmxvYWRzOiAyNTAwMDAwLFxuICAgIGxpa2VzOiAxMjAwLFxuICAgIHRhZ3M6IFsnY29tcHV0ZXItdmlzaW9uJywgJ2NsYXNzaWZpY2F0aW9uJywgJ2N1ZGEtb3B0aW1pemVkJ11cbiAgfSxcbiAge1xuICAgIGlkOiAnbnZpZGlhL3N0YWJsZS1kaWZmdXNpb24tdjEuNScsXG4gICAgbmFtZTogJ1N0YWJsZSBEaWZmdXNpb24gdjEuNScsXG4gICAgZGVzY3JpcHRpb246ICdPcHRpbWl6ZWQgZm9yIE5WSURJQSBHUFVzIHdpdGggdGVuc29yIGNvcmUgYWNjZWxlcmF0aW9uJyxcbiAgICB0eXBlOiAndmlzaW9uJyxcbiAgICB0YXNrOiAndGV4dC10by1pbWFnZScsXG4gICAgYXJjaGl0ZWN0dXJlOiAnRGlmZnVzaW9uJyxcbiAgICBzaXplOiAnNy43IEdCJyxcbiAgICBkb3dubG9hZHM6IDU4MDAwMDAsXG4gICAgbGlrZXM6IDMyMDAsXG4gICAgdGFnczogWydnZW5lcmF0aXZlLWFpJywgJ3RleHQtdG8taW1hZ2UnLCAndGVuc29yLWNvcmVzJ11cbiAgfSxcbiAge1xuICAgIGlkOiAneW9sb3Y4JyxcbiAgICBuYW1lOiAnWU9MT3Y4JyxcbiAgICBkZXNjcmlwdGlvbjogJ1JlYWwtdGltZSBvYmplY3QgZGV0ZWN0aW9uIHdpdGggQ1VEQSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICdvYmplY3QtZGV0ZWN0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdZT0xPJyxcbiAgICBzaXplOiAnMTA4IE1CJyxcbiAgICBkb3dubG9hZHM6IDQyMDAwMDAsXG4gICAgbGlrZXM6IDI4MDAsXG4gICAgdGFnczogWydvYmplY3QtZGV0ZWN0aW9uJywgJ3JlYWwtdGltZScsICd0ZW5zb3JydCddXG4gIH0sXG4gIFxuICAvLyBMYXJnZSBMYW5ndWFnZSBNb2RlbHNcbiAge1xuICAgIGlkOiAnbWV0YS1sbGFtYS9sbGFtYS0yLTdiJyxcbiAgICBuYW1lOiAnTGxhbWEgMiAoN0IpJyxcbiAgICBkZXNjcmlwdGlvbjogJ0VmZmljaWVudCBsYXJnZSBsYW5ndWFnZSBtb2RlbCB3aXRoIG11bHRpLUdQVSBzY2FsaW5nJyxcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgdGFzazogJ3RleHQtZ2VuZXJhdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICcxMy41IEdCJyxcbiAgICBkb3dubG9hZHM6IDg1MDAwMDAsXG4gICAgbGlrZXM6IDQ1MDAsXG4gICAgdGFnczogWydsbG0nLCAnbXVsdGktZ3B1JywgJ2ZwMTYtb3B0aW1pemVkJ11cbiAgfSxcbiAge1xuICAgIGlkOiAnb3BlbmFpL2dwdC0yJyxcbiAgICBuYW1lOiAnR1BULTIgU21hbGwnLFxuICAgIGRlc2NyaXB0aW9uOiAnQ29tcGFjdCBsYW5ndWFnZSBtb2RlbCB3aXRoIEdQVSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICB0YXNrOiAndGV4dC1nZW5lcmF0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzEuNSBHQicsXG4gICAgZG93bmxvYWRzOiAzODAwMDAwLFxuICAgIGxpa2VzOiAyMTAwLFxuICAgIHRhZ3M6IFsnbmxwJywgJ3RleHQtZ2VuZXJhdGlvbicsICdjdWRhJ11cbiAgfSxcblxuICAvLyBTcGVjaWFsaXplZCBNb2RlbHNcbiAge1xuICAgIGlkOiAnZmFjZWJvb2svYmFydC1sYXJnZS1jbm4nLFxuICAgIG5hbWU6ICdCQVJUIExhcmdlIENOTicsXG4gICAgZGVzY3JpcHRpb246ICdHUFUtYWNjZWxlcmF0ZWQgdGV4dCBzdW1tYXJpemF0aW9uIG1vZGVsJyxcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgdGFzazogJ3N1bW1hcml6YXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnMS42IEdCJyxcbiAgICBkb3dubG9hZHM6IDE4MDAwMDAsXG4gICAgbGlrZXM6IDk1MCxcbiAgICB0YWdzOiBbJ25scCcsICdzdW1tYXJpemF0aW9uJywgJ2N1ZGEnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdvcGVuYWkvd2hpc3Blci1iYXNlJyxcbiAgICBuYW1lOiAnV2hpc3BlciBCYXNlJyxcbiAgICBkZXNjcmlwdGlvbjogJ1NwZWVjaCByZWNvZ25pdGlvbiBvcHRpbWl6ZWQgZm9yIE5WSURJQSBHUFVzJyxcbiAgICB0eXBlOiAnYXVkaW8nLFxuICAgIHRhc2s6ICdzcGVlY2gtcmVjb2duaXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnNDQyIE1CJyxcbiAgICBkb3dubG9hZHM6IDI5MDAwMDAsXG4gICAgbGlrZXM6IDE2MDAsXG4gICAgdGFnczogWydzcGVlY2gnLCAnYXVkaW8nLCAnY3VkYS1vcHRpbWl6ZWQnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdnb29nbGUvdml0LWJhc2UtcGF0Y2gxNi0yMjQnLFxuICAgIG5hbWU6ICdWaVQgQmFzZScsXG4gICAgZGVzY3JpcHRpb246ICdWaXNpb24gVHJhbnNmb3JtZXIgd2l0aCB0ZW5zb3IgY29yZSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICdpbWFnZS1jbGFzc2lmaWNhdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICczNDYgTUInLFxuICAgIGRvd25sb2FkczogMzIwMDAwMCxcbiAgICBsaWtlczogMTUwMCxcbiAgICB0YWdzOiBbJ3Zpc2lvbicsICd0cmFuc2Zvcm1lcnMnLCAndGVuc29yLWNvcmVzJ11cbiAgfSxcbiAge1xuICAgIGlkOiAnZG1pcy1sYWIvYmlvYmVydC1iYXNlJyxcbiAgICBuYW1lOiAnQmlvQkVSVCcsXG4gICAgZGVzY3JpcHRpb246ICdCaW9tZWRpY2FsIGxhbmd1YWdlIG1vZGVsIHdpdGggR1BVIG9wdGltaXphdGlvbicsXG4gICAgdHlwZTogJ3RleHQnLFxuICAgIHRhc2s6ICd0ZXh0LWNsYXNzaWZpY2F0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdCRVJUJyxcbiAgICBzaXplOiAnNDEyIE1CJyxcbiAgICBkb3dubG9hZHM6IDg5MDAwMCxcbiAgICBsaWtlczogNzIwLFxuICAgIHRhZ3M6IFsnaGVhbHRoY2FyZScsICdubHAnLCAnY3VkYSddXG4gIH0sXG4gIHtcbiAgICBpZDogJ2ZhY2Vib29rL2Rpbm92Mi1iYXNlJyxcbiAgICBuYW1lOiAnRElOT3YyJyxcbiAgICBkZXNjcmlwdGlvbjogJ1NlbGYtc3VwZXJ2aXNlZCB2aXNpb24gbW9kZWwgd2l0aCBOVklESUEgYWNjZWxlcmF0aW9uJyxcbiAgICB0eXBlOiAndmlzaW9uJyxcbiAgICB0YXNrOiAnc2VsZi1zdXBlcnZpc2VkLWxlYXJuaW5nJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzM4NCBNQicsXG4gICAgZG93bmxvYWRzOiAxMjAwMDAwLFxuICAgIGxpa2VzOiA4OTAsXG4gICAgdGFnczogWydzZWxmLXN1cGVydmlzZWQnLCAndmlzaW9uJywgJ2N1ZGEnXVxuICB9XG5dO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2VhcmNoTW9kZWxzKHF1ZXJ5OiBzdHJpbmcpOiBQcm9taXNlPEhGTW9kZWxbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvbW9kZWxzP3NlYXJjaD0ke2VuY29kZVVSSUNvbXBvbmVudChxdWVyeSl9YCxcbiAgICAgIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgZGF0YTtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlOicsIGUpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgY29uc29sZS5lcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQ6JywgZGF0YSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWFwKChtb2RlbDogYW55KSA9PiAoe1xuICAgICAgaWQ6IG1vZGVsLm1vZGVsSWQgfHwgbW9kZWwuaWQsXG4gICAgICBuYW1lOiAobW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCk/LnNwbGl0KCcvJykucG9wKCkgfHwgJ1Vua25vd24gTW9kZWwnLFxuICAgICAgZGVzY3JpcHRpb246IG1vZGVsLmRlc2NyaXB0aW9uIHx8ICdObyBkZXNjcmlwdGlvbiBhdmFpbGFibGUnLFxuICAgICAgdHlwZTogZGV0ZXJtaW5lTW9kZWxUeXBlKG1vZGVsLnBpcGVsaW5lX3RhZyksXG4gICAgICB0YXNrOiBtb2RlbC5waXBlbGluZV90YWcgfHwgJ3Vua25vd24nLFxuICAgICAgYXJjaGl0ZWN0dXJlOiBtb2RlbC5jb25maWc/LmFyY2hpdGVjdHVyZXM/LlswXSB8fCAndW5rbm93bicsXG4gICAgICBzaXplOiBmb3JtYXRTaXplKG1vZGVsLmRvd25sb2Fkcz8uYmluYXJ5Py5zaXplIHx8IDApLFxuICAgICAgZG93bmxvYWRzOiBtb2RlbC5kb3dubG9hZHM/LnRvdGFsIHx8IDAsXG4gICAgICBsaWtlczogbW9kZWwubGlrZXMgfHwgMCxcbiAgICAgIHRhZ3M6IFtcbiAgICAgICAgbW9kZWwucGlwZWxpbmVfdGFnLFxuICAgICAgICAuLi4obW9kZWwudGFncyB8fCBbXSksXG4gICAgICAgIG1vZGVsLmxpYnJhcnlfbmFtZVxuICAgICAgXS5maWx0ZXIoQm9vbGVhbilcbiAgICB9KSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlYXJjaCBtb2RlbHM6JywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNb2RlbFR5cGUocGlwZWxpbmVUYWc6IHN0cmluZyk6IEhGTW9kZWxbJ3R5cGUnXSB7XG4gIGlmICghcGlwZWxpbmVUYWcpIHJldHVybiAndmlzaW9uJztcbiAgXG4gIGNvbnN0IHZpc2lvblRhc2tzID0gWydpbWFnZS1jbGFzc2lmaWNhdGlvbicsICdvYmplY3QtZGV0ZWN0aW9uJywgJ2ltYWdlLXNlZ21lbnRhdGlvbiddO1xuICBjb25zdCB0ZXh0VGFza3MgPSBbJ3RleHQtY2xhc3NpZmljYXRpb24nLCAndGV4dC1nZW5lcmF0aW9uJywgJ3RyYW5zbGF0aW9uJ107XG4gIGNvbnN0IGF1ZGlvVGFza3MgPSBbJ2F1ZGlvLWNsYXNzaWZpY2F0aW9uJywgJ3NwZWVjaC1yZWNvZ25pdGlvbiddO1xuICBcbiAgaWYgKHZpc2lvblRhc2tzLmluY2x1ZGVzKHBpcGVsaW5lVGFnKSkgcmV0dXJuICd2aXNpb24nO1xuICBpZiAodGV4dFRhc2tzLmluY2x1ZGVzKHBpcGVsaW5lVGFnKSkgcmV0dXJuICd0ZXh0JztcbiAgaWYgKGF1ZGlvVGFza3MuaW5jbHVkZXMocGlwZWxpbmVUYWcpKSByZXR1cm4gJ2F1ZGlvJztcbiAgcmV0dXJuICdtdWx0aW1vZGFsJztcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2l6ZShieXRlczogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKGJ5dGVzID09PSAwKSByZXR1cm4gJzAgQic7XG4gIGNvbnN0IGsgPSAxMDI0O1xuICBjb25zdCBzaXplcyA9IFsnQicsICdLQicsICdNQicsICdHQicsICdUQiddO1xuICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSk7XG4gIHJldHVybiBwYXJzZUZsb2F0KChieXRlcyAvIE1hdGgucG93KGssIGkpKS50b0ZpeGVkKDEpKSArICcgJyArIHNpemVzW2ldO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TW9kZWxJbmZvKG1vZGVsSWQ6IHN0cmluZyk6IFByb21pc2U8SEZNb2RlbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vaHVnZ2luZ2ZhY2UuY28vYXBpL21vZGVscy8ke21vZGVsSWR9YCwge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNb2RlbCBub3QgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBtb2RlbCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IG1vZGVsLm1vZGVsSWQgfHwgbW9kZWwuaWQsXG4gICAgICBuYW1lOiAobW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCk/LnNwbGl0KCcvJykucG9wKCkgfHwgJ1Vua25vd24gTW9kZWwnLFxuICAgICAgZGVzY3JpcHRpb246IG1vZGVsLmRlc2NyaXB0aW9uIHx8ICdObyBkZXNjcmlwdGlvbiBhdmFpbGFibGUnLFxuICAgICAgdHlwZTogZGV0ZXJtaW5lTW9kZWxUeXBlKG1vZGVsLnBpcGVsaW5lX3RhZyksXG4gICAgICB0YXNrOiBtb2RlbC5waXBlbGluZV90YWcgfHwgJ3Vua25vd24nLFxuICAgICAgYXJjaGl0ZWN0dXJlOiBtb2RlbC5jb25maWc/LmFyY2hpdGVjdHVyZXM/LlswXSB8fCAndW5rbm93bicsXG4gICAgICBzaXplOiBmb3JtYXRTaXplKG1vZGVsLmRvd25sb2Fkcz8uYmluYXJ5Py5zaXplIHx8IDApLFxuICAgICAgZG93bmxvYWRzOiBtb2RlbC5kb3dubG9hZHM/LnRvdGFsIHx8IDAsXG4gICAgICBsaWtlczogbW9kZWwubGlrZXMgfHwgMCxcbiAgICAgIHRhZ3M6IFtcbiAgICAgICAgbW9kZWwucGlwZWxpbmVfdGFnLFxuICAgICAgICAuLi4obW9kZWwudGFncyB8fCBbXSksXG4gICAgICAgIG1vZGVsLmxpYnJhcnlfbmFtZVxuICAgICAgXS5maWx0ZXIoQm9vbGVhbilcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZXQgbW9kZWwgaW5mbzonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vZGVsQXJjaGl0ZWN0dXJlKG1vZGVsSWQ6IHN0cmluZyk6IFByb21pc2U8TW9kZWxBcmNoaXRlY3R1cmU+IHtcbiAgc3dpdGNoIChtb2RlbElkKSB7XG4gICAgY2FzZSAnbWljcm9zb2Z0L3Jlc25ldC01MCc6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUoKTtcbiAgICBjYXNlICdmYWNlYm9vay9iYXJ0LWxhcmdlLWNubic6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVUcmFuc2Zvcm1lckFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ2dvb2dsZS92aXQtYmFzZS1wYXRjaDE2LTIyNCc6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUoKTtcbiAgICBjYXNlICdudmlkaWEvc3RhYmxlLWRpZmZ1c2lvbi12MS41JzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVN0YWJsZURpZmZ1c2lvbkFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ21ldGEtbGxhbWEvbGxhbWEtMi03Yic6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVMbGFtYTJBcmNoaXRlY3R1cmUoKTtcbiAgICBjYXNlICd5b2xvdjgnOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlKCk7XG4gICAgLy8gQWRkIG1vcmUgY2FzZXMgYXMgd2UgaW1wbGVtZW50IHRoZW1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdlbmVyYXRlRGVmYXVsdEFyY2hpdGVjdHVyZSgpO1xuICB9XG59XG5cbi8vIEltcG9ydCBhcmNoaXRlY3R1cmUgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbmltcG9ydCB7IE1vZGVsQXJjaGl0ZWN0dXJlIH0gZnJvbSAnLi90eXBlcyc7Il0sIm5hbWVzIjpbIkZFQVRVUkVEX01PREVMUyIsImlkIiwibmFtZSIsImRlc2NyaXB0aW9uIiwidHlwZSIsInRhc2siLCJhcmNoaXRlY3R1cmUiLCJzaXplIiwiZG93bmxvYWRzIiwibGlrZXMiLCJ0YWdzIiwic2VhcmNoTW9kZWxzIiwicXVlcnkiLCJyZXNwb25zZSIsImZldGNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiaGVhZGVycyIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJ0ZXh0IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJtb2RlbCIsIm1vZGVsSWQiLCJzcGxpdCIsInBvcCIsImRldGVybWluZU1vZGVsVHlwZSIsInBpcGVsaW5lX3RhZyIsImNvbmZpZyIsImFyY2hpdGVjdHVyZXMiLCJmb3JtYXRTaXplIiwiYmluYXJ5IiwidG90YWwiLCJsaWJyYXJ5X25hbWUiLCJmaWx0ZXIiLCJCb29sZWFuIiwicGlwZWxpbmVUYWciLCJ2aXNpb25UYXNrcyIsInRleHRUYXNrcyIsImF1ZGlvVGFza3MiLCJpbmNsdWRlcyIsImJ5dGVzIiwiayIsInNpemVzIiwiaSIsIk1hdGgiLCJmbG9vciIsImxvZyIsInBhcnNlRmxvYXQiLCJwb3ciLCJ0b0ZpeGVkIiwiZ2V0TW9kZWxJbmZvIiwianNvbiIsImdldE1vZGVsQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZVRyYW5zZm9ybWVyQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZVN0YWJsZURpZmZ1c2lvbkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlTGxhbWEyQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVZT0xPdjhBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZURlZmF1bHRBcmNoaXRlY3R1cmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/huggingface.ts\n"));

/***/ })

});