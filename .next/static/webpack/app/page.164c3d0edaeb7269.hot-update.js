"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model-architectures.ts":
/*!************************************!*\
  !*** ./lib/model-architectures.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDefaultArchitecture: function() { return /* binding */ generateDefaultArchitecture; },\n/* harmony export */   generateLlama2Architecture: function() { return /* binding */ generateLlama2Architecture; },\n/* harmony export */   generateResNetArchitecture: function() { return /* binding */ generateResNetArchitecture; },\n/* harmony export */   generateStableDiffusionArchitecture: function() { return /* binding */ generateStableDiffusionArchitecture; },\n/* harmony export */   generateTransformerArchitecture: function() { return /* binding */ generateTransformerArchitecture; },\n/* harmony export */   generateViTArchitecture: function() { return /* binding */ generateViTArchitecture; },\n/* harmony export */   generateYOLOv8Architecture: function() { return /* binding */ generateYOLOv8Architecture; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ generateResNetArchitecture,generateTransformerArchitecture,generateViTArchitecture,generateYOLOv8Architecture,generateStableDiffusionArchitecture,generateLlama2Architecture,generateDefaultArchitecture auto */ function generateResNetArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Initial convolution\n    nodes.push({\n        id: \"conv1\",\n        type: \"cnn\",\n        name: \"Conv1\",\n        params: 9408,\n        flops: 118013952,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"conv1\"\n    });\n    prevId = \"conv1\";\n    // ResNet blocks\n    const blocks = [\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\"\n    ];\n    blocks.forEach((block, i)=>{\n        // Each block has multiple residual units\n        for(let unit = 0; unit < 3; unit++){\n            const blockId = \"res\".concat(block, \"_\").concat(unit);\n            nodes.push({\n                id: blockId,\n                type: \"residual\",\n                name: \"ResBlock \".concat(block, \".\").concat(unit),\n                params: 1024 * 1024 * (i + 1),\n                flops: 5 * 1024 * 1024 * (i + 1),\n                memoryUsage: 3 * 1024 * 1024 * (i + 1)\n            });\n            edges.push({\n                source: prevId,\n                target: blockId\n            });\n            prevId = blockId;\n        }\n    });\n    // Final layers\n    nodes.push({\n        id: \"pool\",\n        type: \"mlp\",\n        name: \"Global Pool\",\n        params: 2048,\n        flops: 2048,\n        memoryUsage: 1024 * 512\n    });\n    edges.push({\n        source: prevId,\n        target: \"pool\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"FC 1000\",\n        params: 2048000,\n        flops: 2048000,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"pool\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateTransformerArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Encoder layers\n    for(let i = 0; i < 6; i++){\n        const attentionId = \"enc_attn_\".concat(i);\n        const ffnId = \"enc_ffn_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"attention\",\n            name: \"Encoder Self-Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: ffnId,\n            type: \"mlp\",\n            name: \"Encoder FFN \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Layer Norm \".concat(i),\n            params: 1024,\n            flops: 2048,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: ffnId\n        });\n        edges.push({\n            source: ffnId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    // Output projection\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Projection\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateViTArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Patch Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Patch embedding\n    nodes.push({\n        id: \"patch_embed\",\n        type: \"cnn\",\n        name: \"Patch Embedding\",\n        params: 590592,\n        flops: 47185920,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"patch_embed\"\n    });\n    prevId = \"patch_embed\";\n    // Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attentionId = \"transformer_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"transformer\",\n            name: \"Transformer Block \".concat(i),\n            params: 7 * 1024 * 1024,\n            flops: 28 * 1024 * 1024,\n            memoryUsage: 14 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: mlpId\n        });\n        prevId = mlpId;\n    }\n    // Classification head\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Classification Head\",\n        params: 768000,\n        flops: 768000,\n        memoryUsage: 1024 * 768\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateYOLOv8Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024 // 1MB for input tensor\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Backbone: CSPDarknet\n    for(let i = 0; i < 4; i++){\n        const convId = \"conv_\".concat(i);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Conv Block \".concat(i + 1),\n            params: 64 * Math.pow(2, i) * 3 * 3,\n            flops: 64 * Math.pow(2, i) * 3 * 3 * 512 * 512 / Math.pow(2, i),\n            memoryUsage: 512 * 512 * 64 * Math.pow(2, i) / Math.pow(2, i) * 4 // 4 bytes per float\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    }\n    // Feature Pyramid Network (FPN)\n    const fpnLayers = [\n        \"P5\",\n        \"P4\",\n        \"P3\"\n    ];\n    fpnLayers.forEach((layer, i)=>{\n        const fpnId = \"fpn_\".concat(layer);\n        nodes.push({\n            id: fpnId,\n            type: \"graph\",\n            name: \"FPN \".concat(layer),\n            params: 256 * 256 * 3,\n            flops: 256 * 256 * 3 * 80 * 80 / Math.pow(2, i),\n            memoryUsage: 256 * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: prevId,\n            target: fpnId\n        });\n        prevId = fpnId;\n    });\n    // Detection Heads\n    [\n        \"small\",\n        \"medium\",\n        \"large\"\n    ].forEach((size, i)=>{\n        const headId = \"head_\".concat(size);\n        nodes.push({\n            id: headId,\n            type: \"mlp\",\n            name: \"Detection Head (\".concat(size, \")\"),\n            params: 256 * (80 + 4 + 1),\n            flops: 256 * (80 + 4 + 1) * 80 * 80 / Math.pow(2, i),\n            memoryUsage: (80 + 4 + 1) * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: \"fpn_\".concat(fpnLayers[i]),\n            target: headId\n        });\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Stable Diffusion\nfunction generateStableDiffusionArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Add UNet Encoder blocks\n    for(let i = 0; i < 4; i++){\n        const encoderId = \"encoder_\".concat(i);\n        const attnId = \"encoder_attn_\".concat(i);\n        nodes.push({\n            id: encoderId,\n            type: \"residual\",\n            name: \"UNet Encoder \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Cross Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: encoderId\n        });\n        edges.push({\n            source: encoderId,\n            target: attnId\n        });\n        prevId = attnId;\n    }\n    // Add UNet Decoder blocks with skip connections\n    for(let i = 3; i >= 0; i--){\n        const decoderId = \"decoder_\".concat(i);\n        nodes.push({\n            id: decoderId,\n            type: \"residual\",\n            name: \"UNet Decoder \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: decoderId\n        });\n        edges.push({\n            source: \"encoder_attn_\".concat(i),\n            target: decoderId\n        }); // Skip connection\n        prevId = decoderId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Llama 2\nfunction generateLlama2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token Embedding\",\n        params: 32000 * 4096,\n        flops: 4096,\n        memoryUsage: 4 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // Transformer Blocks\n    for(let i = 0; i < 32; i++){\n        const attnId = \"attn_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId = \"norm_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 4 * 4096 * 4096,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 4096 * 11008,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"RMSNorm \".concat(i),\n            params: 4096,\n            flops: 4096,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 4096 * 32000,\n        flops: 4096 * 32000,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateDefaultArchitecture() {\n    return generateResNetArchitecture();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC1hcmNoaXRlY3R1cmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OFBBSU8sU0FBU0E7SUFDZCxNQUFNQyxRQUFRO1FBQ1o7WUFDRUMsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLE1BQU07WUFDTkMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLGFBQWEsT0FBTztRQUN0QjtLQUNEO0lBRUQsTUFBTUMsUUFBUSxFQUFFO0lBQ2hCLElBQUlDLFNBQVM7SUFFYixzQkFBc0I7SUFDdEJSLE1BQU1TLElBQUksQ0FBQztRQUNUUixJQUFJO1FBQ0pDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsYUFBYSxJQUFJLE9BQU87SUFDMUI7SUFDQUMsTUFBTUUsSUFBSSxDQUFDO1FBQUVDLFFBQVFGO1FBQVFHLFFBQVE7SUFBUTtJQUM3Q0gsU0FBUztJQUVULGdCQUFnQjtJQUNoQixNQUFNSSxTQUFTO1FBQUM7UUFBSztRQUFLO1FBQUs7S0FBSTtJQUNuQ0EsT0FBT0MsT0FBTyxDQUFDLENBQUNDLE9BQU9DO1FBQ3JCLHlDQUF5QztRQUN6QyxJQUFLLElBQUlDLE9BQU8sR0FBR0EsT0FBTyxHQUFHQSxPQUFRO1lBQ25DLE1BQU1DLFVBQVUsTUFBZUQsT0FBVEYsT0FBTSxLQUFRLE9BQUxFO1lBQy9CaEIsTUFBTVMsSUFBSSxDQUFDO2dCQUNUUixJQUFJZ0I7Z0JBQ0pmLE1BQU07Z0JBQ05DLE1BQU0sWUFBcUJhLE9BQVRGLE9BQU0sS0FBUSxPQUFMRTtnQkFDM0JaLFFBQVEsT0FBTyxPQUFRVyxDQUFBQSxJQUFJO2dCQUMzQlYsT0FBTyxJQUFJLE9BQU8sT0FBUVUsQ0FBQUEsSUFBSTtnQkFDOUJULGFBQWEsSUFBSSxPQUFPLE9BQVFTLENBQUFBLElBQUk7WUFDdEM7WUFDQVIsTUFBTUUsSUFBSSxDQUFDO2dCQUFFQyxRQUFRRjtnQkFBUUcsUUFBUU07WUFBUTtZQUM3Q1QsU0FBU1M7UUFDWDtJ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T1osUUFBUVU7UUFBTztRQUMzQ2IsU0FBU2E7SUFDWDtJQUVBckIsTUFBTVMsSUFBSSxDQUFDO1FBQ1RSLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFFBQVEsT0FBTztRQUNmQyxPQUFPLE9BQU87UUFDZEMsYUFBYSxJQUFJLE9BQU87SUFDMUI7SUFDQUMsTUFBTUUsSUFBSSxDQUFDO1FBQUVDLFFBQVFGO1FBQVFHLFFBQVE7SUFBUztJQUU5QyxPQUFPO1FBQUVYO1FBQU9PO0lBQU07QUFDeEI7QUFFTyxTQUFTK0I7SUFDZCxPQUFPdkM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9kZWwtYXJjaGl0ZWN0dXJlcy50cz84ZTBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBNb2RlbEFyY2hpdGVjdHVyZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gSW5pdGlhbCBjb252b2x1dGlvblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ2NvbnYxJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnQ29udjEnLFxuICAgIHBhcmFtczogOTQwOCxcbiAgICBmbG9wczogMTE4MDEzOTUyLFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnY29udjEnIH0pO1xuICBwcmV2SWQgPSAnY29udjEnO1xuXG4gIC8vIFJlc05ldCBibG9ja3NcbiAgY29uc3QgYmxvY2tzID0gWycyJywgJzMnLCAnNCcsICc1J107XG4gIGJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgIC8vIEVhY2ggYmxvY2sgaGFzIG11bHRpcGxlIHJlc2lkdWFsIHVuaXRzXG4gICAgZm9yIChsZXQgdW5pdCA9IDA7IHVuaXQgPCAzOyB1bml0KyspIHtcbiAgICAgIGNvbnN0IGJsb2NrSWQgPSBgcmVzJHtibG9ja31fJHt1bml0fWA7XG4gICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGJsb2NrSWQsXG4gICAgICAgIHR5cGU6ICdyZXNpZHVhbCcsXG4gICAgICAgIG5hbWU6IGBSZXNCbG9jayAke2Jsb2NrfS4ke3VuaXR9YCxcbiAgICAgICAgcGFyYW1zOiAxMDI0ICogMTAyNCAqIChpICsgMSksXG4gICAgICAgIGZsb3BzOiA1ICogMTAyNCAqIDEwMjQgKiAoaSArIDEpLFxuICAgICAgICBtZW1vcnlVc2FnZTogMyAqIDEwMjQgKiAxMDI0ICogKGkgKyAxKVxuICAgICAgfSk7XG4gICAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYmxvY2tJZCB9KTtcbiAgICAgIHByZXZJZCA9IGJsb2NrSWQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBGaW5hbCBsYXllcnNcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdwb29sJyxcbiAgICB0eXBlOiAnbWxwJyxcbiAgICBuYW1lOiAnR2xvYmFsIFBvb2wnLFxuICAgIHBhcmFtczogMjA0OCxcbiAgICBmbG9wczogMjA0OCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDUxMlxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwb29sJyB9KTtcblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0ZDIDEwMDAnLFxuICAgIHBhcmFtczogMjA0ODAwMCxcbiAgICBmbG9wczogMjA0ODAwMCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6ICdwb29sJywgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIEVuY29kZXIgbGF5ZXJzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgY29uc3QgYXR0ZW50aW9uSWQgPSBgZW5jX2F0dG5fJHtpfWA7XG4gICAgY29uc3QgZmZuSWQgPSBgZW5jX2Zmbl8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgZW5jX25vcm1fJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRlbnRpb25JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYEVuY29kZXIgU2VsZi1BdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogZmZuSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIEZGTiAke2l9YCxcbiAgICAgIHBhcmFtczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDMyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gJHtpfWAsXG4gICAgICBwYXJhbXM6IDEwMjQsXG4gICAgICBmbG9wczogMjA0OCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogNjRcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRlbnRpb25JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRlbnRpb25JZCwgdGFyZ2V0OiBmZm5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBmZm5JZCwgdGFyZ2V0OiBub3JtSWQgfSk7XG4gICAgcHJldklkID0gbm9ybUlkO1xuICB9XG5cbiAgLy8gT3V0cHV0IHByb2plY3Rpb25cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgUHJvamVjdGlvbicsXG4gICAgcGFyYW1zOiAxMDI0ICogMTAyNCxcbiAgICBmbG9wczogMiAqIDEwMjQgKiAxMDI0LFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFBhdGNoIGVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ3BhdGNoX2VtYmVkJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDU5MDU5MixcbiAgICBmbG9wczogNDcxODU5MjAsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwYXRjaF9lbWJlZCcgfSk7XG4gIHByZXZJZCA9ICdwYXRjaF9lbWJlZCc7XG5cbiAgLy8gVHJhbnNmb3JtZXIgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIGNvbnN0IGF0dGVudGlvbklkID0gYHRyYW5zZm9ybWVyXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dGVudGlvbklkLFxuICAgICAgdHlwZTogJ3RyYW5zZm9ybWVyJyxcbiAgICAgIG5hbWU6IGBUcmFuc2Zvcm1lciBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogNyAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDI4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTQgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbWxwSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBNTFAgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dGVudGlvbklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dGVudGlvbklkLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIHByZXZJZCA9IG1scElkO1xuICB9XG5cbiAgLy8gQ2xhc3NpZmljYXRpb24gaGVhZFxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0NsYXNzaWZpY2F0aW9uIEhlYWQnLFxuICAgIHBhcmFtczogNzY4MDAwLFxuICAgIGZsb3BzOiA3NjgwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiA3NjhcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IExheWVyJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0ICAvLyAxTUIgZm9yIGlucHV0IHRlbnNvclxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBCYWNrYm9uZTogQ1NQRGFya25ldFxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IGNvbnZJZCA9IGBjb252XyR7aX1gO1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGNvbnZJZCxcbiAgICAgIHR5cGU6ICdjbm4nLFxuICAgICAgbmFtZTogYENvbnYgQmxvY2sgJHtpICsgMX1gLFxuICAgICAgcGFyYW1zOiA2NCAqIE1hdGgucG93KDIsIGkpICogMyAqIDMsICAvLyBSZWFsaXN0aWMgcGFyYW1ldGVyIGNvdW50XG4gICAgICBmbG9wczogNjQgKiBNYXRoLnBvdygyLCBpKSAqIDMgKiAzICogNTEyICogNTEyIC8gTWF0aC5wb3coMiwgaSksXG4gICAgICBtZW1vcnlVc2FnZTogNTEyICogNTEyICogNjQgKiBNYXRoLnBvdygyLCBpKSAvIE1hdGgucG93KDIsIGkpICogNCAgLy8gNCBieXRlcyBwZXIgZmxvYXRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogY29udklkIH0pO1xuICAgIHByZXZJZCA9IGNvbnZJZDtcbiAgfVxuXG4gIC8vIEZlYXR1cmUgUHlyYW1pZCBOZXR3b3JrIChGUE4pXG4gIGNvbnN0IGZwbkxheWVycyA9IFsnUDUnLCAnUDQnLCAnUDMnXTtcbiAgZnBuTGF5ZXJzLmZvckVhY2goKGxheWVyLCBpKSA9PiB7XG4gICAgY29uc3QgZnBuSWQgPSBgZnBuXyR7bGF5ZXJ9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBmcG5JZCxcbiAgICAgIHR5cGU6ICdncmFwaCcsXG4gICAgICBuYW1lOiBgRlBOICR7bGF5ZXJ9YCxcbiAgICAgIHBhcmFtczogMjU2ICogMjU2ICogMyxcbiAgICAgIGZsb3BzOiAyNTYgKiAyNTYgKiAzICogODAgKiA4MCAvIE1hdGgucG93KDIsIGkpLFxuICAgICAgbWVtb3J5VXNhZ2U6IDI1NiAqIDgwICogODAgLyBNYXRoLnBvdygyLCBpKSAqIDRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogZnBuSWQgfSk7XG4gICAgcHJldklkID0gZnBuSWQ7XG4gIH0pO1xuXG4gIC8vIERldGVjdGlvbiBIZWFkc1xuICBbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddLmZvckVhY2goKHNpemUsIGkpID0+IHtcbiAgICBjb25zdCBoZWFkSWQgPSBgaGVhZF8ke3NpemV9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBoZWFkSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBEZXRlY3Rpb24gSGVhZCAoJHtzaXplfSlgLFxuICAgICAgcGFyYW1zOiAyNTYgKiAoODAgKyA0ICsgMSksICAvLyBjbGFzc2VzICsgYmJveCArIG9iamVjdG5lc3NcbiAgICAgIGZsb3BzOiAyNTYgKiAoODAgKyA0ICsgMSkgKiA4MCAqIDgwIC8gTWF0aC5wb3coMiwgaSksXG4gICAgICBtZW1vcnlVc2FnZTogKDgwICsgNCArIDEpICogODAgKiA4MCAvIE1hdGgucG93KDIsIGkpICogNFxuICAgIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGBmcG5fJHtmcG5MYXllcnNbaV19YCwgdGFyZ2V0OiBoZWFkSWQgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG4vLyBTdGFibGUgRGlmZnVzaW9uXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gQWRkIFVOZXQgRW5jb2RlciBibG9ja3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBlbmNvZGVySWQgPSBgZW5jb2Rlcl8ke2l9YDtcbiAgICBjb25zdCBhdHRuSWQgPSBgZW5jb2Rlcl9hdHRuXyR7aX1gO1xuICAgIFxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGVuY29kZXJJZCxcbiAgICAgIHR5cGU6ICdyZXNpZHVhbCcsXG4gICAgICBuYW1lOiBgVU5ldCBFbmNvZGVyICR7aX1gLFxuICAgICAgcGFyYW1zOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBmbG9wczogMzIgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxNiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBDcm9zcyBBdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGVuY29kZXJJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBlbmNvZGVySWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIHByZXZJZCA9IGF0dG5JZDtcbiAgfVxuXG4gIC8vIEFkZCBVTmV0IERlY29kZXIgYmxvY2tzIHdpdGggc2tpcCBjb25uZWN0aW9uc1xuICBmb3IgKGxldCBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBkZWNvZGVySWQgPSBgZGVjb2Rlcl8ke2l9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBkZWNvZGVySWQsXG4gICAgICB0eXBlOiAncmVzaWR1YWwnLFxuICAgICAgbmFtZTogYFVOZXQgRGVjb2RlciAke2l9YCxcbiAgICAgIHBhcmFtczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDMyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBkZWNvZGVySWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYGVuY29kZXJfYXR0bl8ke2l9YCwgdGFyZ2V0OiBkZWNvZGVySWQgfSk7IC8vIFNraXAgY29ubmVjdGlvblxuICAgIHByZXZJZCA9IGRlY29kZXJJZDtcbiAgfVxuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDEwMjQgKiAxMDI0LFxuICAgIGZsb3BzOiAyICogMTAyNCAqIDEwMjQsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbi8vIExsYW1hIDJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSgpOiBNb2RlbEFyY2hpdGVjdHVyZSB7XG4gIGNvbnN0IG5vZGVzID0gW1xuICAgIHtcbiAgICAgIGlkOiAnaW5wdXQnLFxuICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgIG5hbWU6ICdJbnB1dCBMYXllcicsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBUb2tlbiBFbWJlZGRpbmdcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdlbWJlZGRpbmcnLFxuICAgIHR5cGU6ICdlbWJlZGRpbmcnLFxuICAgIG5hbWU6ICdUb2tlbiBFbWJlZGRpbmcnLFxuICAgIHBhcmFtczogMzIwMDAgKiA0MDk2LFxuICAgIGZsb3BzOiA0MDk2LFxuICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnZW1iZWRkaW5nJyB9KTtcbiAgcHJldklkID0gJ2VtYmVkZGluZyc7XG5cbiAgLy8gVHJhbnNmb3JtZXIgQmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGNvbnN0IGF0dG5JZCA9IGBhdHRuXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgbm9ybV8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dG5JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYFNlbGYtQXR0ZW50aW9uICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogNDA5NiAqIDQwOTYsXG4gICAgICBmbG9wczogMTYgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA4ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG1scElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgTUxQIEJsb2NrICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogNDA5NiAqIDExMDA4LFxuICAgICAgZmxvcHM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZCxcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBSTVNOb3JtICR7aX1gLFxuICAgICAgcGFyYW1zOiA0MDk2LFxuICAgICAgZmxvcHM6IDQwOTYsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDY0XG4gICAgfSk7XG5cbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dG5JZCwgdGFyZ2V0OiBtbHBJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBtbHBJZCwgdGFyZ2V0OiBub3JtSWQgfSk7XG4gICAgcHJldklkID0gbm9ybUlkO1xuICB9XG5cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgTGF5ZXInLFxuICAgIHBhcmFtczogNDA5NiAqIDMyMDAwLFxuICAgIGZsb3BzOiA0MDk2ICogMzIwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEZWZhdWx0QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgcmV0dXJuIGdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlKCk7XG59Il0sIm5hbWVzIjpbImdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlIiwibm9kZXMiLCJpZCIsInR5cGUiLCJuYW1lIiwicGFyYW1zIiwiZmxvcHMiLCJtZW1vcnlVc2FnZSIsImVkZ2VzIiwicHJldklkIiwicHVzaCIsInNvdXJjZSIsInRhcmdldCIsImJsb2NrcyIsImZvckVhY2giLCJibG9jayIsImkiLCJ1bml0IiwiYmxvY2tJZCIsImdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUiLCJhdHRlbnRpb25JZCIsImZmbklkIiwibm9ybUlkIiwiZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUiLCJtbHBJZCIsImdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlIiwiY29udklkIiwiTWF0aCIsInBvdyIsImZwbkxheWVycyIsImxheWVyIiwiZnBuSWQiLCJzaXplIiwiaGVhZElkIiwiZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUiLCJlbmNvZGVySWQiLCJhdHRuSWQiLCJkZWNvZGVySWQiLCJnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlRGVmYXVsdEFyY2hpdGVjdHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model-architectures.ts\n"));

/***/ })

});