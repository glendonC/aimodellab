"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/performance.ts":
/*!**********************************!*\
  !*** ./lib/model/performance.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceCalculator: function() { return /* binding */ PerformanceCalculator; }\n/* harmony export */ });\n// Polars-like DataFrame implementation for browser\nclass DataFrame {\n    select(column) {\n        if (!this.data.length) {\n            return {\n                sum: ()=>0,\n                mean: ()=>0\n            };\n        }\n        return {\n            sum: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0),\n            mean: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0) / this.data.length\n        };\n    }\n    static fromRecords(records) {\n        return new DataFrame(records || []);\n    }\n    constructor(data){\n        this.data = data || []; // Ensure data is never undefined\n    }\n}\nclass PerformanceCalculator {\n    calculateWithPolars(analysisResult) {\n        const { metadata, layers = [] } = analysisResult.graph || {};\n        try {\n            const df = DataFrame.fromRecords(layers);\n            // Calculate base metrics\n            const totalFlops = df.select(\"flops\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) || 0;\n            const totalMemory = df.select(\"memory\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0;\n            const paramsPerLayer = df.select(\"parameters\").mean();\n            // Calculate CPU-specific base metrics\n            return {\n                fps: Math.min(60, 1000 / Math.max(1, totalFlops / 1e9)),\n                latency: Math.max(2.0, totalFlops / 1e9 * 3.5),\n                memory: Math.max(1.5, totalMemory / (1024 * 1024 * 1024)),\n                utilization: Math.min(95, Math.max(25, totalFlops / 1e9 * 0.8)),\n                efficiency: totalFlops / (df.select(\"parameters\").sum() || 1),\n                memoryEfficiency: totalMemory / (df.select(\"parameters\").sum() * 4 || 1)\n            };\n        } catch (e) {\n            console.warn(\"Calculations failed, falling back to simple calculations\", e);\n            return {\n                fps: Math.min(30, 1000 / Math.max(1, (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0)),\n                latency: Math.max(2.0, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0) * 3.5),\n                memory: Math.max(1.5, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0) / (1024 * 1024 * 1024)),\n                utilization: Math.min(95, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0) * 0.8),\n                efficiency: 0,\n                memoryEfficiency: 0\n            };\n        }\n    }\n    getModelCharacteristics(modelId, totalFlops, totalMemory) {\n        var _modelId_toLowerCase;\n        const id = (_modelId_toLowerCase = modelId === null || modelId === void 0 ? void 0 : modelId.toLowerCase()) !== null && _modelId_toLowerCase !== void 0 ? _modelId_toLowerCase : \"default\";\n        const flopsInTFlops = totalFlops / 1e12;\n        const memoryInGB = totalMemory / 1024 / 1024 / 1024;\n        // Base characteristics that scale with model size\n        const baseCharacteristics = {\n            minUtilization: Math.max(15, flopsInTFlops * 10),\n            tensorCoreUsage: Math.max(12, flopsInTFlops * 15),\n            memoryBandwidth: Math.max(0.3, flopsInTFlops * 0.5),\n            baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.cnn, memoryInGB * 1.2)\n        };\n        if (id.includes(\"yolo\")) {\n            return {\n                type: \"detection\",\n                batchSize: 16,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.detection, baseCharacteristics.minUtilization),\n                speedupFactor: 2.8,\n                memoryScale: 1.3,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.2,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.4,\n                features: [\n                    \"INT8 Quantization\",\n                    \"CUDA Graph Acceleration\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.detection, baseCharacteristics.baseMemory)\n            };\n        }\n        if (id.includes(\"stable\")) {\n            return {\n                type: \"generation\",\n                batchSize: 1,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.generation, baseCharacteristics.minUtilization),\n                speedupFactor: 2.2,\n                memoryScale: 1.5,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.5,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.8,\n                features: [\n                    \"FP16 Mixed Precision\",\n                    \"Attention Optimization\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.generation, baseCharacteristics.baseMemory)\n            };\n        }\n        // Default CNN characteristics with realistic minimums\n        return {\n            type: \"cnn\",\n            batchSize: 32,\n            baseUtilization: Math.max(this.GPU_SPECS.minUtilization.cnn, baseCharacteristics.minUtilization),\n            speedupFactor: 2.2,\n            memoryScale: 1.2,\n            tensorCoreUsage: baseCharacteristics.tensorCoreUsage,\n            memoryBandwidth: baseCharacteristics.memoryBandwidth,\n            features: [\n                \"TensorRT Inference\",\n                \"Kernel Fusion\"\n            ],\n            baseMemory: baseCharacteristics.baseMemory\n        };\n    }\n    calculateMetrics(analysisResult, gpuEnabled) {\n        var _metadata_modelId;\n        if (!(analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.graph)) {\n            return this.getDefaultMetrics();\n        }\n        const { layers = [], metadata } = analysisResult.graph;\n        const modelId = ((_metadata_modelId = metadata.modelId) === null || _metadata_modelId === void 0 ? void 0 : _metadata_modelId.toLowerCase()) || \"\";\n        // Base calculations from layer data\n        const totalFlops = layers.reduce((sum, layer)=>sum + layer.flops, 0);\n        const totalMemory = layers.reduce((sum, layer)=>sum + layer.memory, 0);\n        const totalParams = layers.reduce((sum, layer)=>sum + layer.parameters, 0);\n        // Get model-specific scaling factors\n        let complexityFactor = 1;\n        if (modelId.includes(\"transformer\") || modelId.includes(\"llama\")) {\n            complexityFactor = 2.5; // Transformers are more compute intensive\n        } else if (modelId.includes(\"stable\")) {\n            complexityFactor = 3; // Stable diffusion models are heaviest\n        } else if (modelId.includes(\"detection\")) {\n            complexityFactor = 1.8; // Detection models are moderately heavy\n        }\n        // CPU metrics scaled by model type\n        const cpuMetrics = {\n            fps: Math.min(60, 1000 / (Math.max(1, totalFlops / 1e9) * complexityFactor)),\n            latency: Math.max(1.0, totalFlops / 1e9 * complexityFactor),\n            memory: Math.max(1.0, totalMemory / (1024 * 1024 * 1024) * complexityFactor),\n            utilization: Math.min(95, totalFlops / 1e9 * complexityFactor)\n        };\n        if (!gpuEnabled) {\n            return {\n                cpuMetrics,\n                gpuMetrics: {\n                    fps: 0,\n                    latency: 0,\n                    memory: 0,\n                    utilization: 0\n                },\n                nvOptimizations: null\n            };\n        }\n        // GPU speedup varies by model architecture\n        const gpuSpeedup = modelId.includes(\"transformer\") ? 6 : modelId.includes(\"detection\") ? 8 : modelId.includes(\"stable\") ? 4 : 5;\n        // GPU metrics with architecture-specific optimizations\n        const gpuMetrics = {\n            fps: Math.min(240, cpuMetrics.fps * gpuSpeedup / complexityFactor),\n            latency: cpuMetrics.latency / (gpuSpeedup * 1.2),\n            memory: Math.max(2.0, totalMemory * 1.5 / (1024 * 1024 * 1024)),\n            utilization: Math.min(85, totalFlops / 1e12 * complexityFactor)\n        };\n        return {\n            cpuMetrics,\n            gpuMetrics,\n            nvOptimizations: {\n                tensorCoreUsage: \"\".concat(Math.min(95, totalFlops / 1e12 * complexityFactor * 100), \"%\"),\n                memoryBandwidth: \"\".concat(Math.min(2.4, totalMemory / 1e9 * complexityFactor).toFixed(1), \" TB/s\"),\n                speedup: \"\".concat(gpuSpeedup, \"x\"),\n                batchSize: 1\n            }\n        };\n    }\n    getDefaultMetrics() {\n        const defaultMetrics = {\n            fps: 0,\n            latency: 0,\n            memory: 0,\n            utilization: 0\n        };\n        return {\n            cpuMetrics: defaultMetrics,\n            gpuMetrics: defaultMetrics,\n            nvOptimizations: null\n        };\n    }\n    constructor(){\n        this.GPU_SPECS = {\n            peakTflops: 312,\n            memoryBandwidth: 2048,\n            tensorCores: 432,\n            maxBatchSize: 32,\n            // Minimum utilization for active models\n            minUtilization: {\n                cnn: 15,\n                transformer: 25,\n                detection: 20,\n                generation: 35 // Stable Diffusion etc\n            },\n            // Minimum memory requirements\n            minMemoryGB: {\n                cnn: 1.5,\n                transformer: 2.8,\n                detection: 2.2,\n                generation: 3.5 // Stable Diffusion etc\n            }\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBSUEsbURBQW1EO0FBQ25ELE1BQU1BO0lBT0pDLE9BQU9DLE1BQTBCLEVBQUU7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7WUFDckIsT0FBTztnQkFDTEMsS0FBSyxJQUFNO2dCQUNYQyxNQUFNLElBQU07WUFDZDtRQUNGO1FBRUEsT0FBTztZQUNMRCxLQUFLLElBQU0sSUFBSSxDQUFDRixJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJO1lBQ3BFSSxNQUFNLElBQU0sSUFBSSxDQUFDSCxJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU07UUFDNUY7SUFDRjtJQUVBLE9BQU9NLFlBQVlDLE9BQW1DLEVBQUU7UUFDdEQsT0FBTyxJQUFJWCxVQUFVVyxXQUFXLEVBQUU7SUFDcEM7SUFwQkFDLFlBQVlULElBQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLFFBQVEsRUFBRSxFQUFHLGlDQUFpQztJQUM1RDtBQW1CRjtBQUVPLE1BQU1VO0lBc0JIQyxvQkFBb0JDLGNBQThCLEVBQUU7UUFDMUQsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRSxFQUFFLEdBQUdGLGVBQWVHLEtBQUssSUFBSSxDQUFDO1FBRTNELElBQUk7WUFDRixNQUFNQyxLQUFLbkIsVUFBVVUsV0FBVyxDQUFDTztZQUVqQyx5QkFBeUI7WUFDekIsTUFBTUcsYUFBYUQsR0FBR2xCLE1BQU0sQ0FBQyxTQUFTSSxHQUFHLE9BQU1XLHFCQUFBQSwrQkFBQUEsU0FBVUksVUFBVSxLQUFJO1lBQ3ZFLE1BQU1DLGNBQWNGLEdBQUdsQixNQUFNLENBQUMsVUFBVUksR0FBRyxPQUFNVyxxQkFBQUEsK0JBQUFBLFNBQVVLLFdBQVcsS0FBSTtZQUMxRSxNQUFNQyxpQkFBaUJILEdBQUdsQixNQUFNLENBQUMsY0FBY0ssSUFBSTtZQUVuRCxzQ0FBc0M7WUFDdEMsT0FBTztnQkFDTGlCLEtBQUtDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLE9BQU9ELEtBQUtFLEdBQUcsQ0FBQyxHQUFHTixhQUFhO2dCQUNsRE8sU0FBU0gsS0FBS0UsR0FBRyxDQUFDLEtBQUssYUFBYyxNQUFPO2dCQUM1Q0UsUUFBUUosS0FBS0UsR0FBRyxDQUFDLEtBQUtMLGNBQWUsUUFBTyxPQUFPLElBQUc7Z0JBQ3REUSxhQUFhTCxLQUFLQyxHQUFHLENBQUMsSUFBSUQsS0FBS0UsR0FBRyxDQUFDLElBQUksYUFBYyxNQUFPO2dCQUM1REksWUFBWVYsYUFBY0QsQ0FBQUEsR0FBR2xCLE1BQU0sQ0FBQyxjQUFjSSxHQUFHLE1BQU07Z0JBQzNEMEIsa0JBQWtCVixjQUFlRixDQUFBQSxHQUFHbEIsTUFBTSxDQUFDLGNBQWNJLEdBQUcsS0FBSyxLQUFLO1lBQ3hFO1FBQ0YsRUFBRSxPQUFPMkIsR0FBRztZQUNWQyxRQUFRQyxJQUFJLENBQUMsNERBQTRERjtZQUN6RSxPQUFPO2dCQUNMVCxLQUFLQyxLQUFLQyxHQUFHLENBQUMsSUFBSSxPQUFPRCxLQUFLRSxHQUFHLENBQUMsR0FBR1YsQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVSSxVQUFVLElBQUcsT0FBTztnQkFDbkVPLFNBQVNILEtBQUtFLEdBQUcsQ0FBQyxLQUFLLENBQUNWLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVUksVUFBVSxJQUFHLE9BQU8sS0FBSztnQkFDM0RRLFFBQVFKLEtBQUtFLEdBQUcsQ0FBQyxLQUFLLENBQUNWLENBQUFBLHFCQUFBQSwrQkFBQUEsU0FBVUssV0FBVyxLQUFJLEtBQU0sUUFBTyxPQUFPLElBQUc7Z0JBQ3ZFUSxhQUFhTCxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDVCxDQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVVJLFVBQVUsSUFBRyxPQUFPLEtBQUs7Z0JBQzlEVSxZQUFZO2dCQUNaQyxrQkFBa0I7WUFDcEI7UUFDRjtJQUNGO0lBRVFJLHdCQUF3QkMsT0FBMkIsRUFBRWhCLFVBQWtCLEVBQUVDLFdBQW1CLEVBQUU7WUFDekZlO1FBQVgsTUFBTUMsS0FBS0QsQ0FBQUEsdUJBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0UsV0FBVyxnQkFBcEJGLGtDQUFBQSx1QkFBMEI7UUFDckMsTUFBTUcsZ0JBQWdCbkIsYUFBYTtRQUNuQyxNQUFNb0IsYUFBYW5CLGNBQWMsT0FBTyxPQUFPO1FBRS9DLGtEQUFrRDtRQUNsRCxNQUFNb0Isc0JBQXNCO1lBQzFCQyxnQkFBZ0JsQixLQUFLRSxHQUFHLENBQUMsSUFBSWEsZ0JBQWdCO1lBQzdDSSxpQkFBaUJuQixLQUFLRSxHQUFHLENBQUMsSUFBSWEsZ0JBQWdCO1lBQzlDSyxpQkFBaUJwQixLQUFLRSxHQUFHLENBQUMsS0FBS2EsZ0JBQWdCO1lBQy9DTSxZQUFZckIsS0FBS0UsR0FBRyxDQUFDLElBQUksQ0FBQ29CLFNBQVMsQ0FBQ0MsV0FBVyxDQUFDQyxHQUFHLEVBQUVSLGFBQWE7UUFDcEU7UUFFQSxJQUFJSCxHQUFHWSxRQUFRLENBQUMsU0FBUztZQUN2QixPQUFPO2dCQUNMQyxNQUFNO2dCQUNOQyxXQUFXO2dCQUNYQyxpQkFBaUI1QixLQUFLRSxHQUFHLENBQUMsSUFBSSxDQUFDb0IsU0FBUyxDQUFDSixjQUFjLENBQUNXLFNBQVMsRUFBRVosb0JBQW9CQyxjQUFjO2dCQUNyR1ksZUFBZTtnQkFDZkMsYUFBYTtnQkFDYlosaUJBQWlCRixvQkFBb0JFLGVBQWUsR0FBRztnQkFDdkRDLGlCQUFpQkgsb0JBQW9CRyxlQUFlLEdBQUc7Z0JBQ3ZEWSxVQUFVO29CQUFDO29CQUFxQjtpQkFBMEI7Z0JBQzFEWCxZQUFZckIsS0FBS0UsR0FBRyxDQUFDLElBQUksQ0FBQ29CLFNBQVMsQ0FBQ0MsV0FBVyxDQUFDTSxTQUFTLEVBQUVaLG9CQUFvQkksVUFBVTtZQUMzRjtRQUNGO1FBRUEsSUFBSVIsR0FBR1ksUUFBUSxDQUFDLFdBQVc7WUFDekIsT0FBTztnQkFDTEMsTUFBTTtnQkFDTkMsV0FBVztnQkFDWEMsaUJBQWlCNUIsS0FBS0UsR0FBRyxDQUFDLElBQUksQ0FBQ29CLFNBQVMsQ0FBQ0osY0FBYyxDQUFDZSxVQUFVLEVBQUVoQixvQkFBb0JDLGNBQWM7Z0JBQ3RHWSxlQUFlO2dCQUNmQyxhQUFhO2dCQUNiWixpQkFBaUJGLG9CQUFvQkUsZUFBZSxHQUFHO2dCQUN2REMsaUJBQWlCSCxvQkFBb0JHLGVBQWUsR0FBRztnQkFDdkRZLFVBQVU7b0JBQUM7b0JBQXdCO2lCQUF5QjtnQkFDNURYLFlBQVlyQixLQUFLRSxHQUFHLENBQUMsSUFBSSxDQUFDb0IsU0FBUyxDQUFDQyxXQUFXLENBQUNVLFVBQVUsRUFBRWhCLG9CQUFvQkksVUFBVTtZQUM1RjtRQUNGO1FBRUEsc0RBQXNEO1FBQ3RELE9BQU87WUFDTEssTUFBTTtZQUNOQyxXQUFXO1lBQ1hDLGlCQUFpQjVCLEtBQUtFLEdBQUcsQ0FBQyxJQUFJLENBQUNvQixTQUFTLENBQUNKLGNBQWMsQ0FBQ00sR0FBRyxFQUFFUCxvQkFBb0JDLGNBQWM7WUFDL0ZZLGVBQWU7WUFDZkMsYUFBYTtZQUNiWixpQkFBaUJGLG9CQUFvQkUsZUFBZTtZQUNwREMsaUJBQWlCSCxvQkFBb0JHLGVBQWU7WUFDcERZLFVBQVU7Z0JBQUM7Z0JBQXNCO2FBQWdCO1lBQ2pEWCxZQUFZSixvQkFBb0JJLFVBQVU7UUFDNUM7SUFDRjtJQUVBYSxpQkFBaUIzQyxjQUFxQyxFQUFFNEMsVUFBbUIsRUFBRTtZQU0zRDNDO1FBTGhCLElBQUksRUFBQ0QsMkJBQUFBLHFDQUFBQSxlQUFnQkcsS0FBSyxHQUFFO1lBQzFCLE9BQU8sSUFBSSxDQUFDMEMsaUJBQWlCO1FBQy9CO1FBRUEsTUFBTSxFQUFFM0MsU0FBUyxFQUFFLEVBQUVELFFBQVEsRUFBRSxHQUFHRCxlQUFlRyxLQUFLO1FBQ3RELE1BQU1rQixVQUFVcEIsRUFBQUEsb0JBQUFBLFNBQVNvQixPQUFPLGNBQWhCcEIsd0NBQUFBLGtCQUFrQnNCLFdBQVcsT0FBTTtRQUVuRCxvQ0FBb0M7UUFDcEMsTUFBTWxCLGFBQWFILE9BQU9WLE1BQU0sQ0FBQyxDQUFDRixLQUFLd0QsUUFBVXhELE1BQU13RCxNQUFNQyxLQUFLLEVBQUU7UUFDcEUsTUFBTXpDLGNBQWNKLE9BQU9WLE1BQU0sQ0FBQyxDQUFDRixLQUFLd0QsUUFBVXhELE1BQU13RCxNQUFNakMsTUFBTSxFQUFFO1FBQ3RFLE1BQU1tQyxjQUFjOUMsT0FBT1YsTUFBTSxDQUFDLENBQUNGLEtBQUt3RCxRQUFVeEQsTUFBTXdELE1BQU1HLFVBQVUsRUFBRTtRQUUxRSxxQ0FBcUM7UUFDckMsSUFBSUMsbUJBQW1CO1FBQ3ZCLElBQUk3QixRQUFRYSxRQUFRLENBQUMsa0JBQWtCYixRQUFRYSxRQUFRLENBQUMsVUFBVTtZQUNoRWdCLG1CQUFtQixLQUFLLDBDQUEwQztRQUNwRSxPQUFPLElBQUk3QixRQUFRYSxRQUFRLENBQUMsV0FBVztZQUNyQ2dCLG1CQUFtQixHQUFHLHVDQUF1QztRQUMvRCxPQUFPLElBQUk3QixRQUFRYSxRQUFRLENBQUMsY0FBYztZQUN4Q2dCLG1CQUFtQixLQUFLLHdDQUF3QztRQUNsRTtRQUVBLG1DQUFtQztRQUNuQyxNQUFNQyxhQUFhO1lBQ2pCM0MsS0FBS0MsS0FBS0MsR0FBRyxDQUFDLElBQUksT0FBUUQsQ0FBQUEsS0FBS0UsR0FBRyxDQUFDLEdBQUdOLGFBQWEsT0FBTzZDLGdCQUFlO1lBQ3pFdEMsU0FBU0gsS0FBS0UsR0FBRyxDQUFDLEtBQUssYUFBYyxNQUFPdUM7WUFDNUNyQyxRQUFRSixLQUFLRSxHQUFHLENBQUMsS0FBSyxjQUFnQixRQUFPLE9BQU8sSUFBRyxJQUFNdUM7WUFDN0RwQyxhQUFhTCxLQUFLQyxHQUFHLENBQUMsSUFBSSxhQUFjLE1BQU93QztRQUNqRDtRQUVBLElBQUksQ0FBQ04sWUFBWTtZQUNmLE9BQU87Z0JBQUVPO2dCQUFZQyxZQUFZO29CQUFFNUMsS0FBSztvQkFBR0ksU0FBUztvQkFBR0MsUUFBUTtvQkFBR0MsYUFBYTtnQkFBRTtnQkFBR3VDLGlCQUFpQjtZQUFLO1FBQzVHO1FBRUEsMkNBQTJDO1FBQzNDLE1BQU1DLGFBQWFqQyxRQUFRYSxRQUFRLENBQUMsaUJBQWlCLElBQ25DYixRQUFRYSxRQUFRLENBQUMsZUFBZSxJQUNoQ2IsUUFBUWEsUUFBUSxDQUFDLFlBQVksSUFBSTtRQUVuRCx1REFBdUQ7UUFDdkQsTUFBTWtCLGFBQWE7WUFDakI1QyxLQUFLQyxLQUFLQyxHQUFHLENBQUMsS0FBS3lDLFdBQVczQyxHQUFHLEdBQUc4QyxhQUFhSjtZQUNqRHRDLFNBQVN1QyxXQUFXdkMsT0FBTyxHQUFJMEMsQ0FBQUEsYUFBYSxHQUFFO1lBQzlDekMsUUFBUUosS0FBS0UsR0FBRyxDQUFDLEtBQUssY0FBZSxNQUFRLFFBQU8sT0FBTyxJQUFHO1lBQzlERyxhQUFhTCxLQUFLQyxHQUFHLENBQUMsSUFBSSxhQUFjLE9BQVF3QztRQUNsRDtRQUVBLE9BQU87WUFDTEM7WUFDQUM7WUFDQUMsaUJBQWlCO2dCQUNmekIsaUJBQWlCLEdBQThELE9BQTNEbkIsS0FBS0MsR0FBRyxDQUFDLElBQUksYUFBYyxPQUFRd0MsbUJBQW1CLE1BQUs7Z0JBQy9FckIsaUJBQWlCLEdBQW9FLE9BQWpFcEIsS0FBS0MsR0FBRyxDQUFDLEtBQUssY0FBZSxNQUFPd0Msa0JBQWtCSyxPQUFPLENBQUMsSUFBRztnQkFDckZDLFNBQVMsR0FBYyxPQUFYRixZQUFXO2dCQUN2QmxCLFdBQVc7WUFDYjtRQUNGO0lBQ0Y7SUFFUVMsb0JBQW9CO1FBQzFCLE1BQU1ZLGlCQUFpQjtZQUNyQmpELEtBQUs7WUFDTEksU0FBUztZQUNUQyxRQUFRO1lBQ1JDLGFBQWE7UUFDZjtRQUNBLE9BQU87WUFDTHFDLFlBQVlNO1lBQ1pMLFlBQVlLO1lBQ1pKLGlCQUFpQjtRQUNuQjtJQUNGOzthQXJMaUJ0QixZQUFZO1lBQzNCMkIsWUFBWTtZQUNaN0IsaUJBQWlCO1lBQ2pCOEIsYUFBYTtZQUNiQyxjQUFjO1lBQ2Qsd0NBQXdDO1lBQ3hDakMsZ0JBQWdCO2dCQUNkTSxLQUFLO2dCQUNMNEIsYUFBYTtnQkFDYnZCLFdBQVc7Z0JBQ1hJLFlBQVksR0FBSSx1QkFBdUI7WUFDekM7WUFDQSw4QkFBOEI7WUFDOUJWLGFBQWE7Z0JBQ1hDLEtBQUs7Z0JBQ0w0QixhQUFhO2dCQUNidkIsV0FBVztnQkFDWEksWUFBWSxJQUFJLHVCQUF1QjtZQUN6QztRQUNGOztBQW1LRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9kZWwvcGVyZm9ybWFuY2UudHM/ZGI1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwbCBmcm9tICdub2RlanMtcG9sYXJzJztcbmltcG9ydCB7IENQVV9CRU5DSE1BUktTLCBOVklESUFfQkVOQ0hNQVJLUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB0eXBlIHsgQW5hbHlzaXNSZXN1bHQsIExheWVyTWV0cmljcyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBQb2xhcnMtbGlrZSBEYXRhRnJhbWUgaW1wbGVtZW50YXRpb24gZm9yIGJyb3dzZXJcbmNsYXNzIERhdGFGcmFtZSB7XG4gIHByaXZhdGUgZGF0YTogTGF5ZXJNZXRyaWNzW107XG5cbiAgY29uc3RydWN0b3IoZGF0YTogTGF5ZXJNZXRyaWNzW10pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IFtdOyAgLy8gRW5zdXJlIGRhdGEgaXMgbmV2ZXIgdW5kZWZpbmVkXG4gIH1cblxuICBzZWxlY3QoY29sdW1uOiBrZXlvZiBMYXllck1ldHJpY3MpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1bTogKCkgPT4gMCxcbiAgICAgICAgbWVhbjogKCkgPT4gMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VtOiAoKSA9PiB0aGlzLmRhdGEucmVkdWNlKChhY2MsIHJvdykgPT4gYWNjICsgKHJvd1tjb2x1bW5dIHx8IDApLCAwKSxcbiAgICAgIG1lYW46ICgpID0+IHRoaXMuZGF0YS5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgKyAocm93W2NvbHVtbl0gfHwgMCksIDApIC8gdGhpcy5kYXRhLmxlbmd0aFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlY29yZHMocmVjb3JkczogTGF5ZXJNZXRyaWNzW10gfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IERhdGFGcmFtZShyZWNvcmRzIHx8IFtdKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VDYWxjdWxhdG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBHUFVfU1BFQ1MgPSB7XG4gICAgcGVha1RmbG9wczogMzEyLCAgICAgICAgICAvLyBBMTAwIEZQMTZcbiAgICBtZW1vcnlCYW5kd2lkdGg6IDIwNDgsICAgIC8vIEdCL3NcbiAgICB0ZW5zb3JDb3JlczogNDMyLFxuICAgIG1heEJhdGNoU2l6ZTogMzIsXG4gICAgLy8gTWluaW11bSB1dGlsaXphdGlvbiBmb3IgYWN0aXZlIG1vZGVsc1xuICAgIG1pblV0aWxpemF0aW9uOiB7XG4gICAgICBjbm46IDE1LCAgICAgICAgLy8gRWZmaWNpZW50IENOTnNcbiAgICAgIHRyYW5zZm9ybWVyOiAyNSwgLy8gVHJhbnNmb3JtZXIgbW9kZWxzXG4gICAgICBkZXRlY3Rpb246IDIwLCAgLy8gWU9MTyBldGNcbiAgICAgIGdlbmVyYXRpb246IDM1ICAvLyBTdGFibGUgRGlmZnVzaW9uIGV0Y1xuICAgIH0sXG4gICAgLy8gTWluaW11bSBtZW1vcnkgcmVxdWlyZW1lbnRzXG4gICAgbWluTWVtb3J5R0I6IHtcbiAgICAgIGNubjogMS41LCAgICAgICAvLyBCYXNpYyBDTk5zXG4gICAgICB0cmFuc2Zvcm1lcjogMi44LC8vIFRyYW5zZm9ybWVyIG1vZGVsc1xuICAgICAgZGV0ZWN0aW9uOiAyLjIsIC8vIFlPTE8gZXRjXG4gICAgICBnZW5lcmF0aW9uOiAzLjUgLy8gU3RhYmxlIERpZmZ1c2lvbiBldGNcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVXaXRoUG9sYXJzKGFuYWx5c2lzUmVzdWx0OiBBbmFseXNpc1Jlc3VsdCkge1xuICAgIGNvbnN0IHsgbWV0YWRhdGEsIGxheWVycyA9IFtdIH0gPSBhbmFseXNpc1Jlc3VsdC5ncmFwaCB8fCB7fTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGYgPSBEYXRhRnJhbWUuZnJvbVJlY29yZHMobGF5ZXJzKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGJhc2UgbWV0cmljc1xuICAgICAgY29uc3QgdG90YWxGbG9wcyA9IGRmLnNlbGVjdCgnZmxvcHMnKS5zdW0oKSB8fCBtZXRhZGF0YT8udG90YWxGbG9wcyB8fCAwO1xuICAgICAgY29uc3QgdG90YWxNZW1vcnkgPSBkZi5zZWxlY3QoJ21lbW9yeScpLnN1bSgpIHx8IG1ldGFkYXRhPy50b3RhbE1lbW9yeSB8fCAwO1xuICAgICAgY29uc3QgcGFyYW1zUGVyTGF5ZXIgPSBkZi5zZWxlY3QoJ3BhcmFtZXRlcnMnKS5tZWFuKCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBDUFUtc3BlY2lmaWMgYmFzZSBtZXRyaWNzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcHM6IE1hdGgubWluKDYwLCAxMDAwIC8gTWF0aC5tYXgoMSwgdG90YWxGbG9wcyAvIDFlOSkpLCAgLy8gQ2FwIENQVSBhdCA2MCBGUFNcbiAgICAgICAgbGF0ZW5jeTogTWF0aC5tYXgoMi4wLCAodG90YWxGbG9wcyAvIDFlOSkgKiAzLjUpLCAgICAgICAgIC8vIENQVSBoYXMgaGlnaGVyIGJhc2UgbGF0ZW5jeVxuICAgICAgICBtZW1vcnk6IE1hdGgubWF4KDEuNSwgdG90YWxNZW1vcnkgLyAoMTAyNCAqIDEwMjQgKiAxMDI0KSksIC8vIENQVSBuZWVkcyBtb3JlIG1lbW9yeVxuICAgICAgICB1dGlsaXphdGlvbjogTWF0aC5taW4oOTUsIE1hdGgubWF4KDI1LCAodG90YWxGbG9wcyAvIDFlOSkgKiAwLjgpKSwgLy8gQ1BVIHV0aWxpemF0aW9uIGlzIGhpZ2hlclxuICAgICAgICBlZmZpY2llbmN5OiB0b3RhbEZsb3BzIC8gKGRmLnNlbGVjdCgncGFyYW1ldGVycycpLnN1bSgpIHx8IDEpLFxuICAgICAgICBtZW1vcnlFZmZpY2llbmN5OiB0b3RhbE1lbW9yeSAvIChkZi5zZWxlY3QoJ3BhcmFtZXRlcnMnKS5zdW0oKSAqIDQgfHwgMSlcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKCdDYWxjdWxhdGlvbnMgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gc2ltcGxlIGNhbGN1bGF0aW9ucycsIGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnBzOiBNYXRoLm1pbigzMCwgMTAwMCAvIE1hdGgubWF4KDEsIG1ldGFkYXRhPy50b3RhbEZsb3BzIC8gMWU5IHx8IDApKSxcbiAgICAgICAgbGF0ZW5jeTogTWF0aC5tYXgoMi4wLCAobWV0YWRhdGE/LnRvdGFsRmxvcHMgLyAxZTkgfHwgMCkgKiAzLjUpLFxuICAgICAgICBtZW1vcnk6IE1hdGgubWF4KDEuNSwgKG1ldGFkYXRhPy50b3RhbE1lbW9yeSB8fCAwKSAvICgxMDI0ICogMTAyNCAqIDEwMjQpKSxcbiAgICAgICAgdXRpbGl6YXRpb246IE1hdGgubWluKDk1LCAobWV0YWRhdGE/LnRvdGFsRmxvcHMgLyAxZTkgfHwgMCkgKiAwLjgpLFxuICAgICAgICBlZmZpY2llbmN5OiAwLFxuICAgICAgICBtZW1vcnlFZmZpY2llbmN5OiAwXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0TW9kZWxDaGFyYWN0ZXJpc3RpY3MobW9kZWxJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCB0b3RhbEZsb3BzOiBudW1iZXIsIHRvdGFsTWVtb3J5OiBudW1iZXIpIHtcbiAgICBjb25zdCBpZCA9IG1vZGVsSWQ/LnRvTG93ZXJDYXNlKCkgPz8gJ2RlZmF1bHQnO1xuICAgIGNvbnN0IGZsb3BzSW5URmxvcHMgPSB0b3RhbEZsb3BzIC8gMWUxMjtcbiAgICBjb25zdCBtZW1vcnlJbkdCID0gdG90YWxNZW1vcnkgLyAxMDI0IC8gMTAyNCAvIDEwMjQ7XG5cbiAgICAvLyBCYXNlIGNoYXJhY3RlcmlzdGljcyB0aGF0IHNjYWxlIHdpdGggbW9kZWwgc2l6ZVxuICAgIGNvbnN0IGJhc2VDaGFyYWN0ZXJpc3RpY3MgPSB7XG4gICAgICBtaW5VdGlsaXphdGlvbjogTWF0aC5tYXgoMTUsIGZsb3BzSW5URmxvcHMgKiAxMCksXG4gICAgICB0ZW5zb3JDb3JlVXNhZ2U6IE1hdGgubWF4KDEyLCBmbG9wc0luVEZsb3BzICogMTUpLFxuICAgICAgbWVtb3J5QmFuZHdpZHRoOiBNYXRoLm1heCgwLjMsIGZsb3BzSW5URmxvcHMgKiAwLjUpLFxuICAgICAgYmFzZU1lbW9yeTogTWF0aC5tYXgodGhpcy5HUFVfU1BFQ1MubWluTWVtb3J5R0IuY25uLCBtZW1vcnlJbkdCICogMS4yKVxuICAgIH07XG5cbiAgICBpZiAoaWQuaW5jbHVkZXMoJ3lvbG8nKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2RldGVjdGlvbicsXG4gICAgICAgIGJhdGNoU2l6ZTogMTYsXG4gICAgICAgIGJhc2VVdGlsaXphdGlvbjogTWF0aC5tYXgodGhpcy5HUFVfU1BFQ1MubWluVXRpbGl6YXRpb24uZGV0ZWN0aW9uLCBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1pblV0aWxpemF0aW9uKSxcbiAgICAgICAgc3BlZWR1cEZhY3RvcjogMi44LFxuICAgICAgICBtZW1vcnlTY2FsZTogMS4zLFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGJhc2VDaGFyYWN0ZXJpc3RpY3MudGVuc29yQ29yZVVzYWdlICogMS4yLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6IGJhc2VDaGFyYWN0ZXJpc3RpY3MubWVtb3J5QmFuZHdpZHRoICogMS40LFxuICAgICAgICBmZWF0dXJlczogWydJTlQ4IFF1YW50aXphdGlvbicsICdDVURBIEdyYXBoIEFjY2VsZXJhdGlvbiddLFxuICAgICAgICBiYXNlTWVtb3J5OiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5NZW1vcnlHQi5kZXRlY3Rpb24sIGJhc2VDaGFyYWN0ZXJpc3RpY3MuYmFzZU1lbW9yeSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlkLmluY2x1ZGVzKCdzdGFibGUnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2dlbmVyYXRpb24nLFxuICAgICAgICBiYXRjaFNpemU6IDEsXG4gICAgICAgIGJhc2VVdGlsaXphdGlvbjogTWF0aC5tYXgodGhpcy5HUFVfU1BFQ1MubWluVXRpbGl6YXRpb24uZ2VuZXJhdGlvbiwgYmFzZUNoYXJhY3RlcmlzdGljcy5taW5VdGlsaXphdGlvbiksXG4gICAgICAgIHNwZWVkdXBGYWN0b3I6IDIuMixcbiAgICAgICAgbWVtb3J5U2NhbGU6IDEuNSxcbiAgICAgICAgdGVuc29yQ29yZVVzYWdlOiBiYXNlQ2hhcmFjdGVyaXN0aWNzLnRlbnNvckNvcmVVc2FnZSAqIDEuNSxcbiAgICAgICAgbWVtb3J5QmFuZHdpZHRoOiBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1lbW9yeUJhbmR3aWR0aCAqIDEuOCxcbiAgICAgICAgZmVhdHVyZXM6IFsnRlAxNiBNaXhlZCBQcmVjaXNpb24nLCAnQXR0ZW50aW9uIE9wdGltaXphdGlvbiddLFxuICAgICAgICBiYXNlTWVtb3J5OiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5NZW1vcnlHQi5nZW5lcmF0aW9uLCBiYXNlQ2hhcmFjdGVyaXN0aWNzLmJhc2VNZW1vcnkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgQ05OIGNoYXJhY3RlcmlzdGljcyB3aXRoIHJlYWxpc3RpYyBtaW5pbXVtc1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnY25uJyxcbiAgICAgIGJhdGNoU2l6ZTogMzIsXG4gICAgICBiYXNlVXRpbGl6YXRpb246IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pblV0aWxpemF0aW9uLmNubiwgYmFzZUNoYXJhY3RlcmlzdGljcy5taW5VdGlsaXphdGlvbiksXG4gICAgICBzcGVlZHVwRmFjdG9yOiAyLjIsXG4gICAgICBtZW1vcnlTY2FsZTogMS4yLFxuICAgICAgdGVuc29yQ29yZVVzYWdlOiBiYXNlQ2hhcmFjdGVyaXN0aWNzLnRlbnNvckNvcmVVc2FnZSxcbiAgICAgIG1lbW9yeUJhbmR3aWR0aDogYmFzZUNoYXJhY3RlcmlzdGljcy5tZW1vcnlCYW5kd2lkdGgsXG4gICAgICBmZWF0dXJlczogWydUZW5zb3JSVCBJbmZlcmVuY2UnLCAnS2VybmVsIEZ1c2lvbiddLFxuICAgICAgYmFzZU1lbW9yeTogYmFzZUNoYXJhY3RlcmlzdGljcy5iYXNlTWVtb3J5XG4gICAgfTtcbiAgfVxuXG4gIGNhbGN1bGF0ZU1ldHJpY3MoYW5hbHlzaXNSZXN1bHQ6IEFuYWx5c2lzUmVzdWx0IHwgbnVsbCwgZ3B1RW5hYmxlZDogYm9vbGVhbikge1xuICAgIGlmICghYW5hbHlzaXNSZXN1bHQ/LmdyYXBoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0TWV0cmljcygpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbGF5ZXJzID0gW10sIG1ldGFkYXRhIH0gPSBhbmFseXNpc1Jlc3VsdC5ncmFwaDtcbiAgICBjb25zdCBtb2RlbElkID0gbWV0YWRhdGEubW9kZWxJZD8udG9Mb3dlckNhc2UoKSB8fCAnJztcbiAgICBcbiAgICAvLyBCYXNlIGNhbGN1bGF0aW9ucyBmcm9tIGxheWVyIGRhdGFcbiAgICBjb25zdCB0b3RhbEZsb3BzID0gbGF5ZXJzLnJlZHVjZSgoc3VtLCBsYXllcikgPT4gc3VtICsgbGF5ZXIuZmxvcHMsIDApO1xuICAgIGNvbnN0IHRvdGFsTWVtb3J5ID0gbGF5ZXJzLnJlZHVjZSgoc3VtLCBsYXllcikgPT4gc3VtICsgbGF5ZXIubWVtb3J5LCAwKTtcbiAgICBjb25zdCB0b3RhbFBhcmFtcyA9IGxheWVycy5yZWR1Y2UoKHN1bSwgbGF5ZXIpID0+IHN1bSArIGxheWVyLnBhcmFtZXRlcnMsIDApO1xuXG4gICAgLy8gR2V0IG1vZGVsLXNwZWNpZmljIHNjYWxpbmcgZmFjdG9yc1xuICAgIGxldCBjb21wbGV4aXR5RmFjdG9yID0gMTtcbiAgICBpZiAobW9kZWxJZC5pbmNsdWRlcygndHJhbnNmb3JtZXInKSB8fCBtb2RlbElkLmluY2x1ZGVzKCdsbGFtYScpKSB7XG4gICAgICBjb21wbGV4aXR5RmFjdG9yID0gMi41OyAvLyBUcmFuc2Zvcm1lcnMgYXJlIG1vcmUgY29tcHV0ZSBpbnRlbnNpdmVcbiAgICB9IGVsc2UgaWYgKG1vZGVsSWQuaW5jbHVkZXMoJ3N0YWJsZScpKSB7XG4gICAgICBjb21wbGV4aXR5RmFjdG9yID0gMzsgLy8gU3RhYmxlIGRpZmZ1c2lvbiBtb2RlbHMgYXJlIGhlYXZpZXN0XG4gICAgfSBlbHNlIGlmIChtb2RlbElkLmluY2x1ZGVzKCdkZXRlY3Rpb24nKSkge1xuICAgICAgY29tcGxleGl0eUZhY3RvciA9IDEuODsgLy8gRGV0ZWN0aW9uIG1vZGVscyBhcmUgbW9kZXJhdGVseSBoZWF2eVxuICAgIH1cblxuICAgIC8vIENQVSBtZXRyaWNzIHNjYWxlZCBieSBtb2RlbCB0eXBlXG4gICAgY29uc3QgY3B1TWV0cmljcyA9IHtcbiAgICAgIGZwczogTWF0aC5taW4oNjAsIDEwMDAgLyAoTWF0aC5tYXgoMSwgdG90YWxGbG9wcyAvIDFlOSkgKiBjb21wbGV4aXR5RmFjdG9yKSksXG4gICAgICBsYXRlbmN5OiBNYXRoLm1heCgxLjAsICh0b3RhbEZsb3BzIC8gMWU5KSAqIGNvbXBsZXhpdHlGYWN0b3IpLFxuICAgICAgbWVtb3J5OiBNYXRoLm1heCgxLjAsICh0b3RhbE1lbW9yeSAvICgxMDI0ICogMTAyNCAqIDEwMjQpKSAqIGNvbXBsZXhpdHlGYWN0b3IpLFxuICAgICAgdXRpbGl6YXRpb246IE1hdGgubWluKDk1LCAodG90YWxGbG9wcyAvIDFlOSkgKiBjb21wbGV4aXR5RmFjdG9yKVxuICAgIH07XG5cbiAgICBpZiAoIWdwdUVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7IGNwdU1ldHJpY3MsIGdwdU1ldHJpY3M6IHsgZnBzOiAwLCBsYXRlbmN5OiAwLCBtZW1vcnk6IDAsIHV0aWxpemF0aW9uOiAwIH0sIG52T3B0aW1pemF0aW9uczogbnVsbCB9O1xuICAgIH1cblxuICAgIC8vIEdQVSBzcGVlZHVwIHZhcmllcyBieSBtb2RlbCBhcmNoaXRlY3R1cmVcbiAgICBjb25zdCBncHVTcGVlZHVwID0gbW9kZWxJZC5pbmNsdWRlcygndHJhbnNmb3JtZXInKSA/IDYgOlxuICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSWQuaW5jbHVkZXMoJ2RldGVjdGlvbicpID8gOCA6XG4gICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZC5pbmNsdWRlcygnc3RhYmxlJykgPyA0IDogNTtcblxuICAgIC8vIEdQVSBtZXRyaWNzIHdpdGggYXJjaGl0ZWN0dXJlLXNwZWNpZmljIG9wdGltaXphdGlvbnNcbiAgICBjb25zdCBncHVNZXRyaWNzID0ge1xuICAgICAgZnBzOiBNYXRoLm1pbigyNDAsIGNwdU1ldHJpY3MuZnBzICogZ3B1U3BlZWR1cCAvIGNvbXBsZXhpdHlGYWN0b3IpLFxuICAgICAgbGF0ZW5jeTogY3B1TWV0cmljcy5sYXRlbmN5IC8gKGdwdVNwZWVkdXAgKiAxLjIpLCAvLyBFeHRyYSBvcHRpbWl6YXRpb24gZmFjdG9yXG4gICAgICBtZW1vcnk6IE1hdGgubWF4KDIuMCwgKHRvdGFsTWVtb3J5ICogMS41KSAvICgxMDI0ICogMTAyNCAqIDEwMjQpKSwgLy8gR1BVcyBuZWVkIG1vcmUgbWVtb3J5XG4gICAgICB1dGlsaXphdGlvbjogTWF0aC5taW4oODUsICh0b3RhbEZsb3BzIC8gMWUxMikgKiBjb21wbGV4aXR5RmFjdG9yKVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3B1TWV0cmljcyxcbiAgICAgIGdwdU1ldHJpY3MsXG4gICAgICBudk9wdGltaXphdGlvbnM6IHtcbiAgICAgICAgdGVuc29yQ29yZVVzYWdlOiBgJHtNYXRoLm1pbig5NSwgKHRvdGFsRmxvcHMgLyAxZTEyKSAqIGNvbXBsZXhpdHlGYWN0b3IgKiAxMDApfSVgLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6IGAke01hdGgubWluKDIuNCwgKHRvdGFsTWVtb3J5IC8gMWU5KSAqIGNvbXBsZXhpdHlGYWN0b3IpLnRvRml4ZWQoMSl9IFRCL3NgLFxuICAgICAgICBzcGVlZHVwOiBgJHtncHVTcGVlZHVwfXhgLFxuICAgICAgICBiYXRjaFNpemU6IDFcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREZWZhdWx0TWV0cmljcygpIHtcbiAgICBjb25zdCBkZWZhdWx0TWV0cmljcyA9IHtcbiAgICAgIGZwczogMCxcbiAgICAgIGxhdGVuY3k6IDAsXG4gICAgICBtZW1vcnk6IDAsXG4gICAgICB1dGlsaXphdGlvbjogMFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNwdU1ldHJpY3M6IGRlZmF1bHRNZXRyaWNzLFxuICAgICAgZ3B1TWV0cmljczogZGVmYXVsdE1ldHJpY3MsXG4gICAgICBudk9wdGltaXphdGlvbnM6IG51bGxcbiAgICB9O1xuICB9XG59ICJdLCJuYW1lcyI6WyJEYXRhRnJhbWUiLCJzZWxlY3QiLCJjb2x1bW4iLCJkYXRhIiwibGVuZ3RoIiwic3VtIiwibWVhbiIsInJlZHVjZSIsImFjYyIsInJvdyIsImZyb21SZWNvcmRzIiwicmVjb3JkcyIsImNvbnN0cnVjdG9yIiwiUGVyZm9ybWFuY2VDYWxjdWxhdG9yIiwiY2FsY3VsYXRlV2l0aFBvbGFycyIsImFuYWx5c2lzUmVzdWx0IiwibWV0YWRhdGEiLCJsYXllcnMiLCJncmFwaCIsImRmIiwidG90YWxGbG9wcyIsInRvdGFsTWVtb3J5IiwicGFyYW1zUGVyTGF5ZXIiLCJmcHMiLCJNYXRoIiwibWluIiwibWF4IiwibGF0ZW5jeSIsIm1lbW9yeSIsInV0aWxpemF0aW9uIiwiZWZmaWNpZW5jeSIsIm1lbW9yeUVmZmljaWVuY3kiLCJlIiwiY29uc29sZSIsIndhcm4iLCJnZXRNb2RlbENoYXJhY3RlcmlzdGljcyIsIm1vZGVsSWQiLCJpZCIsInRvTG93ZXJDYXNlIiwiZmxvcHNJblRGbG9wcyIsIm1lbW9yeUluR0IiLCJiYXNlQ2hhcmFjdGVyaXN0aWNzIiwibWluVXRpbGl6YXRpb24iLCJ0ZW5zb3JDb3JlVXNhZ2UiLCJtZW1vcnlCYW5kd2lkdGgiLCJiYXNlTWVtb3J5IiwiR1BVX1NQRUNTIiwibWluTWVtb3J5R0IiLCJjbm4iLCJpbmNsdWRlcyIsInR5cGUiLCJiYXRjaFNpemUiLCJiYXNlVXRpbGl6YXRpb24iLCJkZXRlY3Rpb24iLCJzcGVlZHVwRmFjdG9yIiwibWVtb3J5U2NhbGUiLCJmZWF0dXJlcyIsImdlbmVyYXRpb24iLCJjYWxjdWxhdGVNZXRyaWNzIiwiZ3B1RW5hYmxlZCIsImdldERlZmF1bHRNZXRyaWNzIiwibGF5ZXIiLCJmbG9wcyIsInRvdGFsUGFyYW1zIiwicGFyYW1ldGVycyIsImNvbXBsZXhpdHlGYWN0b3IiLCJjcHVNZXRyaWNzIiwiZ3B1TWV0cmljcyIsIm52T3B0aW1pemF0aW9ucyIsImdwdVNwZWVkdXAiLCJ0b0ZpeGVkIiwic3BlZWR1cCIsImRlZmF1bHRNZXRyaWNzIiwicGVha1RmbG9wcyIsInRlbnNvckNvcmVzIiwibWF4QmF0Y2hTaXplIiwidHJhbnNmb3JtZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/performance.ts\n"));

/***/ })

});