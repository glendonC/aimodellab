"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/performance.ts":
/*!**********************************!*\
  !*** ./lib/model/performance.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceCalculator: function() { return /* binding */ PerformanceCalculator; }\n/* harmony export */ });\n// Polars-like DataFrame implementation for browser\nclass DataFrame {\n    select(column) {\n        if (!this.data.length) {\n            return {\n                sum: ()=>0,\n                mean: ()=>0\n            };\n        }\n        return {\n            sum: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0),\n            mean: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0) / this.data.length\n        };\n    }\n    static fromRecords(records) {\n        return new DataFrame(records || []);\n    }\n    constructor(data){\n        this.data = data || []; // Ensure data is never undefined\n    }\n}\nclass PerformanceCalculator {\n    calculateWithPolars(analysisResult) {\n        const { metadata, layers = [] } = analysisResult.graph || {};\n        try {\n            const df = DataFrame.fromRecords(layers);\n            // Calculate base metrics\n            const totalFlops = df.select(\"flops\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) || 0;\n            const totalMemory = df.select(\"memory\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0;\n            const paramsPerLayer = df.select(\"parameters\").mean();\n            // Calculate CPU-specific base metrics\n            return {\n                fps: Math.min(60, 1000 / Math.max(1, totalFlops / 1e9)),\n                latency: Math.max(2.0, totalFlops / 1e9 * 3.5),\n                memory: Math.max(1.5, totalMemory / (1024 * 1024 * 1024)),\n                utilization: Math.min(95, Math.max(25, totalFlops / 1e9 * 0.8)),\n                efficiency: totalFlops / (df.select(\"parameters\").sum() || 1),\n                memoryEfficiency: totalMemory / (df.select(\"parameters\").sum() * 4 || 1)\n            };\n        } catch (e) {\n            console.warn(\"Calculations failed, falling back to simple calculations\", e);\n            return {\n                fps: Math.min(30, 1000 / Math.max(1, (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0)),\n                latency: Math.max(2.0, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0) * 3.5),\n                memory: Math.max(1.5, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0) / (1024 * 1024 * 1024)),\n                utilization: Math.min(95, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0) * 0.8),\n                efficiency: 0,\n                memoryEfficiency: 0\n            };\n        }\n    }\n    getModelCharacteristics(modelId, totalFlops, totalMemory) {\n        var _modelId_toLowerCase;\n        const id = (_modelId_toLowerCase = modelId === null || modelId === void 0 ? void 0 : modelId.toLowerCase()) !== null && _modelId_toLowerCase !== void 0 ? _modelId_toLowerCase : \"default\";\n        const flopsInTFlops = totalFlops / 1e12;\n        const memoryInGB = totalMemory / 1024 / 1024 / 1024;\n        // Base characteristics that scale with model size\n        const baseCharacteristics = {\n            minUtilization: Math.max(15, flopsInTFlops * 10),\n            tensorCoreUsage: Math.max(12, flopsInTFlops * 15),\n            memoryBandwidth: Math.max(0.3, flopsInTFlops * 0.5),\n            baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.cnn, memoryInGB * 1.2)\n        };\n        if (id.includes(\"yolo\")) {\n            return {\n                type: \"detection\",\n                batchSize: 16,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.detection, baseCharacteristics.minUtilization),\n                speedupFactor: 2.8,\n                memoryScale: 1.3,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.2,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.4,\n                features: [\n                    \"INT8 Quantization\",\n                    \"CUDA Graph Acceleration\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.detection, baseCharacteristics.baseMemory)\n            };\n        }\n        if (id.includes(\"stable\")) {\n            return {\n                type: \"generation\",\n                batchSize: 1,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.generation, baseCharacteristics.minUtilization),\n                speedupFactor: 2.2,\n                memoryScale: 1.5,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.5,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.8,\n                features: [\n                    \"FP16 Mixed Precision\",\n                    \"Attention Optimization\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.generation, baseCharacteristics.baseMemory)\n            };\n        }\n        // Default CNN characteristics with realistic minimums\n        return {\n            type: \"cnn\",\n            batchSize: 32,\n            baseUtilization: Math.max(this.GPU_SPECS.minUtilization.cnn, baseCharacteristics.minUtilization),\n            speedupFactor: 2.2,\n            memoryScale: 1.2,\n            tensorCoreUsage: baseCharacteristics.tensorCoreUsage,\n            memoryBandwidth: baseCharacteristics.memoryBandwidth,\n            features: [\n                \"TensorRT Inference\",\n                \"Kernel Fusion\"\n            ],\n            baseMemory: baseCharacteristics.baseMemory\n        };\n    }\n    calculateMetrics(analysisResult, gpuEnabled) {\n        if (!(analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.graph)) {\n            return this.getDefaultMetrics();\n        }\n        const baseMetrics = this.calculateWithPolars(analysisResult);\n        const { totalFlops = 0, totalMemory = 0, modelId } = analysisResult.graph.metadata;\n        const modelCharacteristics = this.getModelCharacteristics(modelId, totalFlops, totalMemory);\n        // Get baseline benchmarks\n        const cpuBaseline = CPU_BENCHMARKS[\"xeon-8380\"].resnet50.batchSize1;\n        const gpuBaseline = NVIDIA_BENCHMARKS.resnet50.a100.batchSize1;\n        // Calculate relative performance based on real benchmarks\n        const cpuMetrics = {\n            fps: Math.min(cpuBaseline.fps, baseMetrics.fps),\n            latency: Math.max(cpuBaseline.latency, baseMetrics.latency),\n            memory: Math.max(cpuBaseline.memory / 1024, baseMetrics.memory),\n            utilization: gpuEnabled ? Math.min(40, baseMetrics.utilization * 0.5) : baseMetrics.utilization\n        };\n        // GPU metrics based on real A100 benchmarks\n        const gpuMetrics = {\n            fps: gpuEnabled ? Math.min(gpuBaseline.fps, cpuMetrics.fps * modelCharacteristics.speedupFactor) : Math.min(gpuBaseline.fps / 2, cpuMetrics.fps * 1.2),\n            latency: gpuEnabled ? Math.max(gpuBaseline.latency, cpuMetrics.latency / modelCharacteristics.speedupFactor) : gpuBaseline.latency * 2,\n            memory: gpuEnabled ? Math.max(gpuBaseline.memory / 1024, baseMetrics.memory * 0.7) : gpuBaseline.memory / 1024,\n            utilization: gpuEnabled ? Math.max(modelCharacteristics.baseUtilization, Math.min(85, baseMetrics.utilization * 0.4)) : 0\n        };\n        const nvOptimizations = gpuEnabled ? {\n            tensorCoreUsage: \"\".concat(modelCharacteristics.tensorCoreUsage.toFixed(1), \"%\"),\n            memoryBandwidth: \"\".concat(modelCharacteristics.memoryBandwidth.toFixed(1), \" TB/s\"),\n            speedup: \"\".concat((gpuMetrics.fps / cpuMetrics.fps).toFixed(1), \"x\"),\n            batchSize: modelCharacteristics.batchSize,\n            features: modelCharacteristics.features\n        } : null;\n        return {\n            cpuMetrics,\n            gpuMetrics,\n            nvOptimizations\n        };\n    }\n    getDefaultMetrics() {\n        const defaultMetrics = {\n            fps: 0,\n            latency: 0,\n            memory: 0,\n            utilization: 0\n        };\n        return {\n            cpuMetrics: defaultMetrics,\n            gpuMetrics: defaultMetrics,\n            nvOptimizations: null\n        };\n    }\n    constructor(){\n        this.GPU_SPECS = {\n            peakTflops: 312,\n            memoryBandwidth: 2048,\n            tensorCores: 432,\n            maxBatchSize: 32,\n            // Minimum utilization for active models\n            minUtilization: {\n                cnn: 15,\n                transformer: 25,\n                detection: 20,\n                generation: 35 // Stable Diffusion etc\n            },\n            // Minimum memory requirements\n            minMemoryGB: {\n                cnn: 1.5,\n                transformer: 2.8,\n                detection: 2.2,\n                generation: 3.5 // Stable Diffusion etc\n            }\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBR0EsbURBQW1EO0FBQ25ELE1BQU1BO0lBT0pDLE9BQU9DLE1BQTBCLEVBQUU7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7WUFDckIsT0FBTztnQkFDTEMsS0FBSyxJQUFNO2dCQUNYQyxNQUFNLElBQU07WUFDZDtRQUNGO1FBRUEsT0FBTztZQUNMRCxLQUFLLElBQU0sSUFBSSxDQUFDRixJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJO1lBQ3BFSSxNQUFNLElBQU0sSUFBSSxDQUFDSCxJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU07UUFDNUY7SUFDRjtJQUVBLE9BQU9NLFlBQVlDLE9BQW1DLEVBQUU7UUFDdEQsT0FBTyxJQUFJWCxVQUFVVyxXQUFXLEVBQUU7SUFDcEM7SUFwQkFDLFlBQVlULElBQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLFFBQVEsRUFBRSxFQUFHLGlDQUFpQztJQUM1RDtBQW1CRjtBQUVPLE1BQU1VO0lBc0JIQyxvQkFBb0JDLGNBQThCLEVBQUU7UUFDMUQsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRSxFQUFFLEdBQUdGLGVBQWVHLEtBQUssSUFBSSxDQUFDO1FBRTNELElBQUk7WUFDRixNQUFNQyxLQUFLbkIsVUFBVVUsV0FBVyxDQUFDTztZQUVqQyx5QkFBeUI7WUFDekIsTUFBTUcsYUFBYUQsR0FBR2xCLE1BQU0sQ0FBQyxTQUFTSSxHQUFHLE9BQU1XLHFCQUFBQSwrQkFBQUEsU0FBVUksVUFBVSxLQUFJO1lB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SkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL21vZGVsL3BlcmZvcm1hbmNlLnRzP2RiNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGwgZnJvbSAnbm9kZWpzLXBvbGFycyc7XG5pbXBvcnQgdHlwZSB7IEFuYWx5c2lzUmVzdWx0LCBMYXllck1ldHJpY3MgfSBmcm9tICcuL3R5cGVzJztcblxuLy8gUG9sYXJzLWxpa2UgRGF0YUZyYW1lIGltcGxlbWVudGF0aW9uIGZvciBicm93c2VyXG5jbGFzcyBEYXRhRnJhbWUge1xuICBwcml2YXRlIGRhdGE6IExheWVyTWV0cmljc1tdO1xuXG4gIGNvbnN0cnVjdG9yKGRhdGE6IExheWVyTWV0cmljc1tdKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTsgIC8vIEVuc3VyZSBkYXRhIGlzIG5ldmVyIHVuZGVmaW5lZFxuICB9XG5cbiAgc2VsZWN0KGNvbHVtbjoga2V5b2YgTGF5ZXJNZXRyaWNzKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdW06ICgpID0+IDAsXG4gICAgICAgIG1lYW46ICgpID0+IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1bTogKCkgPT4gdGhpcy5kYXRhLnJlZHVjZSgoYWNjLCByb3cpID0+IGFjYyArIChyb3dbY29sdW1uXSB8fCAwKSwgMCksXG4gICAgICBtZWFuOiAoKSA9PiB0aGlzLmRhdGEucmVkdWNlKChhY2MsIHJvdykgPT4gYWNjICsgKHJvd1tjb2x1bW5dIHx8IDApLCAwKSAvIHRoaXMuZGF0YS5sZW5ndGhcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZyb21SZWNvcmRzKHJlY29yZHM6IExheWVyTWV0cmljc1tdIHwgdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhRnJhbWUocmVjb3JkcyB8fCBbXSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBlcmZvcm1hbmNlQ2FsY3VsYXRvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgR1BVX1NQRUNTID0ge1xuICAgIHBlYWtUZmxvcHM6IDMxMiwgICAgICAgICAgLy8gQTEwMCBGUDE2XG4gICAgbWVtb3J5QmFuZHdpZHRoOiAyMDQ4LCAgICAvLyBHQi9zXG4gICAgdGVuc29yQ29yZXM6IDQzMixcbiAgICBtYXhCYXRjaFNpemU6IDMyLFxuICAgIC8vIE1pbmltdW0gdXRpbGl6YXRpb24gZm9yIGFjdGl2ZSBtb2RlbHNcbiAgICBtaW5VdGlsaXphdGlvbjoge1xuICAgICAgY25uOiAxNSwgICAgICAgIC8vIEVmZmljaWVudCBDTk5zXG4gICAgICB0cmFuc2Zvcm1lcjogMjUsIC8vIFRyYW5zZm9ybWVyIG1vZGVsc1xuICAgICAgZGV0ZWN0aW9uOiAyMCwgIC8vIFlPTE8gZXRjXG4gICAgICBnZW5lcmF0aW9uOiAzNSAgLy8gU3RhYmxlIERpZmZ1c2lvbiBldGNcbiAgICB9LFxuICAgIC8vIE1pbmltdW0gbWVtb3J5IHJlcXVpcmVtZW50c1xuICAgIG1pbk1lbW9yeUdCOiB7XG4gICAgICBjbm46IDEuNSwgICAgICAgLy8gQmFzaWMgQ05Oc1xuICAgICAgdHJhbnNmb3JtZXI6IDIuOCwvLyBUcmFuc2Zvcm1lciBtb2RlbHNcbiAgICAgIGRldGVjdGlvbjogMi4yLCAvLyBZT0xPIGV0Y1xuICAgICAgZ2VuZXJhdGlvbjogMy41IC8vIFN0YWJsZSBEaWZmdXNpb24gZXRjXG4gICAgfVxuICB9O1xuXG4gIHByaXZhdGUgY2FsY3VsYXRlV2l0aFBvbGFycyhhbmFseXNpc1Jlc3VsdDogQW5hbHlzaXNSZXN1bHQpIHtcbiAgICBjb25zdCB7IG1ldGFkYXRhLCBsYXllcnMgPSBbXSB9ID0gYW5hbHlzaXNSZXN1bHQuZ3JhcGggfHwge307XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRmID0gRGF0YUZyYW1lLmZyb21SZWNvcmRzKGxheWVycyk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBiYXNlIG1ldHJpY3NcbiAgICAgIGNvbnN0IHRvdGFsRmxvcHMgPSBkZi5zZWxlY3QoJ2Zsb3BzJykuc3VtKCkgfHwgbWV0YWRhdGE/LnRvdGFsRmxvcHMgfHwgMDtcbiAgICAgIGNvbnN0IHRvdGFsTWVtb3J5ID0gZGYuc2VsZWN0KCdtZW1vcnknKS5zdW0oKSB8fCBtZXRhZGF0YT8udG90YWxNZW1vcnkgfHwgMDtcbiAgICAgIGNvbnN0IHBhcmFtc1BlckxheWVyID0gZGYuc2VsZWN0KCdwYXJhbWV0ZXJzJykubWVhbigpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgQ1BVLXNwZWNpZmljIGJhc2UgbWV0cmljc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnBzOiBNYXRoLm1pbig2MCwgMTAwMCAvIE1hdGgubWF4KDEsIHRvdGFsRmxvcHMgLyAxZTkpKSwgIC8vIENhcCBDUFUgYXQgNjAgRlBTXG4gICAgICAgIGxhdGVuY3k6IE1hdGgubWF4KDIuMCwgKHRvdGFsRmxvcHMgLyAxZTkpICogMy41KSwgICAgICAgICAvLyBDUFUgaGFzIGhpZ2hlciBiYXNlIGxhdGVuY3lcbiAgICAgICAgbWVtb3J5OiBNYXRoLm1heCgxLjUsIHRvdGFsTWVtb3J5IC8gKDEwMjQgKiAxMDI0ICogMTAyNCkpLCAvLyBDUFUgbmVlZHMgbW9yZSBtZW1vcnlcbiAgICAgICAgdXRpbGl6YXRpb246IE1hdGgubWluKDk1LCBNYXRoLm1heCgyNSwgKHRvdGFsRmxvcHMgLyAxZTkpICogMC44KSksIC8vIENQVSB1dGlsaXphdGlvbiBpcyBoaWdoZXJcbiAgICAgICAgZWZmaWNpZW5jeTogdG90YWxGbG9wcyAvIChkZi5zZWxlY3QoJ3BhcmFtZXRlcnMnKS5zdW0oKSB8fCAxKSxcbiAgICAgICAgbWVtb3J5RWZmaWNpZW5jeTogdG90YWxNZW1vcnkgLyAoZGYuc2VsZWN0KCdwYXJhbWV0ZXJzJykuc3VtKCkgKiA0IHx8IDEpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2FsY3VsYXRpb25zIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIHNpbXBsZSBjYWxjdWxhdGlvbnMnLCBlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZwczogTWF0aC5taW4oMzAsIDEwMDAgLyBNYXRoLm1heCgxLCBtZXRhZGF0YT8udG90YWxGbG9wcyAvIDFlOSB8fCAwKSksXG4gICAgICAgIGxhdGVuY3k6IE1hdGgubWF4KDIuMCwgKG1ldGFkYXRhPy50b3RhbEZsb3BzIC8gMWU5IHx8IDApICogMy41KSxcbiAgICAgICAgbWVtb3J5OiBNYXRoLm1heCgxLjUsIChtZXRhZGF0YT8udG90YWxNZW1vcnkgfHwgMCkgLyAoMTAyNCAqIDEwMjQgKiAxMDI0KSksXG4gICAgICAgIHV0aWxpemF0aW9uOiBNYXRoLm1pbig5NSwgKG1ldGFkYXRhPy50b3RhbEZsb3BzIC8gMWU5IHx8IDApICogMC44KSxcbiAgICAgICAgZWZmaWNpZW5jeTogMCxcbiAgICAgICAgbWVtb3J5RWZmaWNpZW5jeTogMFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldE1vZGVsQ2hhcmFjdGVyaXN0aWNzKG1vZGVsSWQ6IHN0cmluZyB8IHVuZGVmaW5lZCwgdG90YWxGbG9wczogbnVtYmVyLCB0b3RhbE1lbW9yeTogbnVtYmVyKSB7XG4gICAgY29uc3QgaWQgPSBtb2RlbElkPy50b0xvd2VyQ2FzZSgpID8/ICdkZWZhdWx0JztcbiAgICBjb25zdCBmbG9wc0luVEZsb3BzID0gdG90YWxGbG9wcyAvIDFlMTI7XG4gICAgY29uc3QgbWVtb3J5SW5HQiA9IHRvdGFsTWVtb3J5IC8gMTAyNCAvIDEwMjQgLyAxMDI0O1xuXG4gICAgLy8gQmFzZSBjaGFyYWN0ZXJpc3RpY3MgdGhhdCBzY2FsZSB3aXRoIG1vZGVsIHNpemVcbiAgICBjb25zdCBiYXNlQ2hhcmFjdGVyaXN0aWNzID0ge1xuICAgICAgbWluVXRpbGl6YXRpb246IE1hdGgubWF4KDE1LCBmbG9wc0luVEZsb3BzICogMTApLFxuICAgICAgdGVuc29yQ29yZVVzYWdlOiBNYXRoLm1heCgxMiwgZmxvcHNJblRGbG9wcyAqIDE1KSxcbiAgICAgIG1lbW9yeUJhbmR3aWR0aDogTWF0aC5tYXgoMC4zLCBmbG9wc0luVEZsb3BzICogMC41KSxcbiAgICAgIGJhc2VNZW1vcnk6IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pbk1lbW9yeUdCLmNubiwgbWVtb3J5SW5HQiAqIDEuMilcbiAgICB9O1xuXG4gICAgaWYgKGlkLmluY2x1ZGVzKCd5b2xvJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdkZXRlY3Rpb24nLFxuICAgICAgICBiYXRjaFNpemU6IDE2LFxuICAgICAgICBiYXNlVXRpbGl6YXRpb246IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pblV0aWxpemF0aW9uLmRldGVjdGlvbiwgYmFzZUNoYXJhY3RlcmlzdGljcy5taW5VdGlsaXphdGlvbiksXG4gICAgICAgIHNwZWVkdXBGYWN0b3I6IDIuOCxcbiAgICAgICAgbWVtb3J5U2NhbGU6IDEuMyxcbiAgICAgICAgdGVuc29yQ29yZVVzYWdlOiBiYXNlQ2hhcmFjdGVyaXN0aWNzLnRlbnNvckNvcmVVc2FnZSAqIDEuMixcbiAgICAgICAgbWVtb3J5QmFuZHdpZHRoOiBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1lbW9yeUJhbmR3aWR0aCAqIDEuNCxcbiAgICAgICAgZmVhdHVyZXM6IFsnSU5UOCBRdWFudGl6YXRpb24nLCAnQ1VEQSBHcmFwaCBBY2NlbGVyYXRpb24nXSxcbiAgICAgICAgYmFzZU1lbW9yeTogTWF0aC5tYXgodGhpcy5HUFVfU1BFQ1MubWluTWVtb3J5R0IuZGV0ZWN0aW9uLCBiYXNlQ2hhcmFjdGVyaXN0aWNzLmJhc2VNZW1vcnkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChpZC5pbmNsdWRlcygnc3RhYmxlJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdnZW5lcmF0aW9uJyxcbiAgICAgICAgYmF0Y2hTaXplOiAxLFxuICAgICAgICBiYXNlVXRpbGl6YXRpb246IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pblV0aWxpemF0aW9uLmdlbmVyYXRpb24sIGJhc2VDaGFyYWN0ZXJpc3RpY3MubWluVXRpbGl6YXRpb24pLFxuICAgICAgICBzcGVlZHVwRmFjdG9yOiAyLjIsXG4gICAgICAgIG1lbW9yeVNjYWxlOiAxLjUsXG4gICAgICAgIHRlbnNvckNvcmVVc2FnZTogYmFzZUNoYXJhY3RlcmlzdGljcy50ZW5zb3JDb3JlVXNhZ2UgKiAxLjUsXG4gICAgICAgIG1lbW9yeUJhbmR3aWR0aDogYmFzZUNoYXJhY3RlcmlzdGljcy5tZW1vcnlCYW5kd2lkdGggKiAxLjgsXG4gICAgICAgIGZlYXR1cmVzOiBbJ0ZQMTYgTWl4ZWQgUHJlY2lzaW9uJywgJ0F0dGVudGlvbiBPcHRpbWl6YXRpb24nXSxcbiAgICAgICAgYmFzZU1lbW9yeTogTWF0aC5tYXgodGhpcy5HUFVfU1BFQ1MubWluTWVtb3J5R0IuZ2VuZXJhdGlvbiwgYmFzZUNoYXJhY3RlcmlzdGljcy5iYXNlTWVtb3J5KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IENOTiBjaGFyYWN0ZXJpc3RpY3Mgd2l0aCByZWFsaXN0aWMgbWluaW11bXNcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2NubicsXG4gICAgICBiYXRjaFNpemU6IDMyLFxuICAgICAgYmFzZVV0aWxpemF0aW9uOiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5VdGlsaXphdGlvbi5jbm4sIGJhc2VDaGFyYWN0ZXJpc3RpY3MubWluVXRpbGl6YXRpb24pLFxuICAgICAgc3BlZWR1cEZhY3RvcjogMi4yLFxuICAgICAgbWVtb3J5U2NhbGU6IDEuMixcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogYmFzZUNoYXJhY3RlcmlzdGljcy50ZW5zb3JDb3JlVXNhZ2UsXG4gICAgICBtZW1vcnlCYW5kd2lkdGg6IGJhc2VDaGFyYWN0ZXJpc3RpY3MubWVtb3J5QmFuZHdpZHRoLFxuICAgICAgZmVhdHVyZXM6IFsnVGVuc29yUlQgSW5mZXJlbmNlJywgJ0tlcm5lbCBGdXNpb24nXSxcbiAgICAgIGJhc2VNZW1vcnk6IGJhc2VDaGFyYWN0ZXJpc3RpY3MuYmFzZU1lbW9yeVxuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVNZXRyaWNzKGFuYWx5c2lzUmVzdWx0OiBBbmFseXNpc1Jlc3VsdCB8IG51bGwsIGdwdUVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoIWFuYWx5c2lzUmVzdWx0Py5ncmFwaCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdE1ldHJpY3MoKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlTWV0cmljcyA9IHRoaXMuY2FsY3VsYXRlV2l0aFBvbGFycyhhbmFseXNpc1Jlc3VsdCk7XG4gICAgY29uc3QgeyB0b3RhbEZsb3BzID0gMCwgdG90YWxNZW1vcnkgPSAwLCBtb2RlbElkIH0gPSBhbmFseXNpc1Jlc3VsdC5ncmFwaC5tZXRhZGF0YTtcbiAgICBjb25zdCBtb2RlbENoYXJhY3RlcmlzdGljcyA9IHRoaXMuZ2V0TW9kZWxDaGFyYWN0ZXJpc3RpY3MobW9kZWxJZCwgdG90YWxGbG9wcywgdG90YWxNZW1vcnkpO1xuXG4gICAgLy8gR2V0IGJhc2VsaW5lIGJlbmNobWFya3NcbiAgICBjb25zdCBjcHVCYXNlbGluZSA9IENQVV9CRU5DSE1BUktTWyd4ZW9uLTgzODAnXS5yZXNuZXQ1MC5iYXRjaFNpemUxO1xuICAgIGNvbnN0IGdwdUJhc2VsaW5lID0gTlZJRElBX0JFTkNITUFSS1MucmVzbmV0NTAuYTEwMC5iYXRjaFNpemUxO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHJlbGF0aXZlIHBlcmZvcm1hbmNlIGJhc2VkIG9uIHJlYWwgYmVuY2htYXJrc1xuICAgIGNvbnN0IGNwdU1ldHJpY3MgPSB7XG4gICAgICBmcHM6IE1hdGgubWluKGNwdUJhc2VsaW5lLmZwcywgYmFzZU1ldHJpY3MuZnBzKSxcbiAgICAgIGxhdGVuY3k6IE1hdGgubWF4KGNwdUJhc2VsaW5lLmxhdGVuY3ksIGJhc2VNZXRyaWNzLmxhdGVuY3kpLFxuICAgICAgbWVtb3J5OiBNYXRoLm1heChjcHVCYXNlbGluZS5tZW1vcnkgLyAxMDI0LCBiYXNlTWV0cmljcy5tZW1vcnkpLCAvLyBDb252ZXJ0IE1CIHRvIEdCXG4gICAgICB1dGlsaXphdGlvbjogZ3B1RW5hYmxlZCBcbiAgICAgICAgPyBNYXRoLm1pbig0MCwgYmFzZU1ldHJpY3MudXRpbGl6YXRpb24gKiAwLjUpXG4gICAgICAgIDogYmFzZU1ldHJpY3MudXRpbGl6YXRpb25cbiAgICB9O1xuXG4gICAgLy8gR1BVIG1ldHJpY3MgYmFzZWQgb24gcmVhbCBBMTAwIGJlbmNobWFya3NcbiAgICBjb25zdCBncHVNZXRyaWNzID0ge1xuICAgICAgZnBzOiBncHVFbmFibGVkIFxuICAgICAgICA/IE1hdGgubWluKGdwdUJhc2VsaW5lLmZwcywgY3B1TWV0cmljcy5mcHMgKiBtb2RlbENoYXJhY3RlcmlzdGljcy5zcGVlZHVwRmFjdG9yKVxuICAgICAgICA6IE1hdGgubWluKGdwdUJhc2VsaW5lLmZwcyAvIDIsIGNwdU1ldHJpY3MuZnBzICogMS4yKSwgLy8gSW5hY3RpdmUgYnV0IHNob3cgcG90ZW50aWFsXG4gICAgICBsYXRlbmN5OiBncHVFbmFibGVkXG4gICAgICAgID8gTWF0aC5tYXgoZ3B1QmFzZWxpbmUubGF0ZW5jeSwgY3B1TWV0cmljcy5sYXRlbmN5IC8gbW9kZWxDaGFyYWN0ZXJpc3RpY3Muc3BlZWR1cEZhY3RvcilcbiAgICAgICAgOiBncHVCYXNlbGluZS5sYXRlbmN5ICogMiwgLy8gSGlnaGVyIGxhdGVuY3kgd2hlbiBpbmFjdGl2ZVxuICAgICAgbWVtb3J5OiBncHVFbmFibGVkXG4gICAgICAgID8gTWF0aC5tYXgoZ3B1QmFzZWxpbmUubWVtb3J5IC8gMTAyNCwgYmFzZU1ldHJpY3MubWVtb3J5ICogMC43KVxuICAgICAgICA6IGdwdUJhc2VsaW5lLm1lbW9yeSAvIDEwMjQsXG4gICAgICB1dGlsaXphdGlvbjogZ3B1RW5hYmxlZFxuICAgICAgICA/IE1hdGgubWF4KG1vZGVsQ2hhcmFjdGVyaXN0aWNzLmJhc2VVdGlsaXphdGlvbiwgTWF0aC5taW4oODUsIGJhc2VNZXRyaWNzLnV0aWxpemF0aW9uICogMC40KSlcbiAgICAgICAgOiAwXG4gICAgfTtcblxuICAgIGNvbnN0IG52T3B0aW1pemF0aW9ucyA9IGdwdUVuYWJsZWQgPyB7XG4gICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGAke21vZGVsQ2hhcmFjdGVyaXN0aWNzLnRlbnNvckNvcmVVc2FnZS50b0ZpeGVkKDEpfSVgLFxuICAgICAgbWVtb3J5QmFuZHdpZHRoOiBgJHttb2RlbENoYXJhY3RlcmlzdGljcy5tZW1vcnlCYW5kd2lkdGgudG9GaXhlZCgxKX0gVEIvc2AsXG4gICAgICBzcGVlZHVwOiBgJHsoZ3B1TWV0cmljcy5mcHMgLyBjcHVNZXRyaWNzLmZwcykudG9GaXhlZCgxKX14YCxcbiAgICAgIGJhdGNoU2l6ZTogbW9kZWxDaGFyYWN0ZXJpc3RpY3MuYmF0Y2hTaXplLFxuICAgICAgZmVhdHVyZXM6IG1vZGVsQ2hhcmFjdGVyaXN0aWNzLmZlYXR1cmVzXG4gICAgfSA6IG51bGw7XG5cbiAgICByZXR1cm4geyBjcHVNZXRyaWNzLCBncHVNZXRyaWNzLCBudk9wdGltaXphdGlvbnMgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGVmYXVsdE1ldHJpY3MoKSB7XG4gICAgY29uc3QgZGVmYXVsdE1ldHJpY3MgPSB7XG4gICAgICBmcHM6IDAsXG4gICAgICBsYXRlbmN5OiAwLFxuICAgICAgbWVtb3J5OiAwLFxuICAgICAgdXRpbGl6YXRpb246IDBcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBjcHVNZXRyaWNzOiBkZWZhdWx0TWV0cmljcyxcbiAgICAgIGdwdU1ldHJpY3M6IGRlZmF1bHRNZXRyaWNzLFxuICAgICAgbnZPcHRpbWl6YXRpb25zOiBudWxsXG4gICAgfTtcbiAgfVxufSAiXSwibmFtZXMiOlsiRGF0YUZyYW1lIiwic2VsZWN0IiwiY29sdW1uIiwiZGF0YSIsImxlbmd0aCIsInN1bSIsIm1lYW4iLCJyZWR1Y2UiLCJhY2MiLCJyb3ciLCJmcm9tUmVjb3JkcyIsInJlY29yZHMiLCJjb25zdHJ1Y3RvciIsIlBlcmZvcm1hbmNlQ2FsY3VsYXRvciIsImNhbGN1bGF0ZVdpdGhQb2xhcnMiLCJhbmFseXNpc1Jlc3VsdCIsIm1ldGFkYXRhIiwibGF5ZXJzIiwiZ3JhcGgiLCJkZiIsInRvdGFsRmxvcHMiLCJ0b3RhbE1lbW9yeSIsInBhcmFtc1BlckxheWVyIiwiZnBzIiwiTWF0aCIsIm1pbiIsIm1heCIsImxhdGVuY3kiLCJtZW1vcnkiLCJ1dGlsaXphdGlvbiIsImVmZmljaWVuY3kiLCJtZW1vcnlFZmZpY2llbmN5IiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0TW9kZWxDaGFyYWN0ZXJpc3RpY3MiLCJtb2RlbElkIiwiaWQiLCJ0b0xvd2VyQ2FzZSIsImZsb3BzSW5URmxvcHMiLCJtZW1vcnlJbkdCIiwiYmFzZUNoYXJhY3RlcmlzdGljcyIsIm1pblV0aWxpemF0aW9uIiwidGVuc29yQ29yZVVzYWdlIiwibWVtb3J5QmFuZHdpZHRoIiwiYmFzZU1lbW9yeSIsIkdQVV9TUEVDUyIsIm1pbk1lbW9yeUdCIiwiY25uIiwiaW5jbHVkZXMiLCJ0eXBlIiwiYmF0Y2hTaXplIiwiYmFzZVV0aWxpemF0aW9uIiwiZGV0ZWN0aW9uIiwic3BlZWR1cEZhY3RvciIsIm1lbW9yeVNjYWxlIiwiZmVhdHVyZXMiLCJnZW5lcmF0aW9uIiwiY2FsY3VsYXRlTWV0cmljcyIsImdwdUVuYWJsZWQiLCJnZXREZWZhdWx0TWV0cmljcyIsImJhc2VNZXRyaWNzIiwibW9kZWxDaGFyYWN0ZXJpc3RpY3MiLCJjcHVCYXNlbGluZSIsIkNQVV9CRU5DSE1BUktTIiwicmVzbmV0NTAiLCJiYXRjaFNpemUxIiwiZ3B1QmFzZWxpbmUiLCJOVklESUFfQkVOQ0hNQVJLUyIsImExMDAiLCJjcHVNZXRyaWNzIiwiZ3B1TWV0cmljcyIsIm52T3B0aW1pemF0aW9ucyIsInRvRml4ZWQiLCJzcGVlZHVwIiwiZGVmYXVsdE1ldHJpY3MiLCJwZWFrVGZsb3BzIiwidGVuc29yQ29yZXMiLCJtYXhCYXRjaFNpemUiLCJ0cmFuc2Zvcm1lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/performance.ts\n"));

/***/ })

});