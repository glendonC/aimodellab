"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/huggingface.ts":
/*!****************************!*\
  !*** ./lib/huggingface.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FEATURED_MODELS: function() { return /* binding */ FEATURED_MODELS; },\n/* harmony export */   getModelArchitecture: function() { return /* binding */ getModelArchitecture; },\n/* harmony export */   getModelInfo: function() { return /* binding */ getModelInfo; },\n/* harmony export */   searchModels: function() { return /* binding */ searchModels; }\n/* harmony export */ });\n/* harmony import */ var _model_architectures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model-architectures */ \"(app-pages-browser)/./lib/model-architectures.ts\");\nconst FEATURED_MODELS = [\n    // Vision Models (GPU-Intensive)\n    {\n        id: \"microsoft/resnet-50\",\n        name: \"ResNet-50\",\n        description: \"State-of-the-art image classification model with CUDA optimization\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"ResNet\",\n        size: \"98 MB\",\n        downloads: 2500000,\n        likes: 1200,\n        tags: [\n            \"computer-vision\",\n            \"classification\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"nvidia/stable-diffusion-v1.5\",\n        name: \"Stable Diffusion v1.5\",\n        description: \"Optimized for NVIDIA GPUs with tensor core acceleration\",\n        type: \"vision\",\n        task: \"text-to-image\",\n        architecture: \"Diffusion\",\n        size: \"7.7 GB\",\n        downloads: 5800000,\n        likes: 3200,\n        tags: [\n            \"generative-ai\",\n            \"text-to-image\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"yolov8\",\n        name: \"YOLOv8\",\n        description: \"Real-time object detection with CUDA acceleration\",\n        type: \"vision\",\n        task: \"object-detection\",\n        architecture: \"YOLO\",\n        size: \"108 MB\",\n        downloads: 4200000,\n        likes: 2800,\n        tags: [\n            \"object-detection\",\n            \"real-time\",\n            \"tensorrt\"\n        ]\n    },\n    // Large Language Models\n    {\n        id: \"meta-llama/llama-2-7b\",\n        name: \"Llama 2 (7B)\",\n        description: \"Efficient large language model with multi-GPU scaling\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"13.5 GB\",\n        downloads: 8500000,\n        likes: 4500,\n        tags: [\n            \"llm\",\n            \"multi-gpu\",\n            \"fp16-optimized\"\n        ]\n    },\n    {\n        id: \"openai/gpt-2\",\n        name: \"GPT-2 Small\",\n        description: \"Compact language model with GPU acceleration\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"1.5 GB\",\n        downloads: 3800000,\n        likes: 2100,\n        tags: [\n            \"nlp\",\n            \"text-generation\",\n            \"cuda\"\n        ]\n    },\n    // Specialized Models\n    {\n        id: \"facebook/bart-large-cnn\",\n        name: \"BART Large CNN\",\n        description: \"GPU-accelerated text summarization model\",\n        type: \"text\",\n        task: \"summarization\",\n        architecture: \"Transformer\",\n        size: \"1.6 GB\",\n        downloads: 1800000,\n        likes: 950,\n        tags: [\n            \"nlp\",\n            \"summarization\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"openai/whisper-base\",\n        name: \"Whisper Base\",\n        description: \"Speech recognition optimized for NVIDIA GPUs\",\n        type: \"audio\",\n        task: \"speech-recognition\",\n        architecture: \"Transformer\",\n        size: \"442 MB\",\n        downloads: 2900000,\n        likes: 1600,\n        tags: [\n            \"speech\",\n            \"audio\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"google/vit-base-patch16-224\",\n        name: \"ViT Base\",\n        description: \"Vision Transformer with tensor core acceleration\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"Transformer\",\n        size: \"346 MB\",\n        downloads: 3200000,\n        likes: 1500,\n        tags: [\n            \"vision\",\n            \"transformers\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"dmis-lab/biobert-base\",\n        name: \"BioBERT\",\n        description: \"Biomedical language model with GPU optimization\",\n        type: \"text\",\n        task: \"text-classification\",\n        architecture: \"BERT\",\n        size: \"412 MB\",\n        downloads: 890000,\n        likes: 720,\n        tags: [\n            \"healthcare\",\n            \"nlp\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"facebook/dinov2-base\",\n        name: \"DINOv2\",\n        description: \"Self-supervised vision model with NVIDIA acceleration\",\n        type: \"vision\",\n        task: \"self-supervised-learning\",\n        architecture: \"Transformer\",\n        size: \"384 MB\",\n        downloads: 1200000,\n        likes: 890,\n        tags: [\n            \"self-supervised\",\n            \"vision\",\n            \"cuda\"\n        ]\n    }\n];\nasync function searchModels(query) {\n    try {\n        const response = await fetch(\"https://huggingface.co/api/models?search=\".concat(encodeURIComponent(query)), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const text = await response.text();\n        if (!text) {\n            return [];\n        }\n        let data;\n        try {\n            data = JSON.parse(text);\n        } catch (e) {\n            console.error(\"Failed to parse response:\", e);\n            return [];\n        }\n        if (!Array.isArray(data)) {\n            console.error(\"Unexpected response format:\", data);\n            return [];\n        }\n        return data.map((model)=>{\n            var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n            return {\n                id: model.modelId || model.id,\n                name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n                description: model.description || \"No description available\",\n                type: determineModelType(model.pipeline_tag),\n                task: model.pipeline_tag || \"unknown\",\n                architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n                size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n                downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n                likes: model.likes || 0,\n                tags: [\n                    model.pipeline_tag,\n                    ...model.tags || [],\n                    model.library_name\n                ].filter(Boolean)\n            };\n        });\n    } catch (error) {\n        console.error(\"Failed to search models:\", error);\n        return [];\n    }\n}\nfunction determineModelType(pipelineTag) {\n    if (!pipelineTag) return \"vision\";\n    const visionTasks = [\n        \"image-classification\",\n        \"object-detection\",\n        \"image-segmentation\"\n    ];\n    const textTasks = [\n        \"text-classification\",\n        \"text-generation\",\n        \"translation\"\n    ];\n    const audioTasks = [\n        \"audio-classification\",\n        \"speech-recognition\"\n    ];\n    if (visionTasks.includes(pipelineTag)) return \"vision\";\n    if (textTasks.includes(pipelineTag)) return \"text\";\n    if (audioTasks.includes(pipelineTag)) return \"audio\";\n    return \"multimodal\";\n}\nfunction formatSize(bytes) {\n    if (bytes === 0) return \"0 B\";\n    const k = 1024;\n    const sizes = [\n        \"B\",\n        \"KB\",\n        \"MB\",\n        \"GB\",\n        \"TB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + \" \" + sizes[i];\n}\nasync function getModelInfo(modelId) {\n    try {\n        var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n        const response = await fetch(\"https://huggingface.co/api/models/\".concat(modelId), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Model not found\");\n        }\n        const model = await response.json();\n        return {\n            id: model.modelId || model.id,\n            name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n            description: model.description || \"No description available\",\n            type: determineModelType(model.pipeline_tag),\n            task: model.pipeline_tag || \"unknown\",\n            architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n            size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n            downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n            likes: model.likes || 0,\n            tags: [\n                model.pipeline_tag,\n                ...model.tags || [],\n                model.library_name\n            ].filter(Boolean)\n        };\n    } catch (error) {\n        console.error(\"Failed to get model info:\", error);\n        throw error;\n    }\n}\nasync function getModelArchitecture(modelId) {\n    switch(modelId){\n        case \"microsoft/resnet-50\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateResNetArchitecture)();\n        case \"facebook/bart-large-cnn\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateTransformerArchitecture)();\n        case \"google/vit-base-patch16-224\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateViTArchitecture)();\n        case \"nvidia/stable-diffusion-v1.5\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateStableDiffusionArchitecture)();\n        case \"meta-llama/llama-2-7b\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateLlama2Architecture)();\n        case \"yolov8\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateYOLOv8Architecture)();\n        // case 'openai/gpt-2':\n        //   return generateGPT2Architecture();\n        // case 'openai/whisper-base':\n        //   return generateWhisperArchitecture();\n        // case 'dmis-lab/biobert-base':\n        //   return generateBioBERTArchitecture();\n        // case 'facebook/dinov2-base':\n        //   return generateDINOv2Architecture();\n        default:\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateDefaultArchitecture)();\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9odWdnaW5nZmFjZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQThCTyxNQUFNQSxrQkFBNkI7SUFDeEMsZ0NBQWdDO0lBQ2hDO1FBQ0VDLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxjQUFjO1FBQ2RDLE1BQU07UUFDTkMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLE1BQU07WUFBQztZQUFtQjtZQUFrQjtTQUFpQjtJQUMvRDtJQUNBO1FBQ0VULElBQUk7UUFDSkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxjQUFjO1FBQ2RDLE1BQU07UUFDTkMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLE1BQU07WUFBQztZQUFpQjtZQUFpQjtTQUFlO0lBQzFEO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsTUFBTTtZQUFDO1lBQW9CO1lBQWE7U0FBVztJQUNyRDtJQUVBLHdCQUF3QjtJQUN4QjtRQUNFVCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsY0FBYztRQUNkQyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxNQUFNO1lBQUM7WUFBTztZQUFhO1NBQWlCO0lBQzlDO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsTUFBTTtZQUFDO1lBQU87WUFBbUI7U0FBTztJQUMxQztJQUVBLHFCQUFxQjtJQUNyQjtRQUNFVCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsY0FBYztRQUNkQyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxNQUFNO1lBQUM7WUFBTztZQUFpQjtTQUFPO0lBQ3hDO0lBQ0E7UUFDRVQsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLGNBQWM7UUFDZEMsTUFBTTtRQUNOQyxXQUFXO1FBQ1hDLE9BQU87UUFDUEMsTUFBTTtZQUFDO1lBQVU7WUFBUztTQUFpQjtJQUM3QztJQUNBO1FBQ0VULElBQUk7UUFDSkMsTUFBTTtRQUNOQyxhQUFhO1FBQ2JDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxjQUFjO1FBQ2RDLE1BQU07UUFDTkMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLE1BQU07WUFBQztZQUFVO1lBQWdCO1NBQWU7SUFDbEQ7SUFDQTtRQUNFVCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsY0FBYztRQUNkQyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxNQUFNO1lBQUM7WUFBYztZQUFPO1NBQU87SUFDckM7SUFDQTtRQUNFVCxJQUFJO1FBQ0pDLE1BQU07UUFDTkMsYUFBYTtRQUNiQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsY0FBYztRQUNkQyxNQUFNO1FBQ05DLFdBQVc7UUFDWEMsT0FBTztRQUNQQyxNQUFNO1lBQUM7WUFBbUI7WUFBVTtTQUFPO0lBQzdDO0NBQ0QsQ0FBQztBQUVLLGVBQWVDLGFBQWFDLEtBQWE7SUFDOUMsSUFBSTtRQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFDckIsNENBQXNFLE9BQTFCQyxtQkFBbUJILFNBQy9EO1lBQ0VJLFNBQVM7Z0JBQ1AsVUFBVTtZQUNaO1FBQ0Y7UUFHRixJQUFJLENBQUNILFNBQVNJLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0sdUJBQXVDLE9BQWhCTCxTQUFTTSxNQUFNO1FBQ3hEO1FBRUEsTUFBTUMsT0FBTyxNQUFNUCxTQUFTTyxJQUFJO1FBQ2hDLElBQUksQ0FBQ0EsTUFBTTtZQUNULE9BQU8sRUFBRTtRQUNYO1FBRUEsSUFBSUM7UUFDSixJQUFJO1lBQ0ZBLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0g7UUFDcEIsRUFBRSxPQUFPSSxHQUFHO1lBQ1ZDLFFBQVFDLEtBQUssQ0FBQyw2QkFBNkJGO1lBQzNDLE9BQU8sRUFBRTtRQUNYO1FBRUEsSUFBSSxDQUFDRyxNQUFNQyxPQUFPLENBQUNQLE9BQU87WUFDeEJJLFFBQVFDLEtBQUssQ0FBQywrQkFBK0JMO1lBQzdDLE9BQU8sRUFBRTtRQUNYO1FBRUEsT0FBT0EsS0FBS1EsR0FBRyxDQUFDLENBQUNDO2dCQUVSQSxPQUlPQSw2QkFBQUEsZUFDR0EseUJBQUFBLGtCQUNOQTttQkFSb0I7Z0JBQy9CN0IsSUFBSTZCLE1BQU1DLE9BQU8sSUFBSUQsTUFBTTdCLEVBQUU7Z0JBQzdCQyxNQUFNLEVBQUM0QixRQUFBQSxNQUFNQyxPQUFPLElBQUlELE1BQU03QixFQUFFLGNBQXpCNkIsNEJBQUQsTUFBNkJFLEtBQUssQ0FBQyxLQUFLQyxHQUFHLE9BQU07Z0JBQ3ZEOUIsYUFBYTJCLE1BQU0zQixXQUFXLElBQUk7Z0JBQ2xDQyxNQUFNOEIsbUJBQW1CSixNQUFNSyxZQUFZO2dCQUMzQzlCLE1BQU15QixNQUFNSyxZQUFZLElBQUk7Z0JBQzVCN0IsY0FBY3dCLEVBQUFBLGdCQUFBQSxNQUFNTSxNQUFNLGNBQVpOLHFDQUFBQSw4QkFBQUEsY0FBY08sYUFBYSxjQUEzQlAsa0RBQUFBLDJCQUE2QixDQUFDLEVBQUUsS0FBSTtnQkFDbER2QixNQUFNK0IsV0FBV1IsRUFBQUEsbUJBQUFBLE1BQU10QixTQUFTLGNBQWZzQix3Q0FBQUEsMEJBQUFBLGlCQUFpQlMsTUFBTSxjQUF2QlQsOENBQUFBLHdCQUF5QnZCLElBQUksS0FBSTtnQkFDbERDLFdBQVdzQixFQUFBQSxvQkFBQUEsTUFBTXRCLFNBQVMsY0FBZnNCLHdDQUFBQSxrQkFBaUJVLEtBQUssS0FBSTtnQkFDckMvQixPQUFPcUIsTUFBTXJCLEtBQUssSUFBSTtnQkFDdEJDLE1BQU07b0JBQ0pvQixNQUFNSyxZQUFZO3VCQUNkTCxNQUFNcEIsSUFBSSxJQUFJLEVBQUU7b0JBQ3BCb0IsTUFBTVcsWUFBWTtpQkFDbkIsQ0FBQ0MsTUFBTSxDQUFDQztZQUNYOztJQUNGLEVBQUUsT0FBT2pCLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsT0FBTyxFQUFFO0lBQ1g7QUFDRjtBQUVBLFNBQVNRLG1CQUFtQlUsV0FBbUI7SUFDN0MsSUFBSSxDQUFDQSxhQUFhLE9BQU87SUFFekIsTUFBTUMsY0FBYztRQUFDO1FBQXdCO1FBQW9CO0tBQXFCO0lBQ3RGLE1BQU1DLFlBQVk7UUFBQztRQUF1QjtRQUFtQjtLQUFjO0lBQzNFLE1BQU1DLGFBQWE7UUFBQztRQUF3QjtLQUFxQjtJQUVqRSxJQUFJRixZQUFZRyxRQUFRLENBQUNKLGNBQWMsT0FBTztJQUM5QyxJQUFJRSxVQUFVRSxRQUFRLENBQUNKLGNBQWMsT0FBTztJQUM1QyxJQUFJRyxXQUFXQyxRQUFRLENBQUNKLGNBQWMsT0FBTztJQUM3QyxPQUFPO0FBQ1Q7QUFFQSxTQUFTTixXQUFXVyxLQUFhO0lBQy9CLElBQUlBLFVBQVUsR0FBRyxPQUFPO0lBQ3hCLE1BQU1DLElBQUk7SUFDVixNQUFNQyxRQUFRO1FBQUM7UUFBSztRQUFNO1FBQU07UUFBTTtLQUFLO0lBQzNDLE1BQU1DLElBQUlDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsR0FBRyxDQUFDTixTQUFTSSxLQUFLRSxHQUFHLENBQUNMO0lBQ2hELE9BQU9NLFdBQVcsQ0FBQ1AsUUFBUUksS0FBS0ksR0FBRyxDQUFDUCxHQUFHRSxFQUFDLEVBQUdNLE9BQU8sQ0FBQyxNQUFNLE1BQU1QLEtBQUssQ0FBQ0MsRUFBRTtBQUN6RTtBQUVPLGVBQWVPLGFBQWE1QixPQUFlO0lBQ2hELElBQUk7WUFjT0QsT0FJT0EsNkJBQUFBLGVBQ0dBLHlCQUFBQSxrQkFDTkE7UUFuQmIsTUFBTWpCLFdBQVcsTUFBTUMsTUFBTSxxQ0FBNkMsT0FBUmlCLFVBQVc7WUFDM0VmLFNBQVM7Z0JBQ1AsVUFBVTtZQUNaO1FBQ0Y7UUFFQSxJQUFJLENBQUNILFNBQVNJLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxNQUFNWSxRQUFRLE1BQU1qQixTQUFTK0MsSUFBSTtRQUNqQyxPQUFPO1lBQ0wzRCxJQUFJNkIsTUFBTUMsT0FBTyxJQUFJRCxNQUFNN0IsRUFBRTtZQUM3QkMsTUFBTSxFQUFDNEIsUUFBQUEsTUFBTUMsT0FBTyxJQUFJRCxNQUFNN0IsRUFBRSxjQUF6QjZCLDRCQUFELE1BQTZCRSxLQUFLLENBQUMsS0FBS0MsR0FBRyxPQUFNO1lBQ3ZEOUIsYUFBYTJCLE1BQU0zQixXQUFXLElBQUk7WUFDbENDLE1BQU04QixtQkFBbUJKLE1BQU1LLFlBQVk7WUFDM0M5QixNQUFNeUIsTUFBTUssWUFBWSxJQUFJO1lBQzVCN0IsY0FBY3dCLEVBQUFBLGdCQUFBQSxNQUFNTSxNQUFNLGNBQVpOLHFDQUFBQSw4QkFBQUEsY0FBY08sYUFBYSxjQUEzQlAsa0RBQUFBLDJCQUE2QixDQUFDLEVBQUUsS0FBSTtZQUNsRHZCLE1BQU0rQixXQUFXUixFQUFBQSxtQkFBQUEsTUFBTXRCLFNBQVMsY0FBZnNCLHdDQUFBQSwwQkFBQUEsaUJBQWlCUyxNQUFNLGNBQXZCVCw4Q0FBQUEsd0JBQXlCdkIsSUFBSSxLQUFJO1lBQ2xEQyxXQUFXc0IsRUFBQUEsb0JBQUFBLE1BQU10QixTQUFTLGNBQWZzQix3Q0FBQUEsa0JBQWlCVSxLQUFLLEtBQUk7WUFDckMvQixPQUFPcUIsTUFBTXJCLEtBQUssSUFBSTtZQUN0QkMsTUFBTTtnQkFDSm9CLE1BQU1LLFlBQVk7bUJBQ2RMLE1BQU1wQixJQUFJLElBQUksRUFBRTtnQkFDcEJvQixNQUFNVyxZQUFZO2FBQ25CLENBQUNDLE1BQU0sQ0FBQ0M7UUFDWDtJQUNGLEVBQUUsT0FBT2pCLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0MsTUFBTUE7SUFDUjtBQUNGO0FBRU8sZUFBZW1DLHFCQUFxQjlCLE9BQWU7SUFDeEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTytCLGdGQUEwQkE7UUFDbkMsS0FBSztZQUNILE9BQU9DLHFGQUErQkE7UUFDeEMsS0FBSztZQUNILE9BQU9DLDZFQUF1QkE7UUFDaEMsS0FBSztZQUNILE9BQU9DLHlGQUFtQ0E7UUFDNUMsS0FBSztZQUNILE9BQU9DLGdGQUEwQkE7UUFDbkMsS0FBSztZQUNILE9BQU9DLGdGQUEwQkE7UUFDbkMsdUJBQXVCO1FBQ3ZCLHVDQUF1QztRQUN2Qyw4QkFBOEI7UUFDOUIsMENBQTBDO1FBQzFDLGdDQUFnQztRQUNoQywwQ0FBMEM7UUFDMUMsK0JBQStCO1FBQy9CLHlDQUF5QztRQUN6QztZQUNFLE9BQU9DLGlGQUEyQkE7SUFDdEM7QUFDRjtBQVlnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaHVnZ2luZ2ZhY2UudHM/YTBmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIZkluZmVyZW5jZSB9IGZyb20gJ0BodWdnaW5nZmFjZS9pbmZlcmVuY2UnO1xuXG5leHBvcnQgdHlwZSBIRk1vZGVsID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHR5cGU6ICd2aXNpb24nIHwgJ3RleHQnIHwgJ2F1ZGlvJyB8ICdtdWx0aW1vZGFsJztcbiAgdGFzazogc3RyaW5nO1xuICBhcmNoaXRlY3R1cmU6IHN0cmluZztcbiAgc2l6ZTogc3RyaW5nO1xuICBkb3dubG9hZHM6IG51bWJlcjtcbiAgbGlrZXM6IG51bWJlcjtcbiAgdGFnczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBNb2RlbEFyY2hpdGVjdHVyZSA9IHtcbiAgbm9kZXM6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcGFyYW1zOiBudW1iZXI7XG4gICAgZmxvcHM6IG51bWJlcjtcbiAgICBtZW1vcnlVc2FnZTogbnVtYmVyO1xuICB9PjtcbiAgZWRnZXM6IEFycmF5PHtcbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICB0YXJnZXQ6IHN0cmluZztcbiAgfT47XG59O1xuXG5leHBvcnQgY29uc3QgRkVBVFVSRURfTU9ERUxTOiBIRk1vZGVsW10gPSBbXG4gIC8vIFZpc2lvbiBNb2RlbHMgKEdQVS1JbnRlbnNpdmUpXG4gIHtcbiAgICBpZDogJ21pY3Jvc29mdC9yZXNuZXQtNTAnLFxuICAgIG5hbWU6ICdSZXNOZXQtNTAnLFxuICAgIGRlc2NyaXB0aW9uOiAnU3RhdGUtb2YtdGhlLWFydCBpbWFnZSBjbGFzc2lmaWNhdGlvbiBtb2RlbCB3aXRoIENVREEgb3B0aW1pemF0aW9uJyxcbiAgICB0eXBlOiAndmlzaW9uJyxcbiAgICB0YXNrOiAnaW1hZ2UtY2xhc3NpZmljYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1Jlc05ldCcsXG4gICAgc2l6ZTogJzk4IE1CJyxcbiAgICBkb3dubG9hZHM6IDI1MDAwMDAsXG4gICAgbGlrZXM6IDEyMDAsXG4gICAgdGFnczogWydjb21wdXRlci12aXNpb24nLCAnY2xhc3NpZmljYXRpb24nLCAnY3VkYS1vcHRpbWl6ZWQnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdudmlkaWEvc3RhYmxlLWRpZmZ1c2lvbi12MS41JyxcbiAgICBuYW1lOiAnU3RhYmxlIERpZmZ1c2lvbiB2MS41JyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGltaXplZCBmb3IgTlZJRElBIEdQVXMgd2l0aCB0ZW5zb3IgY29yZSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICd0ZXh0LXRvLWltYWdlJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdEaWZmdXNpb24nLFxuICAgIHNpemU6ICc3LjcgR0InLFxuICAgIGRvd25sb2FkczogNTgwMDAwMCxcbiAgICBsaWtlczogMzIwMCxcbiAgICB0YWdzOiBbJ2dlbmVyYXRpdmUtYWknLCAndGV4dC10by1pbWFnZScsICd0ZW5zb3ItY29yZXMnXVxuICB9LFxuICB7XG4gICAgaWQ6ICd5b2xvdjgnLFxuICAgIG5hbWU6ICdZT0xPdjgnLFxuICAgIGRlc2NyaXB0aW9uOiAnUmVhbC10aW1lIG9iamVjdCBkZXRlY3Rpb24gd2l0aCBDVURBIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3Zpc2lvbicsXG4gICAgdGFzazogJ29iamVjdC1kZXRlY3Rpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1lPTE8nLFxuICAgIHNpemU6ICcxMDggTUInLFxuICAgIGRvd25sb2FkczogNDIwMDAwMCxcbiAgICBsaWtlczogMjgwMCxcbiAgICB0YWdzOiBbJ29iamVjdC1kZXRlY3Rpb24nLCAncmVhbC10aW1lJywgJ3RlbnNvcnJ0J11cbiAgfSxcbiAgXG4gIC8vIExhcmdlIExhbmd1YWdlIE1vZGVsc1xuICB7XG4gICAgaWQ6ICdtZXRhLWxsYW1hL2xsYW1hLTItN2InLFxuICAgIG5hbWU6ICdMbGFtYSAyICg3QiknLFxuICAgIGRlc2NyaXB0aW9uOiAnRWZmaWNpZW50IGxhcmdlIGxhbmd1YWdlIG1vZGVsIHdpdGggbXVsdGktR1BVIHNjYWxpbmcnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICB0YXNrOiAndGV4dC1nZW5lcmF0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzEzLjUgR0InLFxuICAgIGRvd25sb2FkczogODUwMDAwMCxcbiAgICBsaWtlczogNDUwMCxcbiAgICB0YWdzOiBbJ2xsbScsICdtdWx0aS1ncHUnLCAnZnAxNi1vcHRpbWl6ZWQnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdvcGVuYWkvZ3B0LTInLFxuICAgIG5hbWU6ICdHUFQtMiBTbWFsbCcsXG4gICAgZGVzY3JpcHRpb246ICdDb21wYWN0IGxhbmd1YWdlIG1vZGVsIHdpdGggR1BVIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3RleHQnLFxuICAgIHRhc2s6ICd0ZXh0LWdlbmVyYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnMS41IEdCJyxcbiAgICBkb3dubG9hZHM6IDM4MDAwMDAsXG4gICAgbGlrZXM6IDIxMDAsXG4gICAgdGFnczogWydubHAnLCAndGV4dC1nZW5lcmF0aW9uJywgJ2N1ZGEnXVxuICB9LFxuXG4gIC8vIFNwZWNpYWxpemVkIE1vZGVsc1xuICB7XG4gICAgaWQ6ICdmYWNlYm9vay9iYXJ0LWxhcmdlLWNubicsXG4gICAgbmFtZTogJ0JBUlQgTGFyZ2UgQ05OJyxcbiAgICBkZXNjcmlwdGlvbjogJ0dQVS1hY2NlbGVyYXRlZCB0ZXh0IHN1bW1hcml6YXRpb24gbW9kZWwnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICB0YXNrOiAnc3VtbWFyaXphdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICcxLjYgR0InLFxuICAgIGRvd25sb2FkczogMTgwMDAwMCxcbiAgICBsaWtlczogOTUwLFxuICAgIHRhZ3M6IFsnbmxwJywgJ3N1bW1hcml6YXRpb24nLCAnY3VkYSddXG4gIH0sXG4gIHtcbiAgICBpZDogJ29wZW5haS93aGlzcGVyLWJhc2UnLFxuICAgIG5hbWU6ICdXaGlzcGVyIEJhc2UnLFxuICAgIGRlc2NyaXB0aW9uOiAnU3BlZWNoIHJlY29nbml0aW9uIG9wdGltaXplZCBmb3IgTlZJRElBIEdQVXMnLFxuICAgIHR5cGU6ICdhdWRpbycsXG4gICAgdGFzazogJ3NwZWVjaC1yZWNvZ25pdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICc0NDIgTUInLFxuICAgIGRvd25sb2FkczogMjkwMDAwMCxcbiAgICBsaWtlczogMTYwMCxcbiAgICB0YWdzOiBbJ3NwZWVjaCcsICdhdWRpbycsICdjdWRhLW9wdGltaXplZCddXG4gIH0sXG4gIHtcbiAgICBpZDogJ2dvb2dsZS92aXQtYmFzZS1wYXRjaDE2LTIyNCcsXG4gICAgbmFtZTogJ1ZpVCBCYXNlJyxcbiAgICBkZXNjcmlwdGlvbjogJ1Zpc2lvbiBUcmFuc2Zvcm1lciB3aXRoIHRlbnNvciBjb3JlIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3Zpc2lvbicsXG4gICAgdGFzazogJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzM0NiBNQicsXG4gICAgZG93bmxvYWRzOiAzMjAwMDAwLFxuICAgIGxpa2VzOiAxNTAwLFxuICAgIHRhZ3M6IFsndmlzaW9uJywgJ3RyYW5zZm9ybWVycycsICd0ZW5zb3ItY29yZXMnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdkbWlzLWxhYi9iaW9iZXJ0LWJhc2UnLFxuICAgIG5hbWU6ICdCaW9CRVJUJyxcbiAgICBkZXNjcmlwdGlvbjogJ0Jpb21lZGljYWwgbGFuZ3VhZ2UgbW9kZWwgd2l0aCBHUFUgb3B0aW1pemF0aW9uJyxcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgdGFzazogJ3RleHQtY2xhc3NpZmljYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ0JFUlQnLFxuICAgIHNpemU6ICc0MTIgTUInLFxuICAgIGRvd25sb2FkczogODkwMDAwLFxuICAgIGxpa2VzOiA3MjAsXG4gICAgdGFnczogWydoZWFsdGhjYXJlJywgJ25scCcsICdjdWRhJ11cbiAgfSxcbiAge1xuICAgIGlkOiAnZmFjZWJvb2svZGlub3YyLWJhc2UnLFxuICAgIG5hbWU6ICdESU5PdjInLFxuICAgIGRlc2NyaXB0aW9uOiAnU2VsZi1zdXBlcnZpc2VkIHZpc2lvbiBtb2RlbCB3aXRoIE5WSURJQSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICdzZWxmLXN1cGVydmlzZWQtbGVhcm5pbmcnLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnMzg0IE1CJyxcbiAgICBkb3dubG9hZHM6IDEyMDAwMDAsXG4gICAgbGlrZXM6IDg5MCxcbiAgICB0YWdzOiBbJ3NlbGYtc3VwZXJ2aXNlZCcsICd2aXNpb24nLCAnY3VkYSddXG4gIH1cbl07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hNb2RlbHMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8SEZNb2RlbFtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS9tb2RlbHM/c2VhcmNoPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX1gLFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2U6JywgZSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdDonLCBkYXRhKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5tYXAoKG1vZGVsOiBhbnkpID0+ICh7XG4gICAgICBpZDogbW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCxcbiAgICAgIG5hbWU6IChtb2RlbC5tb2RlbElkIHx8IG1vZGVsLmlkKT8uc3BsaXQoJy8nKS5wb3AoKSB8fCAnVW5rbm93biBNb2RlbCcsXG4gICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZScsXG4gICAgICB0eXBlOiBkZXRlcm1pbmVNb2RlbFR5cGUobW9kZWwucGlwZWxpbmVfdGFnKSxcbiAgICAgIHRhc2s6IG1vZGVsLnBpcGVsaW5lX3RhZyB8fCAndW5rbm93bicsXG4gICAgICBhcmNoaXRlY3R1cmU6IG1vZGVsLmNvbmZpZz8uYXJjaGl0ZWN0dXJlcz8uWzBdIHx8ICd1bmtub3duJyxcbiAgICAgIHNpemU6IGZvcm1hdFNpemUobW9kZWwuZG93bmxvYWRzPy5iaW5hcnk/LnNpemUgfHwgMCksXG4gICAgICBkb3dubG9hZHM6IG1vZGVsLmRvd25sb2Fkcz8udG90YWwgfHwgMCxcbiAgICAgIGxpa2VzOiBtb2RlbC5saWtlcyB8fCAwLFxuICAgICAgdGFnczogW1xuICAgICAgICBtb2RlbC5waXBlbGluZV90YWcsXG4gICAgICAgIC4uLihtb2RlbC50YWdzIHx8IFtdKSxcbiAgICAgICAgbW9kZWwubGlicmFyeV9uYW1lXG4gICAgICBdLmZpbHRlcihCb29sZWFuKVxuICAgIH0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VhcmNoIG1vZGVsczonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1vZGVsVHlwZShwaXBlbGluZVRhZzogc3RyaW5nKTogSEZNb2RlbFsndHlwZSddIHtcbiAgaWYgKCFwaXBlbGluZVRhZykgcmV0dXJuICd2aXNpb24nO1xuICBcbiAgY29uc3QgdmlzaW9uVGFza3MgPSBbJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJywgJ29iamVjdC1kZXRlY3Rpb24nLCAnaW1hZ2Utc2VnbWVudGF0aW9uJ107XG4gIGNvbnN0IHRleHRUYXNrcyA9IFsndGV4dC1jbGFzc2lmaWNhdGlvbicsICd0ZXh0LWdlbmVyYXRpb24nLCAndHJhbnNsYXRpb24nXTtcbiAgY29uc3QgYXVkaW9UYXNrcyA9IFsnYXVkaW8tY2xhc3NpZmljYXRpb24nLCAnc3BlZWNoLXJlY29nbml0aW9uJ107XG4gIFxuICBpZiAodmlzaW9uVGFza3MuaW5jbHVkZXMocGlwZWxpbmVUYWcpKSByZXR1cm4gJ3Zpc2lvbic7XG4gIGlmICh0ZXh0VGFza3MuaW5jbHVkZXMocGlwZWxpbmVUYWcpKSByZXR1cm4gJ3RleHQnO1xuICBpZiAoYXVkaW9UYXNrcy5pbmNsdWRlcyhwaXBlbGluZVRhZykpIHJldHVybiAnYXVkaW8nO1xuICByZXR1cm4gJ211bHRpbW9kYWwnO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTaXplKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoYnl0ZXMgPT09IDApIHJldHVybiAnMCBCJztcbiAgY29uc3QgayA9IDEwMjQ7XG4gIGNvbnN0IHNpemVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ107XG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoMSkpICsgJyAnICsgc2l6ZXNbaV07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbEluZm8obW9kZWxJZDogc3RyaW5nKTogUHJvbWlzZTxIRk1vZGVsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvbW9kZWxzLyR7bW9kZWxJZH1gLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGVsID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogbW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCxcbiAgICAgIG5hbWU6IChtb2RlbC5tb2RlbElkIHx8IG1vZGVsLmlkKT8uc3BsaXQoJy8nKS5wb3AoKSB8fCAnVW5rbm93biBNb2RlbCcsXG4gICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZScsXG4gICAgICB0eXBlOiBkZXRlcm1pbmVNb2RlbFR5cGUobW9kZWwucGlwZWxpbmVfdGFnKSxcbiAgICAgIHRhc2s6IG1vZGVsLnBpcGVsaW5lX3RhZyB8fCAndW5rbm93bicsXG4gICAgICBhcmNoaXRlY3R1cmU6IG1vZGVsLmNvbmZpZz8uYXJjaGl0ZWN0dXJlcz8uWzBdIHx8ICd1bmtub3duJyxcbiAgICAgIHNpemU6IGZvcm1hdFNpemUobW9kZWwuZG93bmxvYWRzPy5iaW5hcnk/LnNpemUgfHwgMCksXG4gICAgICBkb3dubG9hZHM6IG1vZGVsLmRvd25sb2Fkcz8udG90YWwgfHwgMCxcbiAgICAgIGxpa2VzOiBtb2RlbC5saWtlcyB8fCAwLFxuICAgICAgdGFnczogW1xuICAgICAgICBtb2RlbC5waXBlbGluZV90YWcsXG4gICAgICAgIC4uLihtb2RlbC50YWdzIHx8IFtdKSxcbiAgICAgICAgbW9kZWwubGlicmFyeV9uYW1lXG4gICAgICBdLmZpbHRlcihCb29sZWFuKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBtb2RlbCBpbmZvOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TW9kZWxBcmNoaXRlY3R1cmUobW9kZWxJZDogc3RyaW5nKTogUHJvbWlzZTxNb2RlbEFyY2hpdGVjdHVyZT4ge1xuICBzd2l0Y2ggKG1vZGVsSWQpIHtcbiAgICBjYXNlICdtaWNyb3NvZnQvcmVzbmV0LTUwJzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVJlc05ldEFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ2ZhY2Vib29rL2JhcnQtbGFyZ2UtY25uJzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVRyYW5zZm9ybWVyQXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAnZ29vZ2xlL3ZpdC1iYXNlLXBhdGNoMTYtMjI0JzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVZpVEFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ252aWRpYS9zdGFibGUtZGlmZnVzaW9uLXYxLjUnOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlU3RhYmxlRGlmZnVzaW9uQXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAnbWV0YS1sbGFtYS9sbGFtYS0yLTdiJzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ3lvbG92OCc6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVZT0xPdjhBcmNoaXRlY3R1cmUoKTtcbiAgICAvLyBjYXNlICdvcGVuYWkvZ3B0LTInOlxuICAgIC8vICAgcmV0dXJuIGdlbmVyYXRlR1BUMkFyY2hpdGVjdHVyZSgpO1xuICAgIC8vIGNhc2UgJ29wZW5haS93aGlzcGVyLWJhc2UnOlxuICAgIC8vICAgcmV0dXJuIGdlbmVyYXRlV2hpc3BlckFyY2hpdGVjdHVyZSgpO1xuICAgIC8vIGNhc2UgJ2RtaXMtbGFiL2Jpb2JlcnQtYmFzZSc6XG4gICAgLy8gICByZXR1cm4gZ2VuZXJhdGVCaW9CRVJUQXJjaGl0ZWN0dXJlKCk7XG4gICAgLy8gY2FzZSAnZmFjZWJvb2svZGlub3YyLWJhc2UnOlxuICAgIC8vICAgcmV0dXJuIGdlbmVyYXRlRElOT3YyQXJjaGl0ZWN0dXJlKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZW5lcmF0ZURlZmF1bHRBcmNoaXRlY3R1cmUoKTtcbiAgfVxufVxuXG4vLyBJbXBvcnQgYXJjaGl0ZWN0dXJlIGdlbmVyYXRpb24gZnVuY3Rpb25zXG5pbXBvcnQgeyBNb2RlbEFyY2hpdGVjdHVyZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVEZWZhdWx0QXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVJlc05ldEFyY2hpdGVjdHVyZSxcbiAgZ2VuZXJhdGVUcmFuc2Zvcm1lckFyY2hpdGVjdHVyZSxcbiAgZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUsXG4gIGdlbmVyYXRlU3RhYmxlRGlmZnVzaW9uQXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSxcbiAgZ2VuZXJhdGVZT0xPdjhBcmNoaXRlY3R1cmUsXG4gIFxuIH0gZnJvbSAnLi9tb2RlbC1hcmNoaXRlY3R1cmVzJztcbiJdLCJuYW1lcyI6WyJGRUFUVVJFRF9NT0RFTFMiLCJpZCIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsInR5cGUiLCJ0YXNrIiwiYXJjaGl0ZWN0dXJlIiwic2l6ZSIsImRvd25sb2FkcyIsImxpa2VzIiwidGFncyIsInNlYXJjaE1vZGVscyIsInF1ZXJ5IiwicmVzcG9uc2UiLCJmZXRjaCIsImVuY29kZVVSSUNvbXBvbmVudCIsImhlYWRlcnMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwidGV4dCIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwibW9kZWwiLCJtb2RlbElkIiwic3BsaXQiLCJwb3AiLCJkZXRlcm1pbmVNb2RlbFR5cGUiLCJwaXBlbGluZV90YWciLCJjb25maWciLCJhcmNoaXRlY3R1cmVzIiwiZm9ybWF0U2l6ZSIsImJpbmFyeSIsInRvdGFsIiwibGlicmFyeV9uYW1lIiwiZmlsdGVyIiwiQm9vbGVhbiIsInBpcGVsaW5lVGFnIiwidmlzaW9uVGFza3MiLCJ0ZXh0VGFza3MiLCJhdWRpb1Rhc2tzIiwiaW5jbHVkZXMiLCJieXRlcyIsImsiLCJzaXplcyIsImkiLCJNYXRoIiwiZmxvb3IiLCJsb2ciLCJwYXJzZUZsb2F0IiwicG93IiwidG9GaXhlZCIsImdldE1vZGVsSW5mbyIsImpzb24iLCJnZXRNb2RlbEFyY2hpdGVjdHVyZSIsImdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVUcmFuc2Zvcm1lckFyY2hpdGVjdHVyZSIsImdlbmVyYXRlVmlUQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVEZWZhdWx0QXJjaGl0ZWN0dXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/huggingface.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/model-architectures.ts":
/*!************************************!*\
  !*** ./lib/model-architectures.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDefaultArchitecture: function() { return /* binding */ generateDefaultArchitecture; },\n/* harmony export */   generateLlama2Architecture: function() { return /* binding */ generateLlama2Architecture; },\n/* harmony export */   generateResNetArchitecture: function() { return /* binding */ generateResNetArchitecture; },\n/* harmony export */   generateStableDiffusionArchitecture: function() { return /* binding */ generateStableDiffusionArchitecture; },\n/* harmony export */   generateTransformerArchitecture: function() { return /* binding */ generateTransformerArchitecture; },\n/* harmony export */   generateViTArchitecture: function() { return /* binding */ generateViTArchitecture; },\n/* harmony export */   generateYOLOv8Architecture: function() { return /* binding */ generateYOLOv8Architecture; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ generateResNetArchitecture,generateTransformerArchitecture,generateViTArchitecture,generateYOLOv8Architecture,generateStableDiffusionArchitecture,generateLlama2Architecture,generateDefaultArchitecture auto */ function generateResNetArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Initial convolution\n    nodes.push({\n        id: \"conv1\",\n        type: \"cnn\",\n        name: \"Conv1\",\n        params: 9408,\n        flops: 118013952,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"conv1\"\n    });\n    prevId = \"conv1\";\n    // ResNet blocks\n    const blocks = [\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\"\n    ];\n    blocks.forEach((block, i)=>{\n        // Each block has multiple residual units\n        for(let unit = 0; unit < 3; unit++){\n            const blockId = \"res\".concat(block, \"_\").concat(unit);\n            nodes.push({\n                id: blockId,\n                type: \"residual\",\n                name: \"ResBlock \".concat(block, \".\").concat(unit),\n                params: 1024 * 1024 * (i + 1),\n                flops: 5 * 1024 * 1024 * (i + 1),\n                memoryUsage: 3 * 1024 * 1024 * (i + 1)\n            });\n            edges.push({\n                source: prevId,\n                target: blockId\n            });\n            prevId = blockId;\n        }\n    });\n    // Final layers\n    nodes.push({\n        id: \"pool\",\n        type: \"mlp\",\n        name: \"Global Pool\",\n        params: 2048,\n        flops: 2048,\n        memoryUsage: 1024 * 512\n    });\n    edges.push({\n        source: prevId,\n        target: \"pool\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"FC 1000\",\n        params: 2048000,\n        flops: 2048000,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"pool\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateTransformerArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Encoder layers\n    for(let i = 0; i < 6; i++){\n        const attentionId = \"enc_attn_\".concat(i);\n        const ffnId = \"enc_ffn_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"attention\",\n            name: \"Encoder Self-Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: ffnId,\n            type: \"mlp\",\n            name: \"Encoder FFN \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Layer Norm \".concat(i),\n            params: 1024,\n            flops: 2048,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: ffnId\n        });\n        edges.push({\n            source: ffnId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    // Output projection\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Projection\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateViTArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Patch Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Patch embedding\n    nodes.push({\n        id: \"patch_embed\",\n        type: \"cnn\",\n        name: \"Patch Embedding\",\n        params: 590592,\n        flops: 47185920,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"patch_embed\"\n    });\n    prevId = \"patch_embed\";\n    // Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attentionId = \"transformer_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"transformer\",\n            name: \"Transformer Block \".concat(i),\n            params: 7 * 1024 * 1024,\n            flops: 28 * 1024 * 1024,\n            memoryUsage: 14 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: mlpId\n        });\n        prevId = mlpId;\n    }\n    // Classification head\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Classification Head\",\n        params: 768000,\n        flops: 768000,\n        memoryUsage: 1024 * 768\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateYOLOv8Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024 // 1MB for input tensor\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Backbone: CSPDarknet\n    for(let i = 0; i < 4; i++){\n        const convId = \"conv_\".concat(i);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Conv Block \".concat(i + 1),\n            params: 64 * Math.pow(2, i) * 3 * 3,\n            flops: 64 * Math.pow(2, i) * 3 * 3 * 512 * 512 / Math.pow(2, i),\n            memoryUsage: 512 * 512 * 64 * Math.pow(2, i) / Math.pow(2, i) * 4 // 4 bytes per float\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    }\n    // Feature Pyramid Network (FPN)\n    const fpnLayers = [\n        \"P5\",\n        \"P4\",\n        \"P3\"\n    ];\n    fpnLayers.forEach((layer, i)=>{\n        const fpnId = \"fpn_\".concat(layer);\n        nodes.push({\n            id: fpnId,\n            type: \"graph\",\n            name: \"FPN \".concat(layer),\n            params: 256 * 256 * 3,\n            flops: 256 * 256 * 3 * 80 * 80 / Math.pow(2, i),\n            memoryUsage: 256 * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: prevId,\n            target: fpnId\n        });\n        prevId = fpnId;\n    });\n    // Detection Heads\n    [\n        \"small\",\n        \"medium\",\n        \"large\"\n    ].forEach((size, i)=>{\n        const headId = \"head_\".concat(size);\n        nodes.push({\n            id: headId,\n            type: \"mlp\",\n            name: \"Detection Head (\".concat(size, \")\"),\n            params: 256 * (80 + 4 + 1),\n            flops: 256 * (80 + 4 + 1) * 80 * 80 / Math.pow(2, i),\n            memoryUsage: (80 + 4 + 1) * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: \"fpn_\".concat(fpnLayers[i]),\n            target: headId\n        });\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Stable Diffusion\nfunction generateStableDiffusionArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Add UNet Encoder blocks\n    for(let i = 0; i < 4; i++){\n        const encoderId = \"encoder_\".concat(i);\n        const attnId = \"encoder_attn_\".concat(i);\n        nodes.push({\n            id: encoderId,\n            type: \"residual\",\n            name: \"UNet Encoder \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Cross Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: encoderId\n        });\n        edges.push({\n            source: encoderId,\n            target: attnId\n        });\n        prevId = attnId;\n    }\n    // Add UNet Decoder blocks with skip connections\n    for(let i = 3; i >= 0; i--){\n        const decoderId = \"decoder_\".concat(i);\n        nodes.push({\n            id: decoderId,\n            type: \"residual\",\n            name: \"UNet Decoder \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: decoderId\n        });\n        edges.push({\n            source: \"encoder_attn_\".concat(i),\n            target: decoderId\n        }); // Skip connection\n        prevId = decoderId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Llama 2\nfunction generateLlama2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token Embedding\",\n        params: 32000 * 4096,\n        flops: 4096,\n        memoryUsage: 4 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // Transformer Blocks\n    for(let i = 0; i < 32; i++){\n        const attnId = \"attn_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId = \"norm_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 4 * 4096 * 4096,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 4096 * 11008,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"RMSNorm \".concat(i),\n            params: 4096,\n            flops: 4096,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 4096 * 32000,\n        flops: 4096 * 32000,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateDefaultArchitecture() {\n    return generateResNetArchitecture();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC1hcmNoaXRlY3R1cmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OFBBSU8sU0FBU0E7SUFDZCxNQUFNQyxRQUFRO1FBQ1o7WUFDRUMsSUFBSTtZQUNKQyxNQUFNO1lBQ05DLE1BQU07WUFDTkMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLGFBQWEsT0FBTztRQUN0QjtLQUNEO0lBRUQsTUFBTUMsUUFBUSxFQUFFO0lBQ2hCLElBQUlDLFNBQVM7SUFFYixzQkFBc0I7SUFDdEJSLE1BQU1TLElBQUksQ0FBQztRQUNUUixJQUFJO1FBQ0pDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsYUFBYSxJQUFJLE9BQU87SUFDMUI7SUFDQUMsTUFBTUUsSUFBSSxDQUFDO1FBQUVDLFFBQVFGO1FBQVFHLFFBQVE7SUFBUTtJQUM3Q0gsU0FBUztJQUVULGdCQUFnQjtJQUNoQixNQUFNSSxTQUFTO1FBQUM7UUFBSztRQUFLO1FBQUs7S0FBSTtJQUNuQ0EsT0FBT0MsT0FBTyxDQUFDLENBQUNDLE9BQU9DO1FBQ3JCLHlDQUF5QztRQUN6QyxJQUFLLElBQUlDLE9BQU8sR0FBR0EsT0FBTyxHQUFHQSxPQUFRO1lBQ25DLE1BQU1DLFVBQVUsTUFBZUQsT0FBVEYsT0FBTSxLQUFRLE9BQUxFO1lBQy9CaEIsTUFBTVMsSUFBSSxDQUFDO2dCQUNUUixJQUFJZ0I7Z0JBQ0pmLE1BQU07Z0JBQ05DLE1BQU0sWUFBcUJhLE9BQVRGLE9BQU0sS0FBUSxPQUFMRTtnQkFDM0JaLFFBQVEsT0FBTyxPQUFRVyxDQUFBQSxJQUFJO2dCQUMzQlYsT0FBTyxJQUFJLE9BQU8sT0FBUVUsQ0FBQUEsSUFBSTtnQkFDOUJULGFBQWEsSUFBSSxPQUFPLE9BQVFTLENBQUFBLElBQUk7WUFDdEM7WUFDQVIsTUFBTUUsSUFBSSxDQUFDO2dCQUFFQyxRQUFRRjtnQkFBUUcsUUFBUU07WUFBUTtZQUM3Q1QsU0FBU1M7UUFDWDtJ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T1osUUFBUVU7UUFBTztRQUMzQ2IsU0FBU2E7SUFDWDtJQUVBckIsTUFBTVMsSUFBSSxDQUFDO1FBQ1RSLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFFBQVEsT0FBTztRQUNmQyxPQUFPLE9BQU87UUFDZEMsYUFBYSxJQUFJLE9BQU87SUFDMUI7SUFDQUMsTUFBTUUsSUFBSSxDQUFDO1FBQUVDLFFBQVFGO1FBQVFHLFFBQVE7SUFBUztJQUU5QyxPQUFPO1FBQUVYO1FBQU9PO0lBQU07QUFDeEI7QUFFTyxTQUFTK0I7SUFDZCxPQUFPdkM7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9kZWwtYXJjaGl0ZWN0dXJlcy50cz84ZTBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBNb2RlbEFyY2hpdGVjdHVyZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gSW5pdGlhbCBjb252b2x1dGlvblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ2NvbnYxJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnQ29udjEnLFxuICAgIHBhcmFtczogOTQwOCxcbiAgICBmbG9wczogMTE4MDEzOTUyLFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnY29udjEnIH0pO1xuICBwcmV2SWQgPSAnY29udjEnO1xuXG4gIC8vIFJlc05ldCBibG9ja3NcbiAgY29uc3QgYmxvY2tzID0gWycyJywgJzMnLCAnNCcsICc1J107XG4gIGJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgIC8vIEVhY2ggYmxvY2sgaGFzIG11bHRpcGxlIHJlc2lkdWFsIHVuaXRzXG4gICAgZm9yIChsZXQgdW5pdCA9IDA7IHVuaXQgPCAzOyB1bml0KyspIHtcbiAgICAgIGNvbnN0IGJsb2NrSWQgPSBgcmVzJHtibG9ja31fJHt1bml0fWA7XG4gICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGJsb2NrSWQsXG4gICAgICAgIHR5cGU6ICdyZXNpZHVhbCcsXG4gICAgICAgIG5hbWU6IGBSZXNCbG9jayAke2Jsb2NrfS4ke3VuaXR9YCxcbiAgICAgICAgcGFyYW1zOiAxMDI0ICogMTAyNCAqIChpICsgMSksXG4gICAgICAgIGZsb3BzOiA1ICogMTAyNCAqIDEwMjQgKiAoaSArIDEpLFxuICAgICAgICBtZW1vcnlVc2FnZTogMyAqIDEwMjQgKiAxMDI0ICogKGkgKyAxKVxuICAgICAgfSk7XG4gICAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYmxvY2tJZCB9KTtcbiAgICAgIHByZXZJZCA9IGJsb2NrSWQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBGaW5hbCBsYXllcnNcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdwb29sJyxcbiAgICB0eXBlOiAnbWxwJyxcbiAgICBuYW1lOiAnR2xvYmFsIFBvb2wnLFxuICAgIHBhcmFtczogMjA0OCxcbiAgICBmbG9wczogMjA0OCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDUxMlxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwb29sJyB9KTtcblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0ZDIDEwMDAnLFxuICAgIHBhcmFtczogMjA0ODAwMCxcbiAgICBmbG9wczogMjA0ODAwMCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6ICdwb29sJywgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIEVuY29kZXIgbGF5ZXJzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgY29uc3QgYXR0ZW50aW9uSWQgPSBgZW5jX2F0dG5fJHtpfWA7XG4gICAgY29uc3QgZmZuSWQgPSBgZW5jX2Zmbl8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgZW5jX25vcm1fJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRlbnRpb25JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYEVuY29kZXIgU2VsZi1BdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogZmZuSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIEZGTiAke2l9YCxcbiAgICAgIHBhcmFtczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDMyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gJHtpfWAsXG4gICAgICBwYXJhbXM6IDEwMjQsXG4gICAgICBmbG9wczogMjA0OCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogNjRcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRlbnRpb25JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRlbnRpb25JZCwgdGFyZ2V0OiBmZm5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBmZm5JZCwgdGFyZ2V0OiBub3JtSWQgfSk7XG4gICAgcHJldklkID0gbm9ybUlkO1xuICB9XG5cbiAgLy8gT3V0cHV0IHByb2plY3Rpb25cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgUHJvamVjdGlvbicsXG4gICAgcGFyYW1zOiAxMDI0ICogMTAyNCxcbiAgICBmbG9wczogMiAqIDEwMjQgKiAxMDI0LFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFBhdGNoIGVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ3BhdGNoX2VtYmVkJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDU5MDU5MixcbiAgICBmbG9wczogNDcxODU5MjAsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwYXRjaF9lbWJlZCcgfSk7XG4gIHByZXZJZCA9ICdwYXRjaF9lbWJlZCc7XG5cbiAgLy8gVHJhbnNmb3JtZXIgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIGNvbnN0IGF0dGVudGlvbklkID0gYHRyYW5zZm9ybWVyXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dGVudGlvbklkLFxuICAgICAgdHlwZTogJ3RyYW5zZm9ybWVyJyxcbiAgICAgIG5hbWU6IGBUcmFuc2Zvcm1lciBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogNyAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDI4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTQgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbWxwSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBNTFAgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dGVudGlvbklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dGVudGlvbklkLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIHByZXZJZCA9IG1scElkO1xuICB9XG5cbiAgLy8gQ2xhc3NpZmljYXRpb24gaGVhZFxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0NsYXNzaWZpY2F0aW9uIEhlYWQnLFxuICAgIHBhcmFtczogNzY4MDAwLFxuICAgIGZsb3BzOiA3NjgwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiA3NjhcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IExheWVyJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0ICAvLyAxTUIgZm9yIGlucHV0IHRlbnNvclxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBCYWNrYm9uZTogQ1NQRGFya25ldFxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IGNvbnZJZCA9IGBjb252XyR7aX1gO1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGNvbnZJZCxcbiAgICAgIHR5cGU6ICdjbm4nLFxuICAgICAgbmFtZTogYENvbnYgQmxvY2sgJHtpICsgMX1gLFxuICAgICAgcGFyYW1zOiA2NCAqIE1hdGgucG93KDIsIGkpICogMyAqIDMsICAvLyBSZWFsaXN0aWMgcGFyYW1ldGVyIGNvdW50XG4gICAgICBmbG9wczogNjQgKiBNYXRoLnBvdygyLCBpKSAqIDMgKiAzICogNTEyICogNTEyIC8gTWF0aC5wb3coMiwgaSksXG4gICAgICBtZW1vcnlVc2FnZTogNTEyICogNTEyICogNjQgKiBNYXRoLnBvdygyLCBpKSAvIE1hdGgucG93KDIsIGkpICogNCAgLy8gNCBieXRlcyBwZXIgZmxvYXRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogY29udklkIH0pO1xuICAgIHByZXZJZCA9IGNvbnZJZDtcbiAgfVxuXG4gIC8vIEZlYXR1cmUgUHlyYW1pZCBOZXR3b3JrIChGUE4pXG4gIGNvbnN0IGZwbkxheWVycyA9IFsnUDUnLCAnUDQnLCAnUDMnXTtcbiAgZnBuTGF5ZXJzLmZvckVhY2goKGxheWVyLCBpKSA9PiB7XG4gICAgY29uc3QgZnBuSWQgPSBgZnBuXyR7bGF5ZXJ9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBmcG5JZCxcbiAgICAgIHR5cGU6ICdncmFwaCcsXG4gICAgICBuYW1lOiBgRlBOICR7bGF5ZXJ9YCxcbiAgICAgIHBhcmFtczogMjU2ICogMjU2ICogMyxcbiAgICAgIGZsb3BzOiAyNTYgKiAyNTYgKiAzICogODAgKiA4MCAvIE1hdGgucG93KDIsIGkpLFxuICAgICAgbWVtb3J5VXNhZ2U6IDI1NiAqIDgwICogODAgLyBNYXRoLnBvdygyLCBpKSAqIDRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogZnBuSWQgfSk7XG4gICAgcHJldklkID0gZnBuSWQ7XG4gIH0pO1xuXG4gIC8vIERldGVjdGlvbiBIZWFkc1xuICBbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddLmZvckVhY2goKHNpemUsIGkpID0+IHtcbiAgICBjb25zdCBoZWFkSWQgPSBgaGVhZF8ke3NpemV9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBoZWFkSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBEZXRlY3Rpb24gSGVhZCAoJHtzaXplfSlgLFxuICAgICAgcGFyYW1zOiAyNTYgKiAoODAgKyA0ICsgMSksICAvLyBjbGFzc2VzICsgYmJveCArIG9iamVjdG5lc3NcbiAgICAgIGZsb3BzOiAyNTYgKiAoODAgKyA0ICsgMSkgKiA4MCAqIDgwIC8gTWF0aC5wb3coMiwgaSksXG4gICAgICBtZW1vcnlVc2FnZTogKDgwICsgNCArIDEpICogODAgKiA4MCAvIE1hdGgucG93KDIsIGkpICogNFxuICAgIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGBmcG5fJHtmcG5MYXllcnNbaV19YCwgdGFyZ2V0OiBoZWFkSWQgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG4vLyBTdGFibGUgRGlmZnVzaW9uXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gQWRkIFVOZXQgRW5jb2RlciBibG9ja3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBlbmNvZGVySWQgPSBgZW5jb2Rlcl8ke2l9YDtcbiAgICBjb25zdCBhdHRuSWQgPSBgZW5jb2Rlcl9hdHRuXyR7aX1gO1xuICAgIFxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGVuY29kZXJJZCxcbiAgICAgIHR5cGU6ICdyZXNpZHVhbCcsXG4gICAgICBuYW1lOiBgVU5ldCBFbmNvZGVyICR7aX1gLFxuICAgICAgcGFyYW1zOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBmbG9wczogMzIgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxNiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBDcm9zcyBBdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGVuY29kZXJJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBlbmNvZGVySWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIHByZXZJZCA9IGF0dG5JZDtcbiAgfVxuXG4gIC8vIEFkZCBVTmV0IERlY29kZXIgYmxvY2tzIHdpdGggc2tpcCBjb25uZWN0aW9uc1xuICBmb3IgKGxldCBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBkZWNvZGVySWQgPSBgZGVjb2Rlcl8ke2l9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBkZWNvZGVySWQsXG4gICAgICB0eXBlOiAncmVzaWR1YWwnLFxuICAgICAgbmFtZTogYFVOZXQgRGVjb2RlciAke2l9YCxcbiAgICAgIHBhcmFtczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDMyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBkZWNvZGVySWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYGVuY29kZXJfYXR0bl8ke2l9YCwgdGFyZ2V0OiBkZWNvZGVySWQgfSk7IC8vIFNraXAgY29ubmVjdGlvblxuICAgIHByZXZJZCA9IGRlY29kZXJJZDtcbiAgfVxuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDEwMjQgKiAxMDI0LFxuICAgIGZsb3BzOiAyICogMTAyNCAqIDEwMjQsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbi8vIExsYW1hIDJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSgpOiBNb2RlbEFyY2hpdGVjdHVyZSB7XG4gIGNvbnN0IG5vZGVzID0gW1xuICAgIHtcbiAgICAgIGlkOiAnaW5wdXQnLFxuICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgIG5hbWU6ICdJbnB1dCBMYXllcicsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBUb2tlbiBFbWJlZGRpbmdcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdlbWJlZGRpbmcnLFxuICAgIHR5cGU6ICdlbWJlZGRpbmcnLFxuICAgIG5hbWU6ICdUb2tlbiBFbWJlZGRpbmcnLFxuICAgIHBhcmFtczogMzIwMDAgKiA0MDk2LFxuICAgIGZsb3BzOiA0MDk2LFxuICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnZW1iZWRkaW5nJyB9KTtcbiAgcHJldklkID0gJ2VtYmVkZGluZyc7XG5cbiAgLy8gVHJhbnNmb3JtZXIgQmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGNvbnN0IGF0dG5JZCA9IGBhdHRuXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgbm9ybV8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dG5JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYFNlbGYtQXR0ZW50aW9uICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogNDA5NiAqIDQwOTYsXG4gICAgICBmbG9wczogMTYgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA4ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG1scElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgTUxQIEJsb2NrICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogNDA5NiAqIDExMDA4LFxuICAgICAgZmxvcHM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZCxcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBSTVNOb3JtICR7aX1gLFxuICAgICAgcGFyYW1zOiA0MDk2LFxuICAgICAgZmxvcHM6IDQwOTYsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDY0XG4gICAgfSk7XG5cbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dG5JZCwgdGFyZ2V0OiBtbHBJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBtbHBJZCwgdGFyZ2V0OiBub3JtSWQgfSk7XG4gICAgcHJldklkID0gbm9ybUlkO1xuICB9XG5cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgTGF5ZXInLFxuICAgIHBhcmFtczogNDA5NiAqIDMyMDAwLFxuICAgIGZsb3BzOiA0MDk2ICogMzIwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEZWZhdWx0QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgcmV0dXJuIGdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlKCk7XG59Il0sIm5hbWVzIjpbImdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlIiwibm9kZXMiLCJpZCIsInR5cGUiLCJuYW1lIiwicGFyYW1zIiwiZmxvcHMiLCJtZW1vcnlVc2FnZSIsImVkZ2VzIiwicHJldklkIiwicHVzaCIsInNvdXJjZSIsInRhcmdldCIsImJsb2NrcyIsImZvckVhY2giLCJibG9jayIsImkiLCJ1bml0IiwiYmxvY2tJZCIsImdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUiLCJhdHRlbnRpb25JZCIsImZmbklkIiwibm9ybUlkIiwiZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUiLCJtbHBJZCIsImdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlIiwiY29udklkIiwiTWF0aCIsInBvdyIsImZwbkxheWVycyIsImxheWVyIiwiZnBuSWQiLCJzaXplIiwiaGVhZElkIiwiZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUiLCJlbmNvZGVySWQiLCJhdHRuSWQiLCJkZWNvZGVySWQiLCJnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlRGVmYXVsdEFyY2hpdGVjdHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model-architectures.ts\n"));

/***/ })

});