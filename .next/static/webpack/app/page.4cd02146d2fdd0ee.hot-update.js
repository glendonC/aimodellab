"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/performance.ts":
/*!**********************************!*\
  !*** ./lib/model/performance.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceCalculator: function() { return /* binding */ PerformanceCalculator; }\n/* harmony export */ });\n// Polars-like DataFrame implementation for browser\nclass DataFrame {\n    select(column) {\n        if (!this.data.length) {\n            return {\n                sum: ()=>0,\n                mean: ()=>0\n            };\n        }\n        return {\n            sum: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0),\n            mean: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0) / this.data.length\n        };\n    }\n    static fromRecords(records) {\n        return new DataFrame(records || []);\n    }\n    constructor(data){\n        this.data = data || []; // Ensure data is never undefined\n    }\n}\nclass PerformanceCalculator {\n    calculateWithPolars(analysisResult) {\n        const { metadata, layers = [] } = analysisResult.graph || {};\n        // Create DataFrame with layer metrics and handle missing data\n        const df = DataFrame.fromRecords(layers);\n        // Calculate aggregated metrics with safe fallbacks\n        const metrics = {\n            totalFlops: df.select(\"flops\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) || 0,\n            meanFlops: df.select(\"flops\").mean(),\n            totalMemory: df.select(\"memory\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0,\n            paramsPerLayer: df.select(\"parameters\").mean()\n        };\n        // Calculate CPU performance metrics with safe values\n        return {\n            fps: Math.min(120, 1000 / Math.max(1, metrics.totalFlops / 1e9)),\n            latency: Math.max(0.5, metrics.totalFlops / 1e9 * 2),\n            memory: Math.max(0.1, metrics.totalMemory / (1024 * 1024 * 1024)),\n            utilization: Math.min(95, metrics.totalFlops / 1e9 * 0.45)\n        };\n    }\n    getModelCharacteristics(modelId, totalFlops) {\n        var _modelId_toLowerCase;\n        const id = (_modelId_toLowerCase = modelId === null || modelId === void 0 ? void 0 : modelId.toLowerCase()) !== null && _modelId_toLowerCase !== void 0 ? _modelId_toLowerCase : \"default\";\n        const batchSize = 16; // Default batch size\n        if (id.includes(\"yolo\")) {\n            return {\n                type: \"detection\",\n                batchSize,\n                baseUtilization: this.GPU_SPECS.baselineUtilization.detection,\n                speedupFactor: 3.5,\n                memoryEfficiency: 0.7,\n                tensorCoreUsage: Math.min(85, totalFlops / 1e12 * 40),\n                features: [\n                    \"INT8 Quantization\",\n                    \"CUDA Graph Acceleration\",\n                    \"TensorRT Optimizations\"\n                ]\n            };\n        }\n        if (id.includes(\"stable\")) {\n            return {\n                type: \"generation\",\n                batchSize: 1,\n                baseUtilization: this.GPU_SPECS.baselineUtilization.generation,\n                speedupFactor: 2.2,\n                memoryEfficiency: 0.85,\n                tensorCoreUsage: Math.min(90, totalFlops / 1e12 * 50),\n                features: [\n                    \"FP16 Mixed Precision\",\n                    \"Attention Optimization\",\n                    \"Memory Pooling\"\n                ]\n            };\n        }\n        if (id.includes(\"llama\") || id.includes(\"gpt\")) {\n            return {\n                type: \"transformer\",\n                batchSize: 8,\n                baseUtilization: this.GPU_SPECS.baselineUtilization.transformer,\n                speedupFactor: 2.8,\n                memoryEfficiency: 0.8,\n                tensorCoreUsage: Math.min(88, totalFlops / 1e12 * 45),\n                features: [\n                    \"FP16 Inference\",\n                    \"KV Cache Optimization\",\n                    \"Dynamic Batching\"\n                ]\n            };\n        }\n        // Default CNN characteristics\n        return {\n            type: \"cnn\",\n            batchSize,\n            baseUtilization: this.GPU_SPECS.baselineUtilization.cnn,\n            speedupFactor: 4.0,\n            memoryEfficiency: 0.65,\n            tensorCoreUsage: Math.min(75, totalFlops / 1e12 * 35),\n            features: [\n                \"TensorRT Inference\",\n                \"Kernel Fusion\",\n                \"Layer Optimization\"\n            ]\n        };\n    }\n    calculateMetrics(analysisResult, gpuEnabled) {\n        if (!(analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.graph)) {\n            return this.getDefaultMetrics();\n        }\n        const { totalFlops = 0, totalMemory = 0, modelId } = analysisResult.graph.metadata;\n        const modelCharacteristics = this.getModelCharacteristics(modelId, totalFlops);\n        // Calculate base CPU metrics\n        const cpuMetrics = {\n            fps: Math.min(60, 1000 / Math.max(1, totalFlops / 1e9 * 2)),\n            latency: Math.max(1.0, totalFlops / 1e9 * 2.5),\n            memory: Math.max(0.2, totalMemory / (1024 * 1024 * 1024) * 1.2),\n            utilization: Math.min(98, totalFlops / 1e9 * 0.6)\n        };\n        if (!gpuEnabled) {\n            return {\n                cpuMetrics,\n                gpuMetrics: cpuMetrics,\n                nvOptimizations: null\n            };\n        }\n        // Calculate realistic GPU metrics\n        const gpuMetrics = {\n            fps: Math.min(1000, cpuMetrics.fps * modelCharacteristics.speedupFactor * modelCharacteristics.batchSize),\n            latency: Math.max(0.1, cpuMetrics.latency / modelCharacteristics.speedupFactor),\n            memory: cpuMetrics.memory * modelCharacteristics.memoryEfficiency,\n            utilization: Math.min(95, modelCharacteristics.baseUtilization * (totalFlops / 1e12))\n        };\n        // Calculate memory bandwidth based on utilization and model type\n        const memoryBandwidth = gpuMetrics.utilization / 100 * (this.GPU_SPECS.memoryBandwidth * modelCharacteristics.memoryEfficiency);\n        const nvOptimizations = {\n            tensorCoreUsage: \"\".concat(modelCharacteristics.tensorCoreUsage.toFixed(1), \"%\"),\n            memoryBandwidth: \"\".concat((memoryBandwidth / 1000).toFixed(1), \" TB/s\"),\n            speedup: \"\".concat(modelCharacteristics.speedupFactor.toFixed(1), \"x\"),\n            batchSize: modelCharacteristics.batchSize,\n            features: modelCharacteristics.features\n        };\n        return {\n            cpuMetrics,\n            gpuMetrics,\n            nvOptimizations\n        };\n    }\n    getDefaultMetrics() {\n        const defaultMetrics = {\n            fps: 0,\n            latency: 0,\n            memory: 0,\n            utilization: 0\n        };\n        return {\n            cpuMetrics: defaultMetrics,\n            gpuMetrics: defaultMetrics,\n            nvOptimizations: null\n        };\n    }\n    constructor(){\n        this.GPU_SPECS = {\n            peakTflops: 312,\n            memoryBandwidth: 2048,\n            tensorCores: 432,\n            maxBatchSize: 32,\n            // Add realistic baseline metrics\n            baselineUtilization: {\n                cnn: 25,\n                transformer: 45,\n                detection: 35,\n                generation: 65 // Stable Diffusion etc\n            }\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsbURBQW1EO0FBQ25ELE1BQU1BO0lBT0pDLE9BQU9DLE1BQTBCLEVBQUU7UUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxNQUFNLEVBQUU7WUFDckIsT0FBTztnQkFDTEMsS0FBSyxJQUFNO2dCQUNYQyxNQUFNLElBQU07WUFDZDtRQUNGO1FBRUEsT0FBTztZQUNMRCxLQUFLLElBQU0sSUFBSSxDQUFDRixJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJO1lBQ3BFSSxNQUFNLElBQU0sSUFBSSxDQUFDSCxJQUFJLENBQUNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFPQyxDQUFBQSxHQUFHLENBQUNQLE9BQU8sSUFBSSxJQUFJLEtBQUssSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU07UUFDNUY7SUFDRjtJQUVBLE9BQU9NLFlBQVlDLE9BQW1DLEVBQUU7UUFDdEQsT0FBTyxJQUFJWCxVQUFVVyxXQUFXLEVBQUU7SUFDcEM7SUFwQkFDLFlBQVlULElBQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxJQUFJLEdBQUdBLFFBQVEsRUFBRSxFQUFHLGlDQUFpQztJQUM1RDtBQW1CRjtBQUVPLE1BQU1VO0lBZUhDLG9CQUFvQkMsY0FBOEIsRUFBRTtRQUMxRCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEVBQUUsR0FBR0YsZUFBZUcsS0FBSyxJQUFJLENBQUM7UUFFM0QsOERBQThEO1FBQzlELE1BQU1DLEtBQUtuQixVQUFVVSxXQUFXLENBQUNPO1FBRWpDLG1EQUFtRDtRQUNuRCxNQUFNRyxVQUFVO1lBQ2RDLFlBQVlGLEdBQUdsQixNQUFNLENBQUMsU0FBU0ksR0FBRyxPQUFNVyxxQkFBQUEsK0JBQUFBLFNBQVVL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Q0Esa0JBQWtCLElBQUcsRUFBR0MsT0FBTyxDQUFDLElBQUc7WUFDeERDLFNBQVMsR0FBaUQsT0FBOUNOLHFCQUFxQlYsYUFBYSxDQUFDZSxPQUFPLENBQUMsSUFBRztZQUMxRHRCLFdBQVdpQixxQkFBcUJqQixTQUFTO1lBQ3pDVSxVQUFVTyxxQkFBcUJQLFFBQVE7UUFDekM7UUFFQSxPQUFPO1lBQUVRO1lBQVlDO1lBQVlDO1FBQWdCO0lBQ25EO0lBRVFKLG9CQUFvQjtRQUMxQixNQUFNUSxpQkFBaUI7WUFDckJuQyxLQUFLO1lBQ0xJLFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxhQUFhO1FBQ2Y7UUFDQSxPQUFPO1lBQ0x1QixZQUFZTTtZQUNaTCxZQUFZSztZQUNaSixpQkFBaUI7UUFDbkI7SUFDRjs7YUFoS2lCaEIsWUFBWTtZQUMzQnFCLFlBQVk7WUFDWkosaUJBQWlCO1lBQ2pCSyxhQUFhO1lBQ2JDLGNBQWM7WUFDZCxpQ0FBaUM7WUFDakN0QixxQkFBcUI7Z0JBQ25CUSxLQUFLO2dCQUNMRCxhQUFhO2dCQUNiTixXQUFXO2dCQUNYSyxZQUFZLEdBQUksdUJBQXVCO1lBQ3pDO1FBQ0Y7O0FBcUpGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cz9kYjU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQW5hbHlzaXNSZXN1bHQsIExheWVyTWV0cmljcyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBQb2xhcnMtbGlrZSBEYXRhRnJhbWUgaW1wbGVtZW50YXRpb24gZm9yIGJyb3dzZXJcbmNsYXNzIERhdGFGcmFtZSB7XG4gIHByaXZhdGUgZGF0YTogTGF5ZXJNZXRyaWNzW107XG5cbiAgY29uc3RydWN0b3IoZGF0YTogTGF5ZXJNZXRyaWNzW10pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IFtdOyAgLy8gRW5zdXJlIGRhdGEgaXMgbmV2ZXIgdW5kZWZpbmVkXG4gIH1cblxuICBzZWxlY3QoY29sdW1uOiBrZXlvZiBMYXllck1ldHJpY3MpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1bTogKCkgPT4gMCxcbiAgICAgICAgbWVhbjogKCkgPT4gMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3VtOiAoKSA9PiB0aGlzLmRhdGEucmVkdWNlKChhY2MsIHJvdykgPT4gYWNjICsgKHJvd1tjb2x1bW5dIHx8IDApLCAwKSxcbiAgICAgIG1lYW46ICgpID0+IHRoaXMuZGF0YS5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgKyAocm93W2NvbHVtbl0gfHwgMCksIDApIC8gdGhpcy5kYXRhLmxlbmd0aFxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZnJvbVJlY29yZHMocmVjb3JkczogTGF5ZXJNZXRyaWNzW10gfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IERhdGFGcmFtZShyZWNvcmRzIHx8IFtdKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VDYWxjdWxhdG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBHUFVfU1BFQ1MgPSB7XG4gICAgcGVha1RmbG9wczogMzEyLCAgICAgICAgICAvLyBBMTAwIEZQMTZcbiAgICBtZW1vcnlCYW5kd2lkdGg6IDIwNDgsICAgIC8vIEdCL3NcbiAgICB0ZW5zb3JDb3JlczogNDMyLFxuICAgIG1heEJhdGNoU2l6ZTogMzIsXG4gICAgLy8gQWRkIHJlYWxpc3RpYyBiYXNlbGluZSBtZXRyaWNzXG4gICAgYmFzZWxpbmVVdGlsaXphdGlvbjoge1xuICAgICAgY25uOiAyNSwgICAgICAgIC8vIEVmZmljaWVudCBDTk5zXG4gICAgICB0cmFuc2Zvcm1lcjogNDUsIC8vIFRyYW5zZm9ybWVyIG1vZGVsc1xuICAgICAgZGV0ZWN0aW9uOiAzNSwgIC8vIFlPTE8gZXRjXG4gICAgICBnZW5lcmF0aW9uOiA2NSAgLy8gU3RhYmxlIERpZmZ1c2lvbiBldGNcbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVXaXRoUG9sYXJzKGFuYWx5c2lzUmVzdWx0OiBBbmFseXNpc1Jlc3VsdCkge1xuICAgIGNvbnN0IHsgbWV0YWRhdGEsIGxheWVycyA9IFtdIH0gPSBhbmFseXNpc1Jlc3VsdC5ncmFwaCB8fCB7fTtcbiAgICBcbiAgICAvLyBDcmVhdGUgRGF0YUZyYW1lIHdpdGggbGF5ZXIgbWV0cmljcyBhbmQgaGFuZGxlIG1pc3NpbmcgZGF0YVxuICAgIGNvbnN0IGRmID0gRGF0YUZyYW1lLmZyb21SZWNvcmRzKGxheWVycyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgYWdncmVnYXRlZCBtZXRyaWNzIHdpdGggc2FmZSBmYWxsYmFja3NcbiAgICBjb25zdCBtZXRyaWNzID0ge1xuICAgICAgdG90YWxGbG9wczogZGYuc2VsZWN0KCdmbG9wcycpLnN1bSgpIHx8IG1ldGFkYXRhPy50b3RhbEZsb3BzIHx8IDAsXG4gICAgICBtZWFuRmxvcHM6IGRmLnNlbGVjdCgnZmxvcHMnKS5tZWFuKCksXG4gICAgICB0b3RhbE1lbW9yeTogZGYuc2VsZWN0KCdtZW1vcnknKS5zdW0oKSB8fCBtZXRhZGF0YT8udG90YWxNZW1vcnkgfHwgMCxcbiAgICAgIHBhcmFtc1BlckxheWVyOiBkZi5zZWxlY3QoJ3BhcmFtZXRlcnMnKS5tZWFuKClcbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIENQVSBwZXJmb3JtYW5jZSBtZXRyaWNzIHdpdGggc2FmZSB2YWx1ZXNcbiAgICByZXR1cm4ge1xuICAgICAgZnBzOiBNYXRoLm1pbigxMjAsIDEwMDAgLyBNYXRoLm1heCgxLCBtZXRyaWNzLnRvdGFsRmxvcHMgLyAxZTkpKSxcbiAgICAgIGxhdGVuY3k6IE1hdGgubWF4KDAuNSwgKG1ldHJpY3MudG90YWxGbG9wcyAvIDFlOSkgKiAyKSxcbiAgICAgIG1lbW9yeTogTWF0aC5tYXgoMC4xLCBtZXRyaWNzLnRvdGFsTWVtb3J5IC8gKDEwMjQgKiAxMDI0ICogMTAyNCkpLFxuICAgICAgdXRpbGl6YXRpb246IE1hdGgubWluKDk1LCAobWV0cmljcy50b3RhbEZsb3BzIC8gMWU5KSAqIDAuNDUpXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TW9kZWxDaGFyYWN0ZXJpc3RpY3MobW9kZWxJZDogc3RyaW5nIHwgdW5kZWZpbmVkLCB0b3RhbEZsb3BzOiBudW1iZXIpIHtcbiAgICBjb25zdCBpZCA9IG1vZGVsSWQ/LnRvTG93ZXJDYXNlKCkgPz8gJ2RlZmF1bHQnO1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IDE2OyAvLyBEZWZhdWx0IGJhdGNoIHNpemVcblxuICAgIGlmIChpZC5pbmNsdWRlcygneW9sbycpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGV0ZWN0aW9uJyxcbiAgICAgICAgYmF0Y2hTaXplLFxuICAgICAgICBiYXNlVXRpbGl6YXRpb246IHRoaXMuR1BVX1NQRUNTLmJhc2VsaW5lVXRpbGl6YXRpb24uZGV0ZWN0aW9uLFxuICAgICAgICBzcGVlZHVwRmFjdG9yOiAzLjUsXG4gICAgICAgIG1lbW9yeUVmZmljaWVuY3k6IDAuNyxcbiAgICAgICAgdGVuc29yQ29yZVVzYWdlOiBNYXRoLm1pbig4NSwgKHRvdGFsRmxvcHMgLyAxZTEyKSAqIDQwKSxcbiAgICAgICAgZmVhdHVyZXM6IFtcbiAgICAgICAgICAnSU5UOCBRdWFudGl6YXRpb24nLFxuICAgICAgICAgICdDVURBIEdyYXBoIEFjY2VsZXJhdGlvbicsXG4gICAgICAgICAgJ1RlbnNvclJUIE9wdGltaXphdGlvbnMnXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGlkLmluY2x1ZGVzKCdzdGFibGUnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2dlbmVyYXRpb24nLFxuICAgICAgICBiYXRjaFNpemU6IDEsIC8vIFR5cGljYWxseSBydW4gb25lIGF0IGEgdGltZVxuICAgICAgICBiYXNlVXRpbGl6YXRpb246IHRoaXMuR1BVX1NQRUNTLmJhc2VsaW5lVXRpbGl6YXRpb24uZ2VuZXJhdGlvbixcbiAgICAgICAgc3BlZWR1cEZhY3RvcjogMi4yLFxuICAgICAgICBtZW1vcnlFZmZpY2llbmN5OiAwLjg1LFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IE1hdGgubWluKDkwLCAodG90YWxGbG9wcyAvIDFlMTIpICogNTApLFxuICAgICAgICBmZWF0dXJlczogW1xuICAgICAgICAgICdGUDE2IE1peGVkIFByZWNpc2lvbicsXG4gICAgICAgICAgJ0F0dGVudGlvbiBPcHRpbWl6YXRpb24nLFxuICAgICAgICAgICdNZW1vcnkgUG9vbGluZydcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaWQuaW5jbHVkZXMoJ2xsYW1hJykgfHwgaWQuaW5jbHVkZXMoJ2dwdCcpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndHJhbnNmb3JtZXInLFxuICAgICAgICBiYXRjaFNpemU6IDgsXG4gICAgICAgIGJhc2VVdGlsaXphdGlvbjogdGhpcy5HUFVfU1BFQ1MuYmFzZWxpbmVVdGlsaXphdGlvbi50cmFuc2Zvcm1lcixcbiAgICAgICAgc3BlZWR1cEZhY3RvcjogMi44LFxuICAgICAgICBtZW1vcnlFZmZpY2llbmN5OiAwLjgsXG4gICAgICAgIHRlbnNvckNvcmVVc2FnZTogTWF0aC5taW4oODgsICh0b3RhbEZsb3BzIC8gMWUxMikgKiA0NSksXG4gICAgICAgIGZlYXR1cmVzOiBbXG4gICAgICAgICAgJ0ZQMTYgSW5mZXJlbmNlJyxcbiAgICAgICAgICAnS1YgQ2FjaGUgT3B0aW1pemF0aW9uJyxcbiAgICAgICAgICAnRHluYW1pYyBCYXRjaGluZydcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IENOTiBjaGFyYWN0ZXJpc3RpY3NcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2NubicsXG4gICAgICBiYXRjaFNpemUsXG4gICAgICBiYXNlVXRpbGl6YXRpb246IHRoaXMuR1BVX1NQRUNTLmJhc2VsaW5lVXRpbGl6YXRpb24uY25uLFxuICAgICAgc3BlZWR1cEZhY3RvcjogNC4wLFxuICAgICAgbWVtb3J5RWZmaWNpZW5jeTogMC42NSxcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogTWF0aC5taW4oNzUsICh0b3RhbEZsb3BzIC8gMWUxMikgKiAzNSksXG4gICAgICBmZWF0dXJlczogW1xuICAgICAgICAnVGVuc29yUlQgSW5mZXJlbmNlJyxcbiAgICAgICAgJ0tlcm5lbCBGdXNpb24nLFxuICAgICAgICAnTGF5ZXIgT3B0aW1pemF0aW9uJ1xuICAgICAgXVxuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVNZXRyaWNzKGFuYWx5c2lzUmVzdWx0OiBBbmFseXNpc1Jlc3VsdCB8IG51bGwsIGdwdUVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICBpZiAoIWFuYWx5c2lzUmVzdWx0Py5ncmFwaCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdE1ldHJpY3MoKTtcbiAgICB9XG5cbiAgICBjb25zdCB7IHRvdGFsRmxvcHMgPSAwLCB0b3RhbE1lbW9yeSA9IDAsIG1vZGVsSWQgfSA9IGFuYWx5c2lzUmVzdWx0LmdyYXBoLm1ldGFkYXRhO1xuICAgIGNvbnN0IG1vZGVsQ2hhcmFjdGVyaXN0aWNzID0gdGhpcy5nZXRNb2RlbENoYXJhY3RlcmlzdGljcyhtb2RlbElkLCB0b3RhbEZsb3BzKTtcblxuICAgIC8vIENhbGN1bGF0ZSBiYXNlIENQVSBtZXRyaWNzXG4gICAgY29uc3QgY3B1TWV0cmljcyA9IHtcbiAgICAgIGZwczogTWF0aC5taW4oNjAsIDEwMDAgLyBNYXRoLm1heCgxLCAodG90YWxGbG9wcyAvIDFlOSkgKiAyKSksXG4gICAgICBsYXRlbmN5OiBNYXRoLm1heCgxLjAsICh0b3RhbEZsb3BzIC8gMWU5KSAqIDIuNSksXG4gICAgICBtZW1vcnk6IE1hdGgubWF4KDAuMiwgdG90YWxNZW1vcnkgLyAoMTAyNCAqIDEwMjQgKiAxMDI0KSAqIDEuMiksXG4gICAgICB1dGlsaXphdGlvbjogTWF0aC5taW4oOTgsICh0b3RhbEZsb3BzIC8gMWU5KSAqIDAuNilcbiAgICB9O1xuXG4gICAgaWYgKCFncHVFbmFibGVkKSB7XG4gICAgICByZXR1cm4geyBjcHVNZXRyaWNzLCBncHVNZXRyaWNzOiBjcHVNZXRyaWNzLCBudk9wdGltaXphdGlvbnM6IG51bGwgfTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgcmVhbGlzdGljIEdQVSBtZXRyaWNzXG4gICAgY29uc3QgZ3B1TWV0cmljcyA9IHtcbiAgICAgIGZwczogTWF0aC5taW4oMTAwMCwgY3B1TWV0cmljcy5mcHMgKiBtb2RlbENoYXJhY3RlcmlzdGljcy5zcGVlZHVwRmFjdG9yICogbW9kZWxDaGFyYWN0ZXJpc3RpY3MuYmF0Y2hTaXplKSxcbiAgICAgIGxhdGVuY3k6IE1hdGgubWF4KDAuMSwgY3B1TWV0cmljcy5sYXRlbmN5IC8gbW9kZWxDaGFyYWN0ZXJpc3RpY3Muc3BlZWR1cEZhY3RvciksXG4gICAgICBtZW1vcnk6IGNwdU1ldHJpY3MubWVtb3J5ICogbW9kZWxDaGFyYWN0ZXJpc3RpY3MubWVtb3J5RWZmaWNpZW5jeSxcbiAgICAgIHV0aWxpemF0aW9uOiBNYXRoLm1pbig5NSwgbW9kZWxDaGFyYWN0ZXJpc3RpY3MuYmFzZVV0aWxpemF0aW9uICogKHRvdGFsRmxvcHMgLyAxZTEyKSlcbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIG1lbW9yeSBiYW5kd2lkdGggYmFzZWQgb24gdXRpbGl6YXRpb24gYW5kIG1vZGVsIHR5cGVcbiAgICBjb25zdCBtZW1vcnlCYW5kd2lkdGggPSAoZ3B1TWV0cmljcy51dGlsaXphdGlvbiAvIDEwMCkgKiBcbiAgICAgICh0aGlzLkdQVV9TUEVDUy5tZW1vcnlCYW5kd2lkdGggKiBtb2RlbENoYXJhY3RlcmlzdGljcy5tZW1vcnlFZmZpY2llbmN5KTtcblxuICAgIGNvbnN0IG52T3B0aW1pemF0aW9ucyA9IHtcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogYCR7bW9kZWxDaGFyYWN0ZXJpc3RpY3MudGVuc29yQ29yZVVzYWdlLnRvRml4ZWQoMSl9JWAsXG4gICAgICBtZW1vcnlCYW5kd2lkdGg6IGAkeyhtZW1vcnlCYW5kd2lkdGggLyAxMDAwKS50b0ZpeGVkKDEpfSBUQi9zYCxcbiAgICAgIHNwZWVkdXA6IGAke21vZGVsQ2hhcmFjdGVyaXN0aWNzLnNwZWVkdXBGYWN0b3IudG9GaXhlZCgxKX14YCxcbiAgICAgIGJhdGNoU2l6ZTogbW9kZWxDaGFyYWN0ZXJpc3RpY3MuYmF0Y2hTaXplLFxuICAgICAgZmVhdHVyZXM6IG1vZGVsQ2hhcmFjdGVyaXN0aWNzLmZlYXR1cmVzXG4gICAgfTtcblxuICAgIHJldHVybiB7IGNwdU1ldHJpY3MsIGdwdU1ldHJpY3MsIG52T3B0aW1pemF0aW9ucyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREZWZhdWx0TWV0cmljcygpIHtcbiAgICBjb25zdCBkZWZhdWx0TWV0cmljcyA9IHtcbiAgICAgIGZwczogMCxcbiAgICAgIGxhdGVuY3k6IDAsXG4gICAgICBtZW1vcnk6IDAsXG4gICAgICB1dGlsaXphdGlvbjogMFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNwdU1ldHJpY3M6IGRlZmF1bHRNZXRyaWNzLFxuICAgICAgZ3B1TWV0cmljczogZGVmYXVsdE1ldHJpY3MsXG4gICAgICBudk9wdGltaXphdGlvbnM6IG51bGxcbiAgICB9O1xuICB9XG59ICJdLCJuYW1lcyI6WyJEYXRhRnJhbWUiLCJzZWxlY3QiLCJjb2x1bW4iLCJkYXRhIiwibGVuZ3RoIiwic3VtIiwibWVhbiIsInJlZHVjZSIsImFjYyIsInJvdyIsImZyb21SZWNvcmRzIiwicmVjb3JkcyIsImNvbnN0cnVjdG9yIiwiUGVyZm9ybWFuY2VDYWxjdWxhdG9yIiwiY2FsY3VsYXRlV2l0aFBvbGFycyIsImFuYWx5c2lzUmVzdWx0IiwibWV0YWRhdGEiLCJsYXllcnMiLCJncmFwaCIsImRmIiwibWV0cmljcyIsInRvdGFsRmxvcHMiLCJtZWFuRmxvcHMiLCJ0b3RhbE1lbW9yeSIsInBhcmFtc1BlckxheWVyIiwiZnBzIiwiTWF0aCIsIm1pbiIsIm1heCIsImxhdGVuY3kiLCJtZW1vcnkiLCJ1dGlsaXphdGlvbiIsImdldE1vZGVsQ2hhcmFjdGVyaXN0aWNzIiwibW9kZWxJZCIsImlkIiwidG9Mb3dlckNhc2UiLCJiYXRjaFNpemUiLCJpbmNsdWRlcyIsInR5cGUiLCJiYXNlVXRpbGl6YXRpb24iLCJHUFVfU1BFQ1MiLCJiYXNlbGluZVV0aWxpemF0aW9uIiwiZGV0ZWN0aW9uIiwic3BlZWR1cEZhY3RvciIsIm1lbW9yeUVmZmljaWVuY3kiLCJ0ZW5zb3JDb3JlVXNhZ2UiLCJmZWF0dXJlcyIsImdlbmVyYXRpb24iLCJ0cmFuc2Zvcm1lciIsImNubiIsImNhbGN1bGF0ZU1ldHJpY3MiLCJncHVFbmFibGVkIiwiZ2V0RGVmYXVsdE1ldHJpY3MiLCJtb2RlbENoYXJhY3RlcmlzdGljcyIsImNwdU1ldHJpY3MiLCJncHVNZXRyaWNzIiwibnZPcHRpbWl6YXRpb25zIiwibWVtb3J5QmFuZHdpZHRoIiwidG9GaXhlZCIsInNwZWVkdXAiLCJkZWZhdWx0TWV0cmljcyIsInBlYWtUZmxvcHMiLCJ0ZW5zb3JDb3JlcyIsIm1heEJhdGNoU2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/performance.ts\n"));

/***/ })

});