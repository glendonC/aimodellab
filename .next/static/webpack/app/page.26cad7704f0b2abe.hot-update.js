"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/constants.ts":
/*!********************************!*\
  !*** ./lib/model/constants.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CPU_BENCHMARKS: function() { return /* binding */ CPU_BENCHMARKS; },\n/* harmony export */   NVIDIA_BENCHMARKS: function() { return /* binding */ NVIDIA_BENCHMARKS; }\n/* harmony export */ });\nconst NVIDIA_BENCHMARKS = {\n    resnet50: {\n        a100: {\n            batchSize1: {\n                fps: 615,\n                latency: 1.6,\n                memory: 98,\n                powerDraw: 250 // Watts\n            },\n            batchSize32: {\n                fps: 2480,\n                latency: 12.9,\n                memory: 1205,\n                powerDraw: 315\n            }\n        }\n    }\n};\nconst CPU_BENCHMARKS = {\n    \"xeon-8380\": {\n        resnet50: {\n            batchSize1: {\n                fps: 52,\n                latency: 19.2,\n                memory: 147\n            }\n        }\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9jb25zdGFudHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxNQUFNQSxvQkFBb0I7SUFDL0JDLFVBQVU7UUFDUkMsTUFBTTtZQUNKQyxZQUFZO2dCQUNWQyxLQUFLO2dCQUNMQyxTQUFTO2dCQUNUQyxRQUFRO2dCQUNSQyxXQUFXLElBQU0sUUFBUTtZQUMzQjtZQUNBQyxhQUFhO2dCQUNYSixLQUFLO2dCQUNMQyxTQUFTO2dCQUNUQyxRQUFRO2dCQUNSQyxXQUFXO1lBQ2I7UUFDRjtJQUNGO0FBRUYsRUFBVztBQUVKLE1BQU1FLGlCQUFpQjtJQUM1QixhQUFhO1FBQ1hSLFVBQVU7WUFDUkUsWUFBWTtnQkFDVkMsS0FBSztnQkFDTEMsU0FBUztnQkFDVEMsUUFBUTtZQUNWO1FBQ0Y7SUFFRjtBQUNGLEVBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL21vZGVsL2NvbnN0YW50cy50cz9jN2YxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBOVklESUFfQkVOQ0hNQVJLUyA9IHtcbiAgcmVzbmV0NTA6IHtcbiAgICBhMTAwOiB7XG4gICAgICBiYXRjaFNpemUxOiB7XG4gICAgICAgIGZwczogNjE1LFxuICAgICAgICBsYXRlbmN5OiAxLjYsICAgIC8vIG1zXG4gICAgICAgIG1lbW9yeTogOTgsICAgICAgLy8gTUJcbiAgICAgICAgcG93ZXJEcmF3OiAyNTAgICAvLyBXYXR0c1xuICAgICAgfSxcbiAgICAgIGJhdGNoU2l6ZTMyOiB7XG4gICAgICAgIGZwczogMjQ4MCxcbiAgICAgICAgbGF0ZW5jeTogMTIuOSxcbiAgICAgICAgbWVtb3J5OiAxMjA1LFxuICAgICAgICBwb3dlckRyYXc6IDMxNVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gLi4uIHJlc3Qgb2YgdGhlIGJlbmNobWFya3Ncbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBDUFVfQkVOQ0hNQVJLUyA9IHtcbiAgJ3hlb24tODM4MCc6IHtcbiAgICByZXNuZXQ1MDoge1xuICAgICAgYmF0Y2hTaXplMToge1xuICAgICAgICBmcHM6IDUyLFxuICAgICAgICBsYXRlbmN5OiAxOS4yLFxuICAgICAgICBtZW1vcnk6IDE0N1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gLi4uIHJlc3Qgb2YgdGhlIGJlbmNobWFya3NcbiAgfVxufSBhcyBjb25zdDsgIl0sIm5hbWVzIjpbIk5WSURJQV9CRU5DSE1BUktTIiwicmVzbmV0NTAiLCJhMTAwIiwiYmF0Y2hTaXplMSIsImZwcyIsImxhdGVuY3kiLCJtZW1vcnkiLCJwb3dlckRyYXciLCJiYXRjaFNpemUzMiIsIkNQVV9CRU5DSE1BUktTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/constants.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/model/performance.ts":
/*!**********************************!*\
  !*** ./lib/model/performance.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceCalculator: function() { return /* binding */ PerformanceCalculator; }\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./lib/model/constants.ts\");\n\n// Polars-like DataFrame implementation for browser\nclass DataFrame {\n    select(column) {\n        if (!this.data.length) {\n            return {\n                sum: ()=>0,\n                mean: ()=>0\n            };\n        }\n        return {\n            sum: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0),\n            mean: ()=>this.data.reduce((acc, row)=>acc + (row[column] || 0), 0) / this.data.length\n        };\n    }\n    static fromRecords(records) {\n        return new DataFrame(records || []);\n    }\n    constructor(data){\n        this.data = data || []; // Ensure data is never undefined\n    }\n}\nclass PerformanceCalculator {\n    calculateWithPolars(analysisResult) {\n        const { metadata, layers = [] } = analysisResult.graph || {};\n        try {\n            const df = DataFrame.fromRecords(layers);\n            // Calculate base metrics\n            const totalFlops = df.select(\"flops\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) || 0;\n            const totalMemory = df.select(\"memory\").sum() || (metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0;\n            const paramsPerLayer = df.select(\"parameters\").mean();\n            // Calculate CPU-specific base metrics\n            return {\n                fps: Math.min(60, 1000 / Math.max(1, totalFlops / 1e9)),\n                latency: Math.max(2.0, totalFlops / 1e9 * 3.5),\n                memory: Math.max(1.5, totalMemory / (1024 * 1024 * 1024)),\n                utilization: Math.min(95, Math.max(25, totalFlops / 1e9 * 0.8)),\n                efficiency: totalFlops / (df.select(\"parameters\").sum() || 1),\n                memoryEfficiency: totalMemory / (df.select(\"parameters\").sum() * 4 || 1)\n            };\n        } catch (e) {\n            console.warn(\"Calculations failed, falling back to simple calculations\", e);\n            return {\n                fps: Math.min(30, 1000 / Math.max(1, (metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0)),\n                latency: Math.max(2.0, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0) * 3.5),\n                memory: Math.max(1.5, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalMemory) || 0) / (1024 * 1024 * 1024)),\n                utilization: Math.min(95, ((metadata === null || metadata === void 0 ? void 0 : metadata.totalFlops) / 1e9 || 0) * 0.8),\n                efficiency: 0,\n                memoryEfficiency: 0\n            };\n        }\n    }\n    getModelCharacteristics(modelId, totalFlops, totalMemory) {\n        var _modelId_toLowerCase;\n        const id = (_modelId_toLowerCase = modelId === null || modelId === void 0 ? void 0 : modelId.toLowerCase()) !== null && _modelId_toLowerCase !== void 0 ? _modelId_toLowerCase : \"default\";\n        const flopsInTFlops = totalFlops / 1e12;\n        const memoryInGB = totalMemory / 1024 / 1024 / 1024;\n        // Base characteristics that scale with model size\n        const baseCharacteristics = {\n            minUtilization: Math.max(15, flopsInTFlops * 10),\n            tensorCoreUsage: Math.max(12, flopsInTFlops * 15),\n            memoryBandwidth: Math.max(0.3, flopsInTFlops * 0.5),\n            baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.cnn, memoryInGB * 1.2)\n        };\n        if (id.includes(\"yolo\")) {\n            return {\n                type: \"detection\",\n                batchSize: 16,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.detection, baseCharacteristics.minUtilization),\n                speedupFactor: 2.8,\n                memoryScale: 1.3,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.2,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.4,\n                features: [\n                    \"INT8 Quantization\",\n                    \"CUDA Graph Acceleration\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.detection, baseCharacteristics.baseMemory)\n            };\n        }\n        if (id.includes(\"stable\")) {\n            return {\n                type: \"generation\",\n                batchSize: 1,\n                baseUtilization: Math.max(this.GPU_SPECS.minUtilization.generation, baseCharacteristics.minUtilization),\n                speedupFactor: 2.2,\n                memoryScale: 1.5,\n                tensorCoreUsage: baseCharacteristics.tensorCoreUsage * 1.5,\n                memoryBandwidth: baseCharacteristics.memoryBandwidth * 1.8,\n                features: [\n                    \"FP16 Mixed Precision\",\n                    \"Attention Optimization\"\n                ],\n                baseMemory: Math.max(this.GPU_SPECS.minMemoryGB.generation, baseCharacteristics.baseMemory)\n            };\n        }\n        // Default CNN characteristics with realistic minimums\n        return {\n            type: \"cnn\",\n            batchSize: 32,\n            baseUtilization: Math.max(this.GPU_SPECS.minUtilization.cnn, baseCharacteristics.minUtilization),\n            speedupFactor: 2.2,\n            memoryScale: 1.2,\n            tensorCoreUsage: baseCharacteristics.tensorCoreUsage,\n            memoryBandwidth: baseCharacteristics.memoryBandwidth,\n            features: [\n                \"TensorRT Inference\",\n                \"Kernel Fusion\"\n            ],\n            baseMemory: baseCharacteristics.baseMemory\n        };\n    }\n    calculateMetrics(analysisResult, gpuEnabled) {\n        if (!(analysisResult === null || analysisResult === void 0 ? void 0 : analysisResult.graph)) {\n            return this.getDefaultMetrics();\n        }\n        const { totalFlops, totalMemory, modelId } = analysisResult.graph.metadata;\n        // Get baseline benchmarks for comparison\n        const cpuBaseline = _constants__WEBPACK_IMPORTED_MODULE_0__.CPU_BENCHMARKS[\"xeon-8380\"].resnet50.batchSize1;\n        const gpuBaseline = _constants__WEBPACK_IMPORTED_MODULE_0__.NVIDIA_BENCHMARKS.resnet50.a100.batchSize1;\n        // Calculate relative scaling based on model size vs ResNet50\n        const resnet50Flops = 8e9; // ResNet50 has ~8 billion FLOPs\n        const modelScale = totalFlops / resnet50Flops;\n        // CPU metrics scaled from real Xeon benchmark\n        const cpuMetrics = {\n            fps: Math.max(1, cpuBaseline.fps / modelScale),\n            latency: cpuBaseline.latency * modelScale,\n            memory: cpuBaseline.memory * modelScale / 1024,\n            utilization: Math.min(98, cpuBaseline.latency * modelScale * 0.8)\n        };\n        if (!gpuEnabled) {\n            return {\n                cpuMetrics,\n                gpuMetrics: {\n                    fps: 0,\n                    latency: 0,\n                    memory: 0,\n                    utilization: 0\n                },\n                nvOptimizations: null\n            };\n        }\n        // GPU metrics scaled from real A100 benchmark\n        const gpuMetrics = {\n            fps: Math.max(1, gpuBaseline.fps / modelScale),\n            latency: gpuBaseline.latency * modelScale,\n            memory: gpuBaseline.memory * modelScale / 1024,\n            utilization: Math.min(95, gpuBaseline.latency * modelScale * 0.6)\n        };\n        // Calculate real speedup from benchmarked values\n        const actualSpeedup = gpuMetrics.fps / cpuMetrics.fps;\n        return {\n            cpuMetrics,\n            gpuMetrics,\n            nvOptimizations: {\n                tensorCoreUsage: \"\".concat(Math.min(90, modelScale * 25), \"%\"),\n                memoryBandwidth: \"\".concat((modelScale * 0.8).toFixed(1), \" TB/s\"),\n                speedup: \"\".concat(actualSpeedup.toFixed(1), \"x\"),\n                batchSize: 1\n            }\n        };\n    }\n    getDefaultMetrics() {\n        const defaultMetrics = {\n            fps: 0,\n            latency: 0,\n            memory: 0,\n            utilization: 0\n        };\n        return {\n            cpuMetrics: defaultMetrics,\n            gpuMetrics: defaultMetrics,\n            nvOptimizations: null\n        };\n    }\n    constructor(){\n        this.GPU_SPECS = {\n            peakTflops: 312,\n            memoryBandwidth: 2048,\n            tensorCores: 432,\n            maxBatchSize: 32,\n            // Minimum utilization for active models\n            minUtilization: {\n                cnn: 15,\n                transformer: 25,\n                detection: 20,\n                generation: 35 // Stable Diffusion etc\n            },\n            // Minimum memory requirements\n            minMemoryGB: {\n                cnn: 1.5,\n                transformer: 2.8,\n                detection: 2.2,\n                generation: 3.5 // Stable Diffusion etc\n            }\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUNnRTtBQUdoRSxtREFBbUQ7QUFDbkQsTUFBTUU7SUFPSkMsT0FBT0MsTUFBMEIsRUFBRTtRQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sRUFBRTtZQUNyQixPQUFPO2dCQUNMQyxLQUFLLElBQU07Z0JBQ1hDLE1BQU0sSUFBTTtZQUNkO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xELEtBQUssSUFBTSxJQUFJLENBQUNGLElBQUksQ0FBQ0ksTUFBTSxDQUFDLENBQUNDLEtBQUtDLE1BQVFELE1BQU9DLENBQUFBLEdBQUcsQ0FBQ1AsT0FBTyxJQUFJLElBQUk7WUFDcEVJLE1BQU0sSUFBTSxJQUFJLENBQUNILElBQUksQ0FBQ0ksTUFBTSxDQUFDLENBQUNDLEtBQUtDLE1BQVFELE1BQU9DLENBQUFBLEdBQUcsQ0FBQ1AsT0FBTyxJQUFJLElBQUksS0FBSyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsTUFBTTtRQUM1RjtJQUNGO0lBRUEsT0FBT00sWUFBWUMsT0FBbUMsRUFBRTtRQUN0RCxPQUFPLElBQUlYLFVBQVVXLFdBQVcsRUFBRTtJQUNwQztJQXBCQUMsWUFBWVQsSUFBb0IsQ0FBRTtRQUNoQyxJQUFJLENBQUNBLElBQUksR0FBR0EsUUFBUSxFQUFFLEVBQUcsaUNBQWlDO0lBQzVEO0FBbUJGO0FBRU8sTUFBTVU7SUFzQkhDLG9CQUFvQkMsY0FBOEIsRUFBRTtRQUMxRCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFLEVBQUUsR0FBR0YsZUFBZUcsS0FBSyxJQUFJLENBQUM7UUFFM0QsSUFBSTtZQUNGLE1BQU1DLEtBQUtuQixVQUFVVSxXQUFXLENBQUNPO1lBRWpDLHlCQUF5QjtZQUN6QixNQUFNRyxhQUFhRCxHQUFHbEIsTUFBTSxDQUFDLFNBQVNJLEdBQUcsT0FBTVcscUJBQUFBLCtCQUFBQSxTQUFVSSxVQUFV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QUFpQyxPQUE5Qm5CLEtBQUtDLEdBQUcsQ0FBQyxJQUFJMEMsYUFBYSxLQUFJO2dCQUNsRHZCLGlCQUFpQixHQUFpQyxPQUE5QixDQUFDdUIsYUFBYSxHQUFFLEVBQUdLLE9BQU8sQ0FBQyxJQUFHO2dCQUNsREMsU0FBUyxHQUE0QixPQUF6QkYsY0FBY0MsT0FBTyxDQUFDLElBQUc7Z0JBQ3JDckIsV0FBVztZQUNiO1FBQ0Y7SUFDRjtJQUVRUyxvQkFBb0I7UUFDMUIsTUFBTWMsaUJBQWlCO1lBQ3JCbkQsS0FBSztZQUNMSSxTQUFTO1lBQ1RDLFFBQVE7WUFDUkMsYUFBYTtRQUNmO1FBQ0EsT0FBTztZQUNMdUMsWUFBWU07WUFDWkwsWUFBWUs7WUFDWkosaUJBQWlCO1FBQ25CO0lBQ0Y7O2FBM0tpQnhCLFlBQVk7WUFDM0I2QixZQUFZO1lBQ1ovQixpQkFBaUI7WUFDakJnQyxhQUFhO1lBQ2JDLGNBQWM7WUFDZCx3Q0FBd0M7WUFDeENuQyxnQkFBZ0I7Z0JBQ2RNLEtBQUs7Z0JBQ0w4QixhQUFhO2dCQUNiekIsV0FBVztnQkFDWEksWUFBWSxHQUFJLHVCQUF1QjtZQUN6QztZQUNBLDhCQUE4QjtZQUM5QlYsYUFBYTtnQkFDWEMsS0FBSztnQkFDTDhCLGFBQWE7Z0JBQ2J6QixXQUFXO2dCQUNYSSxZQUFZLElBQUksdUJBQXVCO1lBQ3pDO1FBQ0Y7O0FBeUpGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cz9kYjU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBsIGZyb20gJ25vZGVqcy1wb2xhcnMnO1xuaW1wb3J0IHsgQ1BVX0JFTkNITUFSS1MsIE5WSURJQV9CRU5DSE1BUktTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHR5cGUgeyBBbmFseXNpc1Jlc3VsdCwgTGF5ZXJNZXRyaWNzIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8vIFBvbGFycy1saWtlIERhdGFGcmFtZSBpbXBsZW1lbnRhdGlvbiBmb3IgYnJvd3NlclxuY2xhc3MgRGF0YUZyYW1lIHtcbiAgcHJpdmF0ZSBkYXRhOiBMYXllck1ldHJpY3NbXTtcblxuICBjb25zdHJ1Y3RvcihkYXRhOiBMYXllck1ldHJpY3NbXSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgW107ICAvLyBFbnN1cmUgZGF0YSBpcyBuZXZlciB1bmRlZmluZWRcbiAgfVxuXG4gIHNlbGVjdChjb2x1bW46IGtleW9mIExheWVyTWV0cmljcykge1xuICAgIGlmICghdGhpcy5kYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VtOiAoKSA9PiAwLFxuICAgICAgICBtZWFuOiAoKSA9PiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdW06ICgpID0+IHRoaXMuZGF0YS5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgKyAocm93W2NvbHVtbl0gfHwgMCksIDApLFxuICAgICAgbWVhbjogKCkgPT4gdGhpcy5kYXRhLnJlZHVjZSgoYWNjLCByb3cpID0+IGFjYyArIChyb3dbY29sdW1uXSB8fCAwKSwgMCkgLyB0aGlzLmRhdGEubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUmVjb3JkcyhyZWNvcmRzOiBMYXllck1ldHJpY3NbXSB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgRGF0YUZyYW1lKHJlY29yZHMgfHwgW10pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZUNhbGN1bGF0b3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IEdQVV9TUEVDUyA9IHtcbiAgICBwZWFrVGZsb3BzOiAzMTIsICAgICAgICAgIC8vIEExMDAgRlAxNlxuICAgIG1lbW9yeUJhbmR3aWR0aDogMjA0OCwgICAgLy8gR0Ivc1xuICAgIHRlbnNvckNvcmVzOiA0MzIsXG4gICAgbWF4QmF0Y2hTaXplOiAzMixcbiAgICAvLyBNaW5pbXVtIHV0aWxpemF0aW9uIGZvciBhY3RpdmUgbW9kZWxzXG4gICAgbWluVXRpbGl6YXRpb246IHtcbiAgICAgIGNubjogMTUsICAgICAgICAvLyBFZmZpY2llbnQgQ05Oc1xuICAgICAgdHJhbnNmb3JtZXI6IDI1LCAvLyBUcmFuc2Zvcm1lciBtb2RlbHNcbiAgICAgIGRldGVjdGlvbjogMjAsICAvLyBZT0xPIGV0Y1xuICAgICAgZ2VuZXJhdGlvbjogMzUgIC8vIFN0YWJsZSBEaWZmdXNpb24gZXRjXG4gICAgfSxcbiAgICAvLyBNaW5pbXVtIG1lbW9yeSByZXF1aXJlbWVudHNcbiAgICBtaW5NZW1vcnlHQjoge1xuICAgICAgY25uOiAxLjUsICAgICAgIC8vIEJhc2ljIENOTnNcbiAgICAgIHRyYW5zZm9ybWVyOiAyLjgsLy8gVHJhbnNmb3JtZXIgbW9kZWxzXG4gICAgICBkZXRlY3Rpb246IDIuMiwgLy8gWU9MTyBldGNcbiAgICAgIGdlbmVyYXRpb246IDMuNSAvLyBTdGFibGUgRGlmZnVzaW9uIGV0Y1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGNhbGN1bGF0ZVdpdGhQb2xhcnMoYW5hbHlzaXNSZXN1bHQ6IEFuYWx5c2lzUmVzdWx0KSB7XG4gICAgY29uc3QgeyBtZXRhZGF0YSwgbGF5ZXJzID0gW10gfSA9IGFuYWx5c2lzUmVzdWx0LmdyYXBoIHx8IHt9O1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZiA9IERhdGFGcmFtZS5mcm9tUmVjb3JkcyhsYXllcnMpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYmFzZSBtZXRyaWNzXG4gICAgICBjb25zdCB0b3RhbEZsb3BzID0gZGYuc2VsZWN0KCdmbG9wcycpLnN1bSgpIHx8IG1ldGFkYXRhPy50b3RhbEZsb3BzIHx8IDA7XG4gICAgICBjb25zdCB0b3RhbE1lbW9yeSA9IGRmLnNlbGVjdCgnbWVtb3J5Jykuc3VtKCkgfHwgbWV0YWRhdGE/LnRvdGFsTWVtb3J5IHx8IDA7XG4gICAgICBjb25zdCBwYXJhbXNQZXJMYXllciA9IGRmLnNlbGVjdCgncGFyYW1ldGVycycpLm1lYW4oKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIENQVS1zcGVjaWZpYyBiYXNlIG1ldHJpY3NcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZwczogTWF0aC5taW4oNjAsIDEwMDAgLyBNYXRoLm1heCgxLCB0b3RhbEZsb3BzIC8gMWU5KSksICAvLyBDYXAgQ1BVIGF0IDYwIEZQU1xuICAgICAgICBsYXRlbmN5OiBNYXRoLm1heCgyLjAsICh0b3RhbEZsb3BzIC8gMWU5KSAqIDMuNSksICAgICAgICAgLy8gQ1BVIGhhcyBoaWdoZXIgYmFzZSBsYXRlbmN5XG4gICAgICAgIG1lbW9yeTogTWF0aC5tYXgoMS41LCB0b3RhbE1lbW9yeSAvICgxMDI0ICogMTAyNCAqIDEwMjQpKSwgLy8gQ1BVIG5lZWRzIG1vcmUgbWVtb3J5XG4gICAgICAgIHV0aWxpemF0aW9uOiBNYXRoLm1pbig5NSwgTWF0aC5tYXgoMjUsICh0b3RhbEZsb3BzIC8gMWU5KSAqIDAuOCkpLCAvLyBDUFUgdXRpbGl6YXRpb24gaXMgaGlnaGVyXG4gICAgICAgIGVmZmljaWVuY3k6IHRvdGFsRmxvcHMgLyAoZGYuc2VsZWN0KCdwYXJhbWV0ZXJzJykuc3VtKCkgfHwgMSksXG4gICAgICAgIG1lbW9yeUVmZmljaWVuY3k6IHRvdGFsTWVtb3J5IC8gKGRmLnNlbGVjdCgncGFyYW1ldGVycycpLnN1bSgpICogNCB8fCAxKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0NhbGN1bGF0aW9ucyBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBzaW1wbGUgY2FsY3VsYXRpb25zJywgZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmcHM6IE1hdGgubWluKDMwLCAxMDAwIC8gTWF0aC5tYXgoMSwgbWV0YWRhdGE/LnRvdGFsRmxvcHMgLyAxZTkgfHwgMCkpLFxuICAgICAgICBsYXRlbmN5OiBNYXRoLm1heCgyLjAsIChtZXRhZGF0YT8udG90YWxGbG9wcyAvIDFlOSB8fCAwKSAqIDMuNSksXG4gICAgICAgIG1lbW9yeTogTWF0aC5tYXgoMS41LCAobWV0YWRhdGE/LnRvdGFsTWVtb3J5IHx8IDApIC8gKDEwMjQgKiAxMDI0ICogMTAyNCkpLFxuICAgICAgICB1dGlsaXphdGlvbjogTWF0aC5taW4oOTUsIChtZXRhZGF0YT8udG90YWxGbG9wcyAvIDFlOSB8fCAwKSAqIDAuOCksXG4gICAgICAgIGVmZmljaWVuY3k6IDAsXG4gICAgICAgIG1lbW9yeUVmZmljaWVuY3k6IDBcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRNb2RlbENoYXJhY3RlcmlzdGljcyhtb2RlbElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHRvdGFsRmxvcHM6IG51bWJlciwgdG90YWxNZW1vcnk6IG51bWJlcikge1xuICAgIGNvbnN0IGlkID0gbW9kZWxJZD8udG9Mb3dlckNhc2UoKSA/PyAnZGVmYXVsdCc7XG4gICAgY29uc3QgZmxvcHNJblRGbG9wcyA9IHRvdGFsRmxvcHMgLyAxZTEyO1xuICAgIGNvbnN0IG1lbW9yeUluR0IgPSB0b3RhbE1lbW9yeSAvIDEwMjQgLyAxMDI0IC8gMTAyNDtcblxuICAgIC8vIEJhc2UgY2hhcmFjdGVyaXN0aWNzIHRoYXQgc2NhbGUgd2l0aCBtb2RlbCBzaXplXG4gICAgY29uc3QgYmFzZUNoYXJhY3RlcmlzdGljcyA9IHtcbiAgICAgIG1pblV0aWxpemF0aW9uOiBNYXRoLm1heCgxNSwgZmxvcHNJblRGbG9wcyAqIDEwKSxcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogTWF0aC5tYXgoMTIsIGZsb3BzSW5URmxvcHMgKiAxNSksXG4gICAgICBtZW1vcnlCYW5kd2lkdGg6IE1hdGgubWF4KDAuMywgZmxvcHNJblRGbG9wcyAqIDAuNSksXG4gICAgICBiYXNlTWVtb3J5OiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5NZW1vcnlHQi5jbm4sIG1lbW9yeUluR0IgKiAxLjIpXG4gICAgfTtcblxuICAgIGlmIChpZC5pbmNsdWRlcygneW9sbycpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGV0ZWN0aW9uJyxcbiAgICAgICAgYmF0Y2hTaXplOiAxNixcbiAgICAgICAgYmFzZVV0aWxpemF0aW9uOiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5VdGlsaXphdGlvbi5kZXRlY3Rpb24sIGJhc2VDaGFyYWN0ZXJpc3RpY3MubWluVXRpbGl6YXRpb24pLFxuICAgICAgICBzcGVlZHVwRmFjdG9yOiAyLjgsXG4gICAgICAgIG1lbW9yeVNjYWxlOiAxLjMsXG4gICAgICAgIHRlbnNvckNvcmVVc2FnZTogYmFzZUNoYXJhY3RlcmlzdGljcy50ZW5zb3JDb3JlVXNhZ2UgKiAxLjIsXG4gICAgICAgIG1lbW9yeUJhbmR3aWR0aDogYmFzZUNoYXJhY3RlcmlzdGljcy5tZW1vcnlCYW5kd2lkdGggKiAxLjQsXG4gICAgICAgIGZlYXR1cmVzOiBbJ0lOVDggUXVhbnRpemF0aW9uJywgJ0NVREEgR3JhcGggQWNjZWxlcmF0aW9uJ10sXG4gICAgICAgIGJhc2VNZW1vcnk6IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pbk1lbW9yeUdCLmRldGVjdGlvbiwgYmFzZUNoYXJhY3RlcmlzdGljcy5iYXNlTWVtb3J5KVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaWQuaW5jbHVkZXMoJ3N0YWJsZScpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZ2VuZXJhdGlvbicsXG4gICAgICAgIGJhdGNoU2l6ZTogMSxcbiAgICAgICAgYmFzZVV0aWxpemF0aW9uOiBNYXRoLm1heCh0aGlzLkdQVV9TUEVDUy5taW5VdGlsaXphdGlvbi5nZW5lcmF0aW9uLCBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1pblV0aWxpemF0aW9uKSxcbiAgICAgICAgc3BlZWR1cEZhY3RvcjogMi4yLFxuICAgICAgICBtZW1vcnlTY2FsZTogMS41LFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGJhc2VDaGFyYWN0ZXJpc3RpY3MudGVuc29yQ29yZVVzYWdlICogMS41LFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6IGJhc2VDaGFyYWN0ZXJpc3RpY3MubWVtb3J5QmFuZHdpZHRoICogMS44LFxuICAgICAgICBmZWF0dXJlczogWydGUDE2IE1peGVkIFByZWNpc2lvbicsICdBdHRlbnRpb24gT3B0aW1pemF0aW9uJ10sXG4gICAgICAgIGJhc2VNZW1vcnk6IE1hdGgubWF4KHRoaXMuR1BVX1NQRUNTLm1pbk1lbW9yeUdCLmdlbmVyYXRpb24sIGJhc2VDaGFyYWN0ZXJpc3RpY3MuYmFzZU1lbW9yeSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCBDTk4gY2hhcmFjdGVyaXN0aWNzIHdpdGggcmVhbGlzdGljIG1pbmltdW1zXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdjbm4nLFxuICAgICAgYmF0Y2hTaXplOiAzMixcbiAgICAgIGJhc2VVdGlsaXphdGlvbjogTWF0aC5tYXgodGhpcy5HUFVfU1BFQ1MubWluVXRpbGl6YXRpb24uY25uLCBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1pblV0aWxpemF0aW9uKSxcbiAgICAgIHNwZWVkdXBGYWN0b3I6IDIuMixcbiAgICAgIG1lbW9yeVNjYWxlOiAxLjIsXG4gICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGJhc2VDaGFyYWN0ZXJpc3RpY3MudGVuc29yQ29yZVVzYWdlLFxuICAgICAgbWVtb3J5QmFuZHdpZHRoOiBiYXNlQ2hhcmFjdGVyaXN0aWNzLm1lbW9yeUJhbmR3aWR0aCxcbiAgICAgIGZlYXR1cmVzOiBbJ1RlbnNvclJUIEluZmVyZW5jZScsICdLZXJuZWwgRnVzaW9uJ10sXG4gICAgICBiYXNlTWVtb3J5OiBiYXNlQ2hhcmFjdGVyaXN0aWNzLmJhc2VNZW1vcnlcbiAgICB9O1xuICB9XG5cbiAgY2FsY3VsYXRlTWV0cmljcyhhbmFseXNpc1Jlc3VsdDogQW5hbHlzaXNSZXN1bHQgfCBudWxsLCBncHVFbmFibGVkOiBib29sZWFuKSB7XG4gICAgaWYgKCFhbmFseXNpc1Jlc3VsdD8uZ3JhcGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRNZXRyaWNzKCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0b3RhbEZsb3BzLCB0b3RhbE1lbW9yeSwgbW9kZWxJZCB9ID0gYW5hbHlzaXNSZXN1bHQuZ3JhcGgubWV0YWRhdGE7XG5cbiAgICAvLyBHZXQgYmFzZWxpbmUgYmVuY2htYXJrcyBmb3IgY29tcGFyaXNvblxuICAgIGNvbnN0IGNwdUJhc2VsaW5lID0gQ1BVX0JFTkNITUFSS1NbJ3hlb24tODM4MCddLnJlc25ldDUwLmJhdGNoU2l6ZTE7XG4gICAgY29uc3QgZ3B1QmFzZWxpbmUgPSBOVklESUFfQkVOQ0hNQVJLUy5yZXNuZXQ1MC5hMTAwLmJhdGNoU2l6ZTE7XG5cbiAgICAvLyBDYWxjdWxhdGUgcmVsYXRpdmUgc2NhbGluZyBiYXNlZCBvbiBtb2RlbCBzaXplIHZzIFJlc05ldDUwXG4gICAgY29uc3QgcmVzbmV0NTBGbG9wcyA9IDhlOTsgLy8gUmVzTmV0NTAgaGFzIH44IGJpbGxpb24gRkxPUHNcbiAgICBjb25zdCBtb2RlbFNjYWxlID0gdG90YWxGbG9wcyAvIHJlc25ldDUwRmxvcHM7XG5cbiAgICAvLyBDUFUgbWV0cmljcyBzY2FsZWQgZnJvbSByZWFsIFhlb24gYmVuY2htYXJrXG4gICAgY29uc3QgY3B1TWV0cmljcyA9IHtcbiAgICAgIGZwczogTWF0aC5tYXgoMSwgY3B1QmFzZWxpbmUuZnBzIC8gbW9kZWxTY2FsZSksXG4gICAgICBsYXRlbmN5OiBjcHVCYXNlbGluZS5sYXRlbmN5ICogbW9kZWxTY2FsZSxcbiAgICAgIG1lbW9yeTogKGNwdUJhc2VsaW5lLm1lbW9yeSAqIG1vZGVsU2NhbGUpIC8gMTAyNCwgLy8gQ29udmVydCBNQiB0byBHQlxuICAgICAgdXRpbGl6YXRpb246IE1hdGgubWluKDk4LCBjcHVCYXNlbGluZS5sYXRlbmN5ICogbW9kZWxTY2FsZSAqIDAuOClcbiAgICB9O1xuXG4gICAgaWYgKCFncHVFbmFibGVkKSB7XG4gICAgICByZXR1cm4geyBjcHVNZXRyaWNzLCBncHVNZXRyaWNzOiB7IGZwczogMCwgbGF0ZW5jeTogMCwgbWVtb3J5OiAwLCB1dGlsaXphdGlvbjogMCB9LCBudk9wdGltaXphdGlvbnM6IG51bGwgfTtcbiAgICB9XG5cbiAgICAvLyBHUFUgbWV0cmljcyBzY2FsZWQgZnJvbSByZWFsIEExMDAgYmVuY2htYXJrXG4gICAgY29uc3QgZ3B1TWV0cmljcyA9IHtcbiAgICAgIGZwczogTWF0aC5tYXgoMSwgZ3B1QmFzZWxpbmUuZnBzIC8gbW9kZWxTY2FsZSksXG4gICAgICBsYXRlbmN5OiBncHVCYXNlbGluZS5sYXRlbmN5ICogbW9kZWxTY2FsZSxcbiAgICAgIG1lbW9yeTogKGdwdUJhc2VsaW5lLm1lbW9yeSAqIG1vZGVsU2NhbGUpIC8gMTAyNCxcbiAgICAgIHV0aWxpemF0aW9uOiBNYXRoLm1pbig5NSwgZ3B1QmFzZWxpbmUubGF0ZW5jeSAqIG1vZGVsU2NhbGUgKiAwLjYpXG4gICAgfTtcblxuICAgIC8vIENhbGN1bGF0ZSByZWFsIHNwZWVkdXAgZnJvbSBiZW5jaG1hcmtlZCB2YWx1ZXNcbiAgICBjb25zdCBhY3R1YWxTcGVlZHVwID0gZ3B1TWV0cmljcy5mcHMgLyBjcHVNZXRyaWNzLmZwcztcblxuICAgIHJldHVybiB7XG4gICAgICBjcHVNZXRyaWNzLFxuICAgICAgZ3B1TWV0cmljcyxcbiAgICAgIG52T3B0aW1pemF0aW9uczoge1xuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGAke01hdGgubWluKDkwLCBtb2RlbFNjYWxlICogMjUpfSVgLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6IGAkeyhtb2RlbFNjYWxlICogMC44KS50b0ZpeGVkKDEpfSBUQi9zYCxcbiAgICAgICAgc3BlZWR1cDogYCR7YWN0dWFsU3BlZWR1cC50b0ZpeGVkKDEpfXhgLFxuICAgICAgICBiYXRjaFNpemU6IDFcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXREZWZhdWx0TWV0cmljcygpIHtcbiAgICBjb25zdCBkZWZhdWx0TWV0cmljcyA9IHtcbiAgICAgIGZwczogMCxcbiAgICAgIGxhdGVuY3k6IDAsXG4gICAgICBtZW1vcnk6IDAsXG4gICAgICB1dGlsaXphdGlvbjogMFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNwdU1ldHJpY3M6IGRlZmF1bHRNZXRyaWNzLFxuICAgICAgZ3B1TWV0cmljczogZGVmYXVsdE1ldHJpY3MsXG4gICAgICBudk9wdGltaXphdGlvbnM6IG51bGxcbiAgICB9O1xuICB9XG59ICJdLCJuYW1lcyI6WyJDUFVfQkVOQ0hNQVJLUyIsIk5WSURJQV9CRU5DSE1BUktTIiwiRGF0YUZyYW1lIiwic2VsZWN0IiwiY29sdW1uIiwiZGF0YSIsImxlbmd0aCIsInN1bSIsIm1lYW4iLCJyZWR1Y2UiLCJhY2MiLCJyb3ciLCJmcm9tUmVjb3JkcyIsInJlY29yZHMiLCJjb25zdHJ1Y3RvciIsIlBlcmZvcm1hbmNlQ2FsY3VsYXRvciIsImNhbGN1bGF0ZVdpdGhQb2xhcnMiLCJhbmFseXNpc1Jlc3VsdCIsIm1ldGFkYXRhIiwibGF5ZXJzIiwiZ3JhcGgiLCJkZiIsInRvdGFsRmxvcHMiLCJ0b3RhbE1lbW9yeSIsInBhcmFtc1BlckxheWVyIiwiZnBzIiwiTWF0aCIsIm1pbiIsIm1heCIsImxhdGVuY3kiLCJtZW1vcnkiLCJ1dGlsaXphdGlvbiIsImVmZmljaWVuY3kiLCJtZW1vcnlFZmZpY2llbmN5IiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwiZ2V0TW9kZWxDaGFyYWN0ZXJpc3RpY3MiLCJtb2RlbElkIiwiaWQiLCJ0b0xvd2VyQ2FzZSIsImZsb3BzSW5URmxvcHMiLCJtZW1vcnlJbkdCIiwiYmFzZUNoYXJhY3RlcmlzdGljcyIsIm1pblV0aWxpemF0aW9uIiwidGVuc29yQ29yZVVzYWdlIiwibWVtb3J5QmFuZHdpZHRoIiwiYmFzZU1lbW9yeSIsIkdQVV9TUEVDUyIsIm1pbk1lbW9yeUdCIiwiY25uIiwiaW5jbHVkZXMiLCJ0eXBlIiwiYmF0Y2hTaXplIiwiYmFzZVV0aWxpemF0aW9uIiwiZGV0ZWN0aW9uIiwic3BlZWR1cEZhY3RvciIsIm1lbW9yeVNjYWxlIiwiZmVhdHVyZXMiLCJnZW5lcmF0aW9uIiwiY2FsY3VsYXRlTWV0cmljcyIsImdwdUVuYWJsZWQiLCJnZXREZWZhdWx0TWV0cmljcyIsImNwdUJhc2VsaW5lIiwicmVzbmV0NTAiLCJiYXRjaFNpemUxIiwiZ3B1QmFzZWxpbmUiLCJhMTAwIiwicmVzbmV0NTBGbG9wcyIsIm1vZGVsU2NhbGUiLCJjcHVNZXRyaWNzIiwiZ3B1TWV0cmljcyIsIm52T3B0aW1pemF0aW9ucyIsImFjdHVhbFNwZWVkdXAiLCJ0b0ZpeGVkIiwic3BlZWR1cCIsImRlZmF1bHRNZXRyaWNzIiwicGVha1RmbG9wcyIsInRlbnNvckNvcmVzIiwibWF4QmF0Y2hTaXplIiwidHJhbnNmb3JtZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/performance.ts\n"));

/***/ })

});