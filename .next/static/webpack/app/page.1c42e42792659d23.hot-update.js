"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/performance.ts":
/*!**********************************!*\
  !*** ./lib/model/performance.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PerformanceCalculator: function() { return /* binding */ PerformanceCalculator; }\n/* harmony export */ });\n// Polars-like DataFrame implementation for browser\nclass DataFrame {\n    select(column) {\n        return {\n            sum: ()=>this.data.reduce((acc, row)=>acc + row[column], 0),\n            mean: ()=>this.data.reduce((acc, row)=>acc + row[column], 0) / this.data.length\n        };\n    }\n    static fromRecords(records) {\n        return new DataFrame(records);\n    }\n    constructor(data){\n        this.data = data;\n    }\n}\nclass PerformanceCalculator {\n    calculateWithPolars(analysisResult) {\n        const { metadata, layers } = analysisResult.graph;\n        // Create DataFrame with layer metrics\n        const df = DataFrame.fromRecords(layers);\n        // Calculate aggregated metrics\n        const metrics = {\n            totalFlops: df.select(\"flops\").sum(),\n            meanFlops: df.select(\"flops\").mean(),\n            totalMemory: df.select(\"memory\").sum(),\n            paramsPerLayer: df.select(\"parameters\").mean()\n        };\n        // Calculate CPU performance metrics\n        return {\n            fps: Math.min(120, 1000 / Math.max(1, metrics.totalFlops / 1e9)),\n            latency: Math.max(0.5, metrics.totalFlops / 1e9 * 2),\n            memory: Math.max(0.1, metrics.totalMemory / (1024 * 1024 * 1024)),\n            utilization: Math.min(95, metrics.totalFlops / 1e9 * 0.45)\n        };\n    }\n    getTensorRTOptimizations(modelId, totalFlops) {\n        var _modelId_toLowerCase;\n        const id = (_modelId_toLowerCase = modelId === null || modelId === void 0 ? void 0 : modelId.toLowerCase()) !== null && _modelId_toLowerCase !== void 0 ? _modelId_toLowerCase : \"default\";\n        // TensorRT optimization profiles based on model type\n        if (id.includes(\"yolo\")) {\n            return {\n                speedup: 5.5,\n                tensorCoreUsage: Math.min(95, totalFlops / 1e12 * 35),\n                memoryBandwidth: totalFlops / 1e12 * 1.2,\n                optimizations: [\n                    \"INT8 Quantization\",\n                    \"CUDA Graph Acceleration\",\n                    \"Layer Fusion\"\n                ]\n            };\n        }\n        if (id.includes(\"stable\")) {\n            return {\n                speedup: 4.2,\n                tensorCoreUsage: Math.min(90, totalFlops / 1e12 * 40),\n                memoryBandwidth: totalFlops / 1e12 * 1.8,\n                optimizations: [\n                    \"FP16 Mixed Precision\",\n                    \"Attention Optimization\",\n                    \"Dynamic Batching\"\n                ]\n            };\n        }\n        // Default optimizations for CNNs\n        return {\n            speedup: 4.0,\n            tensorCoreUsage: Math.min(85, totalFlops / 1e12 * 30),\n            memoryBandwidth: totalFlops / 1e12 * 0.9,\n            optimizations: [\n                \"TensorRT Inference\",\n                \"Kernel Autotuning\",\n                \"Layer Fusion\"\n            ]\n        };\n    }\n    calculateMetrics(analysisResult, gpuEnabled) {\n        // Calculate base metrics using our Polars-like implementation\n        const cpuMetrics = this.calculateWithPolars(analysisResult);\n        if (!gpuEnabled) {\n            return {\n                cpuMetrics,\n                gpuMetrics: cpuMetrics,\n                nvOptimizations: null\n            };\n        }\n        // Get TensorRT optimizations\n        const trt = this.getTensorRTOptimizations(analysisResult.graph.metadata.modelId || \"default\", analysisResult.graph.metadata.totalFlops);\n        // Apply GPU acceleration\n        const gpuMetrics = {\n            fps: Math.min(2000, cpuMetrics.fps * trt.speedup),\n            latency: Math.max(0.1, cpuMetrics.latency / trt.speedup),\n            memory: cpuMetrics.memory * 0.6,\n            utilization: Math.min(85, trt.tensorCoreUsage * 0.8)\n        };\n        const nvOptimizations = {\n            tensorCoreUsage: \"\".concat(trt.tensorCoreUsage.toFixed(1), \"%\"),\n            memoryBandwidth: \"\".concat(trt.memoryBandwidth.toFixed(1), \" TB/s\"),\n            speedup: \"\".concat(trt.speedup.toFixed(1), \"x\"),\n            features: trt.optimizations\n        };\n        return {\n            cpuMetrics,\n            gpuMetrics,\n            nvOptimizations\n        };\n    }\n    constructor(){\n        // Hardware specs based on NVIDIA A100\n        this.GPU_SPECS = {\n            peakTflops: 312,\n            memoryBandwidth: 2048,\n            tensorCores: 432,\n            maxBatchSize: 32\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9wZXJmb3JtYW5jZS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRUEsbURBQW1EO0FBQ25ELE1BQU1BO0lBT0pDLE9BQU9DLE1BQTBCLEVBQUU7UUFDakMsT0FBTztZQUNMQyxLQUFLLElBQU0sSUFBSSxDQUFDQyxJQUFJLENBQUNDLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQyxNQUFRRCxNQUFNQyxHQUFHLENBQUNMLE9BQU8sRUFBRTtZQUM3RE0sTUFBTSxJQUFNLElBQUksQ0FBQ0osSUFBSSxDQUFDQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsTUFBUUQsTUFBTUMsR0FBRyxDQUFDTCxPQUFPLEVBQUUsS0FBSyxJQUFJLENBQUNFLElBQUksQ0FBQ0ssTUFBTTtRQUNyRjtJQUNGO0lBRUEsT0FBT0MsWUFBWUMsT0FBdUIsRUFBRTtRQUMxQyxPQUFPLElBQUlYLFVBQVVXO0lBQ3ZCO0lBYkFDLFlBQVlSLElBQW9CLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO0lBQ2Q7QUFZRjtBQUVPLE1BQU1TO0lBU0hDLG9CQUFvQkMsY0FBOEIsRUFBRTtRQUMxRCxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFLEdBQUdGLGVBQWVHLEtBQUs7UUFFakQsc0NBQXNDO1FBQ3RDLE1BQU1DLEtBQUtuQixVQUFVVSxXQUFXLENBQUNPO1FBRWpDLCtCQUErQjtRQUMvQixNQUFNRyxVQUFVO1lBQ2RDLFlBQVlGLEdBQUdsQixNQUFNLENBQUMsU0FBU0UsR0FBRztZQUNsQ21CLFdBQVdILEdBQUdsQixNQUFNLENBQUMsU0FBU08sSUFBSTtZQUNsQ2UsYUFBYUosR0FBR2xCLE1BQU0sQ0FBQyxVQUFVRSxHQUFHO1lBQ3BDcUIsZ0JBQWdCTCxHQUFHbEIsTUFBTSxDQUFDLGNBQWNPLElBQUk7UUFDOUM7UUFFQSxvQ0FBb0M7UUFDcEMsT0FBTztZQUNMaUIsS0FBS0MsS0FBS0MsR0FBRyxDQUFDLEtBQUssT0FBT0QsS0FB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b3JtYW5jZS50cz9kYjU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQW5hbHlzaXNSZXN1bHQsIExheWVyTWV0cmljcyB9IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBQb2xhcnMtbGlrZSBEYXRhRnJhbWUgaW1wbGVtZW50YXRpb24gZm9yIGJyb3dzZXJcbmNsYXNzIERhdGFGcmFtZSB7XG4gIHByaXZhdGUgZGF0YTogTGF5ZXJNZXRyaWNzW107XG5cbiAgY29uc3RydWN0b3IoZGF0YTogTGF5ZXJNZXRyaWNzW10pIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgc2VsZWN0KGNvbHVtbjoga2V5b2YgTGF5ZXJNZXRyaWNzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1bTogKCkgPT4gdGhpcy5kYXRhLnJlZHVjZSgoYWNjLCByb3cpID0+IGFjYyArIHJvd1tjb2x1bW5dLCAwKSxcbiAgICAgIG1lYW46ICgpID0+IHRoaXMuZGF0YS5yZWR1Y2UoKGFjYywgcm93KSA9PiBhY2MgKyByb3dbY29sdW1uXSwgMCkgLyB0aGlzLmRhdGEubGVuZ3RoXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUmVjb3JkcyhyZWNvcmRzOiBMYXllck1ldHJpY3NbXSkge1xuICAgIHJldHVybiBuZXcgRGF0YUZyYW1lKHJlY29yZHMpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZUNhbGN1bGF0b3Ige1xuICAvLyBIYXJkd2FyZSBzcGVjcyBiYXNlZCBvbiBOVklESUEgQTEwMFxuICBwcml2YXRlIHJlYWRvbmx5IEdQVV9TUEVDUyA9IHtcbiAgICBwZWFrVGZsb3BzOiAzMTIsICAgICAgICAgIC8vIDMxMiBURkxPUFMgRlAxNlxuICAgIG1lbW9yeUJhbmR3aWR0aDogMjA0OCwgICAgLy8gMiBUQi9zIHdpdGggTlZMaW5rXG4gICAgdGVuc29yQ29yZXM6IDQzMixcbiAgICBtYXhCYXRjaFNpemU6IDMyXG4gIH07XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVXaXRoUG9sYXJzKGFuYWx5c2lzUmVzdWx0OiBBbmFseXNpc1Jlc3VsdCkge1xuICAgIGNvbnN0IHsgbWV0YWRhdGEsIGxheWVycyB9ID0gYW5hbHlzaXNSZXN1bHQuZ3JhcGg7XG4gICAgXG4gICAgLy8gQ3JlYXRlIERhdGFGcmFtZSB3aXRoIGxheWVyIG1ldHJpY3NcbiAgICBjb25zdCBkZiA9IERhdGFGcmFtZS5mcm9tUmVjb3JkcyhsYXllcnMpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGFnZ3JlZ2F0ZWQgbWV0cmljc1xuICAgIGNvbnN0IG1ldHJpY3MgPSB7XG4gICAgICB0b3RhbEZsb3BzOiBkZi5zZWxlY3QoJ2Zsb3BzJykuc3VtKCksXG4gICAgICBtZWFuRmxvcHM6IGRmLnNlbGVjdCgnZmxvcHMnKS5tZWFuKCksXG4gICAgICB0b3RhbE1lbW9yeTogZGYuc2VsZWN0KCdtZW1vcnknKS5zdW0oKSxcbiAgICAgIHBhcmFtc1BlckxheWVyOiBkZi5zZWxlY3QoJ3BhcmFtZXRlcnMnKS5tZWFuKClcbiAgICB9O1xuXG4gICAgLy8gQ2FsY3VsYXRlIENQVSBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gICAgcmV0dXJuIHtcbiAgICAgIGZwczogTWF0aC5taW4oMTIwLCAxMDAwIC8gTWF0aC5tYXgoMSwgbWV0cmljcy50b3RhbEZsb3BzIC8gMWU5KSksXG4gICAgICBsYXRlbmN5OiBNYXRoLm1heCgwLjUsIChtZXRyaWNzLnRvdGFsRmxvcHMgLyAxZTkpICogMiksXG4gICAgICBtZW1vcnk6IE1hdGgubWF4KDAuMSwgbWV0cmljcy50b3RhbE1lbW9yeSAvICgxMDI0ICogMTAyNCAqIDEwMjQpKSxcbiAgICAgIHV0aWxpemF0aW9uOiBNYXRoLm1pbig5NSwgKG1ldHJpY3MudG90YWxGbG9wcyAvIDFlOSkgKiAwLjQ1KVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldFRlbnNvclJUT3B0aW1pemF0aW9ucyhtb2RlbElkOiBzdHJpbmcsIHRvdGFsRmxvcHM6IG51bWJlcikge1xuICAgIGNvbnN0IGlkID0gbW9kZWxJZD8udG9Mb3dlckNhc2UoKSA/PyAnZGVmYXVsdCc7XG4gICAgXG4gICAgLy8gVGVuc29yUlQgb3B0aW1pemF0aW9uIHByb2ZpbGVzIGJhc2VkIG9uIG1vZGVsIHR5cGVcbiAgICBpZiAoaWQuaW5jbHVkZXMoJ3lvbG8nKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BlZWR1cDogNS41LFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IE1hdGgubWluKDk1LCAodG90YWxGbG9wcyAvIDFlMTIpICogMzUpLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6ICh0b3RhbEZsb3BzIC8gMWUxMikgKiAxLjIsXG4gICAgICAgIG9wdGltaXphdGlvbnM6IFtcbiAgICAgICAgICAnSU5UOCBRdWFudGl6YXRpb24nLFxuICAgICAgICAgICdDVURBIEdyYXBoIEFjY2VsZXJhdGlvbicsXG4gICAgICAgICAgJ0xheWVyIEZ1c2lvbidcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGlkLmluY2x1ZGVzKCdzdGFibGUnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3BlZWR1cDogNC4yLFxuICAgICAgICB0ZW5zb3JDb3JlVXNhZ2U6IE1hdGgubWluKDkwLCAodG90YWxGbG9wcyAvIDFlMTIpICogNDApLFxuICAgICAgICBtZW1vcnlCYW5kd2lkdGg6ICh0b3RhbEZsb3BzIC8gMWUxMikgKiAxLjgsXG4gICAgICAgIG9wdGltaXphdGlvbnM6IFtcbiAgICAgICAgICAnRlAxNiBNaXhlZCBQcmVjaXNpb24nLFxuICAgICAgICAgICdBdHRlbnRpb24gT3B0aW1pemF0aW9uJyxcbiAgICAgICAgICAnRHluYW1pYyBCYXRjaGluZydcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gRGVmYXVsdCBvcHRpbWl6YXRpb25zIGZvciBDTk5zXG4gICAgcmV0dXJuIHtcbiAgICAgIHNwZWVkdXA6IDQuMCxcbiAgICAgIHRlbnNvckNvcmVVc2FnZTogTWF0aC5taW4oODUsICh0b3RhbEZsb3BzIC8gMWUxMikgKiAzMCksXG4gICAgICBtZW1vcnlCYW5kd2lkdGg6ICh0b3RhbEZsb3BzIC8gMWUxMikgKiAwLjksXG4gICAgICBvcHRpbWl6YXRpb25zOiBbXG4gICAgICAgICdUZW5zb3JSVCBJbmZlcmVuY2UnLFxuICAgICAgICAnS2VybmVsIEF1dG90dW5pbmcnLFxuICAgICAgICAnTGF5ZXIgRnVzaW9uJ1xuICAgICAgXVxuICAgIH07XG4gIH1cblxuICBjYWxjdWxhdGVNZXRyaWNzKGFuYWx5c2lzUmVzdWx0OiBBbmFseXNpc1Jlc3VsdCwgZ3B1RW5hYmxlZDogYm9vbGVhbikge1xuICAgIC8vIENhbGN1bGF0ZSBiYXNlIG1ldHJpY3MgdXNpbmcgb3VyIFBvbGFycy1saWtlIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgY3B1TWV0cmljcyA9IHRoaXMuY2FsY3VsYXRlV2l0aFBvbGFycyhhbmFseXNpc1Jlc3VsdCk7XG5cbiAgICBpZiAoIWdwdUVuYWJsZWQpIHtcbiAgICAgIHJldHVybiB7IGNwdU1ldHJpY3MsIGdwdU1ldHJpY3M6IGNwdU1ldHJpY3MsIG52T3B0aW1pemF0aW9uczogbnVsbCB9O1xuICAgIH1cblxuICAgIC8vIEdldCBUZW5zb3JSVCBvcHRpbWl6YXRpb25zXG4gICAgY29uc3QgdHJ0ID0gdGhpcy5nZXRUZW5zb3JSVE9wdGltaXphdGlvbnMoXG4gICAgICBhbmFseXNpc1Jlc3VsdC5ncmFwaC5tZXRhZGF0YS5tb2RlbElkIHx8ICdkZWZhdWx0JyxcbiAgICAgIGFuYWx5c2lzUmVzdWx0LmdyYXBoLm1ldGFkYXRhLnRvdGFsRmxvcHNcbiAgICApO1xuXG4gICAgLy8gQXBwbHkgR1BVIGFjY2VsZXJhdGlvblxuICAgIGNvbnN0IGdwdU1ldHJpY3MgPSB7XG4gICAgICBmcHM6IE1hdGgubWluKDIwMDAsIGNwdU1ldHJpY3MuZnBzICogdHJ0LnNwZWVkdXApLFxuICAgICAgbGF0ZW5jeTogTWF0aC5tYXgoMC4xLCBjcHVNZXRyaWNzLmxhdGVuY3kgLyB0cnQuc3BlZWR1cCksXG4gICAgICBtZW1vcnk6IGNwdU1ldHJpY3MubWVtb3J5ICogMC42LFxuICAgICAgdXRpbGl6YXRpb246IE1hdGgubWluKDg1LCB0cnQudGVuc29yQ29yZVVzYWdlICogMC44KVxuICAgIH07XG5cbiAgICBjb25zdCBudk9wdGltaXphdGlvbnMgPSB7XG4gICAgICB0ZW5zb3JDb3JlVXNhZ2U6IGAke3RydC50ZW5zb3JDb3JlVXNhZ2UudG9GaXhlZCgxKX0lYCxcbiAgICAgIG1lbW9yeUJhbmR3aWR0aDogYCR7dHJ0Lm1lbW9yeUJhbmR3aWR0aC50b0ZpeGVkKDEpfSBUQi9zYCxcbiAgICAgIHNwZWVkdXA6IGAke3RydC5zcGVlZHVwLnRvRml4ZWQoMSl9eGAsXG4gICAgICBmZWF0dXJlczogdHJ0Lm9wdGltaXphdGlvbnNcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgY3B1TWV0cmljcywgZ3B1TWV0cmljcywgbnZPcHRpbWl6YXRpb25zIH07XG4gIH1cbn0gIl0sIm5hbWVzIjpbIkRhdGFGcmFtZSIsInNlbGVjdCIsImNvbHVtbiIsInN1bSIsImRhdGEiLCJyZWR1Y2UiLCJhY2MiLCJyb3ciLCJtZWFuIiwibGVuZ3RoIiwiZnJvbVJlY29yZHMiLCJyZWNvcmRzIiwiY29uc3RydWN0b3IiLCJQZXJmb3JtYW5jZUNhbGN1bGF0b3IiLCJjYWxjdWxhdGVXaXRoUG9sYXJzIiwiYW5hbHlzaXNSZXN1bHQiLCJtZXRhZGF0YSIsImxheWVycyIsImdyYXBoIiwiZGYiLCJtZXRyaWNzIiwidG90YWxGbG9wcyIsIm1lYW5GbG9wcyIsInRvdGFsTWVtb3J5IiwicGFyYW1zUGVyTGF5ZXIiLCJmcHMiLCJNYXRoIiwibWluIiwibWF4IiwibGF0ZW5jeSIsIm1lbW9yeSIsInV0aWxpemF0aW9uIiwiZ2V0VGVuc29yUlRPcHRpbWl6YXRpb25zIiwibW9kZWxJZCIsImlkIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInNwZWVkdXAiLCJ0ZW5zb3JDb3JlVXNhZ2UiLCJtZW1vcnlCYW5kd2lkdGgiLCJvcHRpbWl6YXRpb25zIiwiY2FsY3VsYXRlTWV0cmljcyIsImdwdUVuYWJsZWQiLCJjcHVNZXRyaWNzIiwiZ3B1TWV0cmljcyIsIm52T3B0aW1pemF0aW9ucyIsInRydCIsInRvRml4ZWQiLCJmZWF0dXJlcyIsIkdQVV9TUEVDUyIsInBlYWtUZmxvcHMiLCJ0ZW5zb3JDb3JlcyIsIm1heEJhdGNoU2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/performance.ts\n"));

/***/ })

});