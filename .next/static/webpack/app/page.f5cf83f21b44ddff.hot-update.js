"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model/analyzer.ts":
/*!*******************************!*\
  !*** ./lib/model/analyzer.ts ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModelAnalyzer: function() { return /* binding */ ModelAnalyzer; }\n/* harmony export */ });\n/* harmony import */ var _lib_huggingface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/huggingface */ \"(app-pages-browser)/./lib/huggingface.ts\");\n/* __next_internal_client_entry_do_not_use__ ModelAnalyzer auto */ \nclass ModelAnalyzer {\n    async analyzeModel(modelId, onProgress) {\n        try {\n            // Loading stage\n            onProgress({\n                stage: \"loading\",\n                progress: 0,\n                message: \"Loading model information...\"\n            });\n            // Skip API call and use local architecture directly\n            const architecture = await (0,_lib_huggingface__WEBPACK_IMPORTED_MODULE_0__.getModelArchitecture)(modelId);\n            // Analysis stage\n            onProgress({\n                stage: \"analyzing\",\n                progress: 75,\n                message: \"Generating visualization...\"\n            });\n            const graph = {\n                nodes: architecture.nodes.map((node)=>({\n                        id: node.id,\n                        type: node.type,\n                        name: node.name,\n                        opType: node.type,\n                        params: node.params,\n                        flops: node.flops,\n                        memoryUsage: node.memoryUsage,\n                        inputShapes: [\n                            [\n                                1,\n                                3,\n                                224,\n                                224\n                            ]\n                        ],\n                        outputShapes: [\n                            [\n                                1,\n                                1000\n                            ]\n                        ],\n                        attributes: {}\n                    })),\n                edges: architecture.edges.map((edge)=>({\n                        id: \"\".concat(edge.source, \"-\").concat(edge.target),\n                        from: edge.source,\n                        to: edge.target,\n                        tensorShape: [\n                            1,\n                            1000\n                        ]\n                    })),\n                metadata: {\n                    framework: \"pytorch\",\n                    version: \"2.0\",\n                    totalParams: architecture.nodes.reduce((sum, node)=>sum + node.params, 0),\n                    totalFlops: architecture.nodes.reduce((sum, node)=>sum + node.flops, 0),\n                    totalMemory: architecture.nodes.reduce((sum, node)=>sum + node.memoryUsage, 0),\n                    modelId: modelId\n                }\n            };\n            // Complete\n            onProgress({\n                stage: \"complete\",\n                progress: 100,\n                message: \"Analysis complete\"\n            });\n            return {\n                graph,\n                performance: this.analyzePerformance(graph)\n            };\n        } catch (error) {\n            console.error(\"Model analysis failed:\", error);\n            throw error;\n        }\n    }\n    analyzePerformance(graph) {\n        // Calculate realistic performance metrics\n        const totalParams = Math.max(1, graph.metadata.totalParams);\n        const totalFlops = Math.max(1, graph.metadata.totalFlops);\n        const memoryPeak = Math.max(1024 * 1024, graph.metadata.totalMemory);\n        // Estimate inference time based on model complexity\n        const inferenceTime = Math.max(1, totalFlops / 1e9 * 0.5);\n        // Estimate device utilization based on model size\n        const deviceUtilization = Math.min(Math.max(0.1, totalParams / 1e9), 0.95);\n        return {\n            inferenceTime,\n            memoryPeak,\n            deviceUtilization\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC9hbmFseXplci50cyIsIm1hcHBpbmdzIjoiOzs7OzttRUFFeUQ7QUFHbEQsTUFBTUM7SUFDWCxNQUFNQyxhQUNKQyxPQUFlLEVBQ2ZDLFVBQWdELEVBQ3ZCO1FBQ3pCLElBQUk7WUFDRixnQkFBZ0I7WUFDaEJBLFdBQVc7Z0JBQ1RDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLFNBQVM7WUFDWDtZQUVBLG9EQUFvRDtZQUNwRCxNQUFNQyxlQUFlLE1BQU1SLHNFQUFvQkEsQ0FBQ0c7WUFFaEQsaUJBQWlCO1lBQ2pCQyxXQUFXO2dCQUNUQyxPQUFPO2dCQUNQQyxVQUFVO2dCQUNWQyxTQUFTO1lBQ1g7WUFFQSxNQUFNRSxRQUFvQjtnQkFDeEJDLE9BQU9GLGFBQWFFLEtBQUssQ0FBQ0MsR0FBRyxDQUFDQyxDQUFBQSxPQUFTO3dCQUNyQ0MsSUFBSUQsS0FBS0MsRUFBRTt3QkFDWEMsTUFBTUYsS0FBS0UsSUFBSTt3QkFDZkMsTUFBTUgsS0FBS0csSUFBSTt3QkFDZkMsUUFBUUosS0FBS0UsSUFBSTt3QkFDakJHLFFBQVFMLEtBQUtLLE1BQU07d0JBQ25CQyxPQUFPTixLQUFLTSxLQUFLO3dCQUNqQkMsYUFBYVAsS0FBS08sV0FBVzt3QkFDN0JDLGFBQWE7NEJBQUM7Z0NBQUM7Z0NBQUc7Z0NBQUc7Z0NBQUs7NkJBQUk7eUJBQUM7d0JBQy9CQyxjQUFjOzRCQUFDO2dDQUFDO2dDQUFHOzZCQUFLO3lCQUFDO3dCQUN6QkMsWUFBWSxDQUFDO29CQUNmO2dCQUNBQyxPQUFPZixhQUFhZSxLQUFLLENBQUNaLEdBQUcsQ0FBQ2EsQ0FBQUEsT0FBUzt3QkFDckNYLElBQUksR0FBa0JXLE9BQWZBLEtBQUtDLE1BQU0sRUFBQyxLQUFlLE9BQVpELEtBQUtFLE1BQU07d0JBQ2pDQyxNQUFNSCxLQUFLQyxNQUFNO3dCQUNqQkcsSUFBSUosS0FBS0UsTUFBTTt3QkFDZkcsYUFBYTs0QkFBQzs0QkFBRzt5QkFBSztvQkFDeEI7Z0JBQ0FDLFVBQVU7b0JBQ1JDLFdBQVc7b0JBQ1hDLFNBQVM7b0JBQ1RDLGFBQWF6QixhQUFhRSxLQUFLLENBQUN3QixNQUFNLENBQUMsQ0FBQ0MsS0FBS3ZCLE9BQVN1QixNQUFNdkIsS0FBS0ssTUFBTSxFQUFFO29CQUN6RW1CLFlBQVk1QixhQUFhRSxLQUFLLENBQUN3QixNQUFNLENBQUMsQ0FBQ0MsS0FBS3ZCLE9BQVN1QixNQUFNdkIsS0FBS00sS0FBSyxFQUFFO29CQUN2RW1CLGFBQWE3QixhQUFhRSxLQUFLLENBQUN3QixNQUFNLENBQUMsQ0FBQ0MsS0FBS3ZCLE9BQVN1QixNQUFNdkIsS0FBS08sV0FBVyxFQUFFO29CQUM5RWhCLFNBQVNBO2dCQUNYO1lBQ0Y7WUFFQSxXQUFXO1lBQ1hDLFdBQVc7Z0JBQ1RDLE9BQU87Z0JBQ1BDLFVBQVU7Z0JBQ1ZDLFNBQVM7WUFDWDtZQUVBLE9BQU87Z0JBQ0xFO2dCQUNBNkIsYUFBYSxJQUFJLENBQUNDLGtCQUFrQixDQUFDOUI7WUFDdkM7UUFFRixFQUFFLE9BQU8rQixPQUFPO1lBQ2RDLFFBQVFELEtBQUssQ0FBQywwQkFBMEJBO1lBQ3hDLE1BQU1BO1FBQ1I7SUFDRjtJQUVRRCxtQkFBbUI5QixLQUFpQixFQUFFO1FBQzVDLDBDQUEwQztRQUMxQyxNQUFNd0IsY0FBY1MsS0FBS0MsR0FBRyxDQUFDLEdBQUdsQyxNQUFNcUIsUUFBUSxDQUFDRyxXQUFXO1FBQzFELE1BQU1HLGFBQWFNLEtBQUtDLEdBQUcsQ0FBQyxHQUFHbEMsTUFBTXFCLFFBQVEsQ0FBQ00sVUFBVTtRQUN4RCxNQUFNUSxhQUFhRixLQUFLQyxHQUFHLENBQUMsT0FBTyxNQUFNbEMsTUFBTXFCLFFBQVEsQ0FBQ08sV0FBVztRQUVuRSxvREFBb0Q7UUFDcEQsTUFBTVEsZ0JBQWdCSCxLQUFLQyxHQUFHLENBQUMsR0FBRyxhQUFjLE1BQU87UUFFdkQsa0RBQWtEO1FBQ2xELE1BQU1HLG9CQUFvQkosS0FBS0ssR0FBRyxDQUFDTCxLQUFLQyxHQUFHLENBQUMsS0FBS1YsY0FBYyxNQUFNO1FBRXJFLE9BQU87WUFDTFk7WUFDQUQ7WUFDQUU7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL21vZGVsL2FuYWx5emVyLnRzP2I3NTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IGdldE1vZGVsQXJjaGl0ZWN0dXJlIH0gZnJvbSAnQC9saWIvaHVnZ2luZ2ZhY2UnO1xuaW1wb3J0IHsgTW9kZWxHcmFwaCwgQW5hbHlzaXNQcm9ncmVzcywgQW5hbHlzaXNSZXN1bHQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNsYXNzIE1vZGVsQW5hbHl6ZXIge1xuICBhc3luYyBhbmFseXplTW9kZWwoXG4gICAgbW9kZWxJZDogc3RyaW5nLFxuICAgIG9uUHJvZ3Jlc3M6IChwcm9ncmVzczogQW5hbHlzaXNQcm9ncmVzcykgPT4gdm9pZFxuICApOiBQcm9taXNlPEFuYWx5c2lzUmVzdWx0PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvYWRpbmcgc3RhZ2VcbiAgICAgIG9uUHJvZ3Jlc3Moe1xuICAgICAgICBzdGFnZTogJ2xvYWRpbmcnLFxuICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgbWVzc2FnZTogJ0xvYWRpbmcgbW9kZWwgaW5mb3JtYXRpb24uLi4nXG4gICAgICB9KTtcblxuICAgICAgLy8gU2tpcCBBUEkgY2FsbCBhbmQgdXNlIGxvY2FsIGFyY2hpdGVjdHVyZSBkaXJlY3RseVxuICAgICAgY29uc3QgYXJjaGl0ZWN0dXJlID0gYXdhaXQgZ2V0TW9kZWxBcmNoaXRlY3R1cmUobW9kZWxJZCk7XG5cbiAgICAgIC8vIEFuYWx5c2lzIHN0YWdlXG4gICAgICBvblByb2dyZXNzKHtcbiAgICAgICAgc3RhZ2U6ICdhbmFseXppbmcnLFxuICAgICAgICBwcm9ncmVzczogNzUsXG4gICAgICAgIG1lc3NhZ2U6ICdHZW5lcmF0aW5nIHZpc3VhbGl6YXRpb24uLi4nXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZ3JhcGg6IE1vZGVsR3JhcGggPSB7XG4gICAgICAgIG5vZGVzOiBhcmNoaXRlY3R1cmUubm9kZXMubWFwKG5vZGUgPT4gKHtcbiAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICB0eXBlOiBub2RlLnR5cGUgYXMgYW55LFxuICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICBvcFR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICBwYXJhbXM6IG5vZGUucGFyYW1zLFxuICAgICAgICAgIGZsb3BzOiBub2RlLmZsb3BzLFxuICAgICAgICAgIG1lbW9yeVVzYWdlOiBub2RlLm1lbW9yeVVzYWdlLFxuICAgICAgICAgIGlucHV0U2hhcGVzOiBbWzEsIDMsIDIyNCwgMjI0XV0sXG4gICAgICAgICAgb3V0cHV0U2hhcGVzOiBbWzEsIDEwMDBdXSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7fVxuICAgICAgICB9KSksXG4gICAgICAgIGVkZ2VzOiBhcmNoaXRlY3R1cmUuZWRnZXMubWFwKGVkZ2UgPT4gKHtcbiAgICAgICAgICBpZDogYCR7ZWRnZS5zb3VyY2V9LSR7ZWRnZS50YXJnZXR9YCxcbiAgICAgICAgICBmcm9tOiBlZGdlLnNvdXJjZSxcbiAgICAgICAgICB0bzogZWRnZS50YXJnZXQsXG4gICAgICAgICAgdGVuc29yU2hhcGU6IFsxLCAxMDAwXVxuICAgICAgICB9KSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgZnJhbWV3b3JrOiAncHl0b3JjaCcsXG4gICAgICAgICAgdmVyc2lvbjogJzIuMCcsXG4gICAgICAgICAgdG90YWxQYXJhbXM6IGFyY2hpdGVjdHVyZS5ub2Rlcy5yZWR1Y2UoKHN1bSwgbm9kZSkgPT4gc3VtICsgbm9kZS5wYXJhbXMsIDApLFxuICAgICAgICAgIHRvdGFsRmxvcHM6IGFyY2hpdGVjdHVyZS5ub2Rlcy5yZWR1Y2UoKHN1bSwgbm9kZSkgPT4gc3VtICsgbm9kZS5mbG9wcywgMCksXG4gICAgICAgICAgdG90YWxNZW1vcnk6IGFyY2hpdGVjdHVyZS5ub2Rlcy5yZWR1Y2UoKHN1bSwgbm9kZSkgPT4gc3VtICsgbm9kZS5tZW1vcnlVc2FnZSwgMCksXG4gICAgICAgICAgbW9kZWxJZDogbW9kZWxJZFxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBDb21wbGV0ZVxuICAgICAgb25Qcm9ncmVzcyh7XG4gICAgICAgIHN0YWdlOiAnY29tcGxldGUnLFxuICAgICAgICBwcm9ncmVzczogMTAwLFxuICAgICAgICBtZXNzYWdlOiAnQW5hbHlzaXMgY29tcGxldGUnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ3JhcGgsXG4gICAgICAgIHBlcmZvcm1hbmNlOiB0aGlzLmFuYWx5emVQZXJmb3JtYW5jZShncmFwaClcbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignTW9kZWwgYW5hbHlzaXMgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYW5hbHl6ZVBlcmZvcm1hbmNlKGdyYXBoOiBNb2RlbEdyYXBoKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHJlYWxpc3RpYyBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gICAgY29uc3QgdG90YWxQYXJhbXMgPSBNYXRoLm1heCgxLCBncmFwaC5tZXRhZGF0YS50b3RhbFBhcmFtcyk7XG4gICAgY29uc3QgdG90YWxGbG9wcyA9IE1hdGgubWF4KDEsIGdyYXBoLm1ldGFkYXRhLnRvdGFsRmxvcHMpO1xuICAgIGNvbnN0IG1lbW9yeVBlYWsgPSBNYXRoLm1heCgxMDI0ICogMTAyNCwgZ3JhcGgubWV0YWRhdGEudG90YWxNZW1vcnkpO1xuXG4gICAgLy8gRXN0aW1hdGUgaW5mZXJlbmNlIHRpbWUgYmFzZWQgb24gbW9kZWwgY29tcGxleGl0eVxuICAgIGNvbnN0IGluZmVyZW5jZVRpbWUgPSBNYXRoLm1heCgxLCAodG90YWxGbG9wcyAvIDFlOSkgKiAwLjUpO1xuICAgIFxuICAgIC8vIEVzdGltYXRlIGRldmljZSB1dGlsaXphdGlvbiBiYXNlZCBvbiBtb2RlbCBzaXplXG4gICAgY29uc3QgZGV2aWNlVXRpbGl6YXRpb24gPSBNYXRoLm1pbihNYXRoLm1heCgwLjEsIHRvdGFsUGFyYW1zIC8gMWU5KSwgMC45NSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5mZXJlbmNlVGltZSxcbiAgICAgIG1lbW9yeVBlYWssXG4gICAgICBkZXZpY2VVdGlsaXphdGlvblxuICAgIH07XG4gIH1cbn0iXSwibmFtZXMiOlsiZ2V0TW9kZWxBcmNoaXRlY3R1cmUiLCJNb2RlbEFuYWx5emVyIiwiYW5hbHl6ZU1vZGVsIiwibW9kZWxJZCIsIm9uUHJvZ3Jlc3MiLCJzdGFnZSIsInByb2dyZXNzIiwibWVzc2FnZSIsImFyY2hpdGVjdHVyZSIsImdyYXBoIiwibm9kZXMiLCJtYXAiLCJub2RlIiwiaWQiLCJ0eXBlIiwibmFtZSIsIm9wVHlwZSIsInBhcmFtcyIsImZsb3BzIiwibWVtb3J5VXNhZ2UiLCJpbnB1dFNoYXBlcyIsIm91dHB1dFNoYXBlcyIsImF0dHJpYnV0ZXMiLCJlZGdlcyIsImVkZ2UiLCJzb3VyY2UiLCJ0YXJnZXQiLCJmcm9tIiwidG8iLCJ0ZW5zb3JTaGFwZSIsIm1ldGFkYXRhIiwiZnJhbWV3b3JrIiwidmVyc2lvbiIsInRvdGFsUGFyYW1zIiwicmVkdWNlIiwic3VtIiwidG90YWxGbG9wcyIsInRvdGFsTWVtb3J5IiwicGVyZm9ybWFuY2UiLCJhbmFseXplUGVyZm9ybWFuY2UiLCJlcnJvciIsImNvbnNvbGUiLCJNYXRoIiwibWF4IiwibWVtb3J5UGVhayIsImluZmVyZW5jZVRpbWUiLCJkZXZpY2VVdGlsaXphdGlvbiIsIm1pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model/analyzer.ts\n"));

/***/ })

});