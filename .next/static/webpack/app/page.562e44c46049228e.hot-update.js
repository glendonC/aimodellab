"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/huggingface.ts":
/*!****************************!*\
  !*** ./lib/huggingface.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FEATURED_MODELS: function() { return /* binding */ FEATURED_MODELS; },\n/* harmony export */   getModelArchitecture: function() { return /* binding */ getModelArchitecture; },\n/* harmony export */   getModelInfo: function() { return /* binding */ getModelInfo; },\n/* harmony export */   searchModels: function() { return /* binding */ searchModels; }\n/* harmony export */ });\n/* harmony import */ var _model_architectures__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model-architectures */ \"(app-pages-browser)/./lib/model-architectures.ts\");\nconst FEATURED_MODELS = [\n    // Vision Models (GPU-Intensive)\n    {\n        id: \"microsoft/resnet-50\",\n        name: \"ResNet-50\",\n        description: \"State-of-the-art image classification model with CUDA optimization\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"ResNet\",\n        size: \"98 MB\",\n        downloads: 2500000,\n        likes: 1200,\n        tags: [\n            \"computer-vision\",\n            \"classification\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"nvidia/stable-diffusion-v1.5\",\n        name: \"Stable Diffusion v1.5\",\n        description: \"Optimized for NVIDIA GPUs with tensor core acceleration\",\n        type: \"vision\",\n        task: \"text-to-image\",\n        architecture: \"Diffusion\",\n        size: \"7.7 GB\",\n        downloads: 5800000,\n        likes: 3200,\n        tags: [\n            \"generative-ai\",\n            \"text-to-image\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"yolov8\",\n        name: \"YOLOv8\",\n        description: \"Real-time object detection with CUDA acceleration\",\n        type: \"vision\",\n        task: \"object-detection\",\n        architecture: \"YOLO\",\n        size: \"108 MB\",\n        downloads: 4200000,\n        likes: 2800,\n        tags: [\n            \"object-detection\",\n            \"real-time\",\n            \"tensorrt\"\n        ]\n    },\n    // Large Language Models\n    {\n        id: \"meta-llama/llama-2-7b\",\n        name: \"Llama 2 (7B)\",\n        description: \"Efficient large language model with multi-GPU scaling\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"13.5 GB\",\n        downloads: 8500000,\n        likes: 4500,\n        tags: [\n            \"llm\",\n            \"multi-gpu\",\n            \"fp16-optimized\"\n        ]\n    },\n    {\n        id: \"openai/gpt-2\",\n        name: \"GPT-2 Small\",\n        description: \"Compact language model with GPU acceleration\",\n        type: \"text\",\n        task: \"text-generation\",\n        architecture: \"Transformer\",\n        size: \"1.5 GB\",\n        downloads: 3800000,\n        likes: 2100,\n        tags: [\n            \"nlp\",\n            \"text-generation\",\n            \"cuda\"\n        ]\n    },\n    // Specialized Models\n    {\n        id: \"facebook/bart-large-cnn\",\n        name: \"BART Large CNN\",\n        description: \"GPU-accelerated text summarization model\",\n        type: \"text\",\n        task: \"summarization\",\n        architecture: \"Transformer\",\n        size: \"1.6 GB\",\n        downloads: 1800000,\n        likes: 950,\n        tags: [\n            \"nlp\",\n            \"summarization\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"openai/whisper-base\",\n        name: \"Whisper Base\",\n        description: \"Speech recognition optimized for NVIDIA GPUs\",\n        type: \"audio\",\n        task: \"speech-recognition\",\n        architecture: \"Transformer\",\n        size: \"442 MB\",\n        downloads: 2900000,\n        likes: 1600,\n        tags: [\n            \"speech\",\n            \"audio\",\n            \"cuda-optimized\"\n        ]\n    },\n    {\n        id: \"google/vit-base-patch16-224\",\n        name: \"ViT Base\",\n        description: \"Vision Transformer with tensor core acceleration\",\n        type: \"vision\",\n        task: \"image-classification\",\n        architecture: \"Transformer\",\n        size: \"346 MB\",\n        downloads: 3200000,\n        likes: 1500,\n        tags: [\n            \"vision\",\n            \"transformers\",\n            \"tensor-cores\"\n        ]\n    },\n    {\n        id: \"dmis-lab/biobert-base\",\n        name: \"BioBERT\",\n        description: \"Biomedical language model with GPU optimization\",\n        type: \"text\",\n        task: \"text-classification\",\n        architecture: \"BERT\",\n        size: \"412 MB\",\n        downloads: 890000,\n        likes: 720,\n        tags: [\n            \"healthcare\",\n            \"nlp\",\n            \"cuda\"\n        ]\n    },\n    {\n        id: \"facebook/dinov2-base\",\n        name: \"DINOv2\",\n        description: \"Self-supervised vision model with NVIDIA acceleration\",\n        type: \"vision\",\n        task: \"self-supervised-learning\",\n        architecture: \"Transformer\",\n        size: \"384 MB\",\n        downloads: 1200000,\n        likes: 890,\n        tags: [\n            \"self-supervised\",\n            \"vision\",\n            \"cuda\"\n        ]\n    }\n];\nasync function searchModels(query) {\n    try {\n        const response = await fetch(\"https://huggingface.co/api/models?search=\".concat(encodeURIComponent(query)), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const text = await response.text();\n        if (!text) {\n            return [];\n        }\n        let data;\n        try {\n            data = JSON.parse(text);\n        } catch (e) {\n            console.error(\"Failed to parse response:\", e);\n            return [];\n        }\n        if (!Array.isArray(data)) {\n            console.error(\"Unexpected response format:\", data);\n            return [];\n        }\n        return data.map((model)=>{\n            var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n            return {\n                id: model.modelId || model.id,\n                name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n                description: model.description || \"No description available\",\n                type: determineModelType(model.pipeline_tag),\n                task: model.pipeline_tag || \"unknown\",\n                architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n                size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n                downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n                likes: model.likes || 0,\n                tags: [\n                    model.pipeline_tag,\n                    ...model.tags || [],\n                    model.library_name\n                ].filter(Boolean)\n            };\n        });\n    } catch (error) {\n        console.error(\"Failed to search models:\", error);\n        return [];\n    }\n}\nfunction determineModelType(pipelineTag) {\n    if (!pipelineTag) return \"vision\";\n    const visionTasks = [\n        \"image-classification\",\n        \"object-detection\",\n        \"image-segmentation\"\n    ];\n    const textTasks = [\n        \"text-classification\",\n        \"text-generation\",\n        \"translation\"\n    ];\n    const audioTasks = [\n        \"audio-classification\",\n        \"speech-recognition\"\n    ];\n    if (visionTasks.includes(pipelineTag)) return \"vision\";\n    if (textTasks.includes(pipelineTag)) return \"text\";\n    if (audioTasks.includes(pipelineTag)) return \"audio\";\n    return \"multimodal\";\n}\nfunction formatSize(bytes) {\n    if (bytes === 0) return \"0 B\";\n    const k = 1024;\n    const sizes = [\n        \"B\",\n        \"KB\",\n        \"MB\",\n        \"GB\",\n        \"TB\"\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + \" \" + sizes[i];\n}\nasync function getModelInfo(modelId) {\n    try {\n        var _this, _model_config_architectures, _model_config, _model_downloads_binary, _model_downloads, _model_downloads1;\n        const response = await fetch(\"https://huggingface.co/api/models/\".concat(modelId), {\n            headers: {\n                \"Accept\": \"application/json\"\n            }\n        });\n        if (!response.ok) {\n            throw new Error(\"Model not found\");\n        }\n        const model = await response.json();\n        return {\n            id: model.modelId || model.id,\n            name: ((_this = model.modelId || model.id) === null || _this === void 0 ? void 0 : _this.split(\"/\").pop()) || \"Unknown Model\",\n            description: model.description || \"No description available\",\n            type: determineModelType(model.pipeline_tag),\n            task: model.pipeline_tag || \"unknown\",\n            architecture: ((_model_config = model.config) === null || _model_config === void 0 ? void 0 : (_model_config_architectures = _model_config.architectures) === null || _model_config_architectures === void 0 ? void 0 : _model_config_architectures[0]) || \"unknown\",\n            size: formatSize(((_model_downloads = model.downloads) === null || _model_downloads === void 0 ? void 0 : (_model_downloads_binary = _model_downloads.binary) === null || _model_downloads_binary === void 0 ? void 0 : _model_downloads_binary.size) || 0),\n            downloads: ((_model_downloads1 = model.downloads) === null || _model_downloads1 === void 0 ? void 0 : _model_downloads1.total) || 0,\n            likes: model.likes || 0,\n            tags: [\n                model.pipeline_tag,\n                ...model.tags || [],\n                model.library_name\n            ].filter(Boolean)\n        };\n    } catch (error) {\n        console.error(\"Failed to get model info:\", error);\n        throw error;\n    }\n}\nasync function getModelArchitecture(modelId) {\n    switch(modelId){\n        case \"microsoft/resnet-50\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateResNetArchitecture)();\n        case \"facebook/bart-large-cnn\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateTransformerArchitecture)();\n        case \"google/vit-base-patch16-224\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateViTArchitecture)();\n        case \"nvidia/stable-diffusion-v1.5\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateStableDiffusionArchitecture)();\n        case \"meta-llama/llama-2-7b\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateLlama2Architecture)();\n        case \"yolov8\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateYOLOv8Architecture)();\n        case \"openai/gpt-2\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateGPT2Architecture)();\n        case \"openai/whisper-base\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateWhisperArchitecture)();\n        case \"dmis-lab/biobert-base\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateBioBERTArchitecture)();\n        case \"facebook/dinov2-base\":\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateDINOv2Architecture)();\n        default:\n            return (0,_model_architectures__WEBPACK_IMPORTED_MODULE_0__.generateDefaultArchitecture)();\n    }\n}\n// Import architecture generation functions\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNGO0FBRU8sZUFBZW1DLHFCQUFxQjlCLE9BQWU7SUFDeEQsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTytCLGdGQUEwQkE7UUFDbkMsS0FBSztZQUNILE9BQU9DLHFGQUErQkE7UUFDeEMsS0FBSztZQUNILE9BQU9DLDZFQUF1QkE7UUFDaEMsS0FBSztZQUNILE9BQU9DLHlGQUFtQ0E7UUFDNUMsS0FBSztZQUNILE9BQU9DLGdGQUEwQkE7UUFDbkMsS0FBSztZQUNILE9BQU9DLGdGQUEwQkE7UUFDbkMsS0FBSztZQUNILE9BQU9DLDhFQUF3QkE7UUFDakMsS0FBSztZQUNILE9BQU9DLGlGQUEyQkE7UUFDcEMsS0FBSztZQUNILE9BQU9DLGlGQUEyQkE7UUFDcEMsS0FBSztZQUNILE9BQU9DLGdGQUEwQkE7UUFDbkM7WUFDRSxPQUFPQyxpRkFBMkJBO0lBQ3RDO0FBQ0Y7QUFFQSwyQ0FBMkM7QUFhWiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvaHVnZ2luZ2ZhY2UudHM/YTBmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIZkluZmVyZW5jZSB9IGZyb20gJ0BodWdnaW5nZmFjZS9pbmZlcmVuY2UnO1xuXG5leHBvcnQgdHlwZSBIRk1vZGVsID0ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHR5cGU6ICd2aXNpb24nIHwgJ3RleHQnIHwgJ2F1ZGlvJyB8ICdtdWx0aW1vZGFsJztcbiAgdGFzazogc3RyaW5nO1xuICBhcmNoaXRlY3R1cmU6IHN0cmluZztcbiAgc2l6ZTogc3RyaW5nO1xuICBkb3dubG9hZHM6IG51bWJlcjtcbiAgbGlrZXM6IG51bWJlcjtcbiAgdGFnczogc3RyaW5nW107XG59O1xuXG5leHBvcnQgdHlwZSBNb2RlbEFyY2hpdGVjdHVyZSA9IHtcbiAgbm9kZXM6IEFycmF5PHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcGFyYW1zOiBudW1iZXI7XG4gICAgZmxvcHM6IG51bWJlcjtcbiAgICBtZW1vcnlVc2FnZTogbnVtYmVyO1xuICB9PjtcbiAgZWRnZXM6IEFycmF5PHtcbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICB0YXJnZXQ6IHN0cmluZztcbiAgfT47XG59O1xuXG5leHBvcnQgY29uc3QgRkVBVFVSRURfTU9ERUxTOiBIRk1vZGVsW10gPSBbXG4gIC8vIFZpc2lvbiBNb2RlbHMgKEdQVS1JbnRlbnNpdmUpXG4gIHtcbiAgICBpZDogJ21pY3Jvc29mdC9yZXNuZXQtNTAnLFxuICAgIG5hbWU6ICdSZXNOZXQtNTAnLFxuICAgIGRlc2NyaXB0aW9uOiAnU3RhdGUtb2YtdGhlLWFydCBpbWFnZSBjbGFzc2lmaWNhdGlvbiBtb2RlbCB3aXRoIENVREEgb3B0aW1pemF0aW9uJyxcbiAgICB0eXBlOiAndmlzaW9uJyxcbiAgICB0YXNrOiAnaW1hZ2UtY2xhc3NpZmljYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1Jlc05ldCcsXG4gICAgc2l6ZTogJzk4IE1CJyxcbiAgICBkb3dubG9hZHM6IDI1MDAwMDAsXG4gICAgbGlrZXM6IDEyMDAsXG4gICAgdGFnczogWydjb21wdXRlci12aXNpb24nLCAnY2xhc3NpZmljYXRpb24nLCAnY3VkYS1vcHRpbWl6ZWQnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdudmlkaWEvc3RhYmxlLWRpZmZ1c2lvbi12MS41JyxcbiAgICBuYW1lOiAnU3RhYmxlIERpZmZ1c2lvbiB2MS41JyxcbiAgICBkZXNjcmlwdGlvbjogJ09wdGltaXplZCBmb3IgTlZJRElBIEdQVXMgd2l0aCB0ZW5zb3IgY29yZSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICd0ZXh0LXRvLWltYWdlJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdEaWZmdXNpb24nLFxuICAgIHNpemU6ICc3LjcgR0InLFxuICAgIGRvd25sb2FkczogNTgwMDAwMCxcbiAgICBsaWtlczogMzIwMCxcbiAgICB0YWdzOiBbJ2dlbmVyYXRpdmUtYWknLCAndGV4dC10by1pbWFnZScsICd0ZW5zb3ItY29yZXMnXVxuICB9LFxuICB7XG4gICAgaWQ6ICd5b2xvdjgnLFxuICAgIG5hbWU6ICdZT0xPdjgnLFxuICAgIGRlc2NyaXB0aW9uOiAnUmVhbC10aW1lIG9iamVjdCBkZXRlY3Rpb24gd2l0aCBDVURBIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3Zpc2lvbicsXG4gICAgdGFzazogJ29iamVjdC1kZXRlY3Rpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1lPTE8nLFxuICAgIHNpemU6ICcxMDggTUInLFxuICAgIGRvd25sb2FkczogNDIwMDAwMCxcbiAgICBsaWtlczogMjgwMCxcbiAgICB0YWdzOiBbJ29iamVjdC1kZXRlY3Rpb24nLCAncmVhbC10aW1lJywgJ3RlbnNvcnJ0J11cbiAgfSxcbiAgXG4gIC8vIExhcmdlIExhbmd1YWdlIE1vZGVsc1xuICB7XG4gICAgaWQ6ICdtZXRhLWxsYW1hL2xsYW1hLTItN2InLFxuICAgIG5hbWU6ICdMbGFtYSAyICg3QiknLFxuICAgIGRlc2NyaXB0aW9uOiAnRWZmaWNpZW50IGxhcmdlIGxhbmd1YWdlIG1vZGVsIHdpdGggbXVsdGktR1BVIHNjYWxpbmcnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICB0YXNrOiAndGV4dC1nZW5lcmF0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzEzLjUgR0InLFxuICAgIGRvd25sb2FkczogODUwMDAwMCxcbiAgICBsaWtlczogNDUwMCxcbiAgICB0YWdzOiBbJ2xsbScsICdtdWx0aS1ncHUnLCAnZnAxNi1vcHRpbWl6ZWQnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdvcGVuYWkvZ3B0LTInLFxuICAgIG5hbWU6ICdHUFQtMiBTbWFsbCcsXG4gICAgZGVzY3JpcHRpb246ICdDb21wYWN0IGxhbmd1YWdlIG1vZGVsIHdpdGggR1BVIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3RleHQnLFxuICAgIHRhc2s6ICd0ZXh0LWdlbmVyYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnMS41IEdCJyxcbiAgICBkb3dubG9hZHM6IDM4MDAwMDAsXG4gICAgbGlrZXM6IDIxMDAsXG4gICAgdGFnczogWydubHAnLCAndGV4dC1nZW5lcmF0aW9uJywgJ2N1ZGEnXVxuICB9LFxuXG4gIC8vIFNwZWNpYWxpemVkIE1vZGVsc1xuICB7XG4gICAgaWQ6ICdmYWNlYm9vay9iYXJ0LWxhcmdlLWNubicsXG4gICAgbmFtZTogJ0JBUlQgTGFyZ2UgQ05OJyxcbiAgICBkZXNjcmlwdGlvbjogJ0dQVS1hY2NlbGVyYXRlZCB0ZXh0IHN1bW1hcml6YXRpb24gbW9kZWwnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICB0YXNrOiAnc3VtbWFyaXphdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICcxLjYgR0InLFxuICAgIGRvd25sb2FkczogMTgwMDAwMCxcbiAgICBsaWtlczogOTUwLFxuICAgIHRhZ3M6IFsnbmxwJywgJ3N1bW1hcml6YXRpb24nLCAnY3VkYSddXG4gIH0sXG4gIHtcbiAgICBpZDogJ29wZW5haS93aGlzcGVyLWJhc2UnLFxuICAgIG5hbWU6ICdXaGlzcGVyIEJhc2UnLFxuICAgIGRlc2NyaXB0aW9uOiAnU3BlZWNoIHJlY29nbml0aW9uIG9wdGltaXplZCBmb3IgTlZJRElBIEdQVXMnLFxuICAgIHR5cGU6ICdhdWRpbycsXG4gICAgdGFzazogJ3NwZWVjaC1yZWNvZ25pdGlvbicsXG4gICAgYXJjaGl0ZWN0dXJlOiAnVHJhbnNmb3JtZXInLFxuICAgIHNpemU6ICc0NDIgTUInLFxuICAgIGRvd25sb2FkczogMjkwMDAwMCxcbiAgICBsaWtlczogMTYwMCxcbiAgICB0YWdzOiBbJ3NwZWVjaCcsICdhdWRpbycsICdjdWRhLW9wdGltaXplZCddXG4gIH0sXG4gIHtcbiAgICBpZDogJ2dvb2dsZS92aXQtYmFzZS1wYXRjaDE2LTIyNCcsXG4gICAgbmFtZTogJ1ZpVCBCYXNlJyxcbiAgICBkZXNjcmlwdGlvbjogJ1Zpc2lvbiBUcmFuc2Zvcm1lciB3aXRoIHRlbnNvciBjb3JlIGFjY2VsZXJhdGlvbicsXG4gICAgdHlwZTogJ3Zpc2lvbicsXG4gICAgdGFzazogJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJyxcbiAgICBhcmNoaXRlY3R1cmU6ICdUcmFuc2Zvcm1lcicsXG4gICAgc2l6ZTogJzM0NiBNQicsXG4gICAgZG93bmxvYWRzOiAzMjAwMDAwLFxuICAgIGxpa2VzOiAxNTAwLFxuICAgIHRhZ3M6IFsndmlzaW9uJywgJ3RyYW5zZm9ybWVycycsICd0ZW5zb3ItY29yZXMnXVxuICB9LFxuICB7XG4gICAgaWQ6ICdkbWlzLWxhYi9iaW9iZXJ0LWJhc2UnLFxuICAgIG5hbWU6ICdCaW9CRVJUJyxcbiAgICBkZXNjcmlwdGlvbjogJ0Jpb21lZGljYWwgbGFuZ3VhZ2UgbW9kZWwgd2l0aCBHUFUgb3B0aW1pemF0aW9uJyxcbiAgICB0eXBlOiAndGV4dCcsXG4gICAgdGFzazogJ3RleHQtY2xhc3NpZmljYXRpb24nLFxuICAgIGFyY2hpdGVjdHVyZTogJ0JFUlQnLFxuICAgIHNpemU6ICc0MTIgTUInLFxuICAgIGRvd25sb2FkczogODkwMDAwLFxuICAgIGxpa2VzOiA3MjAsXG4gICAgdGFnczogWydoZWFsdGhjYXJlJywgJ25scCcsICdjdWRhJ11cbiAgfSxcbiAge1xuICAgIGlkOiAnZmFjZWJvb2svZGlub3YyLWJhc2UnLFxuICAgIG5hbWU6ICdESU5PdjInLFxuICAgIGRlc2NyaXB0aW9uOiAnU2VsZi1zdXBlcnZpc2VkIHZpc2lvbiBtb2RlbCB3aXRoIE5WSURJQSBhY2NlbGVyYXRpb24nLFxuICAgIHR5cGU6ICd2aXNpb24nLFxuICAgIHRhc2s6ICdzZWxmLXN1cGVydmlzZWQtbGVhcm5pbmcnLFxuICAgIGFyY2hpdGVjdHVyZTogJ1RyYW5zZm9ybWVyJyxcbiAgICBzaXplOiAnMzg0IE1CJyxcbiAgICBkb3dubG9hZHM6IDEyMDAwMDAsXG4gICAgbGlrZXM6IDg5MCxcbiAgICB0YWdzOiBbJ3NlbGYtc3VwZXJ2aXNlZCcsICd2aXNpb24nLCAnY3VkYSddXG4gIH1cbl07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hNb2RlbHMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8SEZNb2RlbFtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGBodHRwczovL2h1Z2dpbmdmYWNlLmNvL2FwaS9tb2RlbHM/c2VhcmNoPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KX1gLFxuICAgICAge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIGlmICghdGV4dCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2U6JywgZSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdDonLCBkYXRhKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5tYXAoKG1vZGVsOiBhbnkpID0+ICh7XG4gICAgICBpZDogbW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCxcbiAgICAgIG5hbWU6IChtb2RlbC5tb2RlbElkIHx8IG1vZGVsLmlkKT8uc3BsaXQoJy8nKS5wb3AoKSB8fCAnVW5rbm93biBNb2RlbCcsXG4gICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZScsXG4gICAgICB0eXBlOiBkZXRlcm1pbmVNb2RlbFR5cGUobW9kZWwucGlwZWxpbmVfdGFnKSxcbiAgICAgIHRhc2s6IG1vZGVsLnBpcGVsaW5lX3RhZyB8fCAndW5rbm93bicsXG4gICAgICBhcmNoaXRlY3R1cmU6IG1vZGVsLmNvbmZpZz8uYXJjaGl0ZWN0dXJlcz8uWzBdIHx8ICd1bmtub3duJyxcbiAgICAgIHNpemU6IGZvcm1hdFNpemUobW9kZWwuZG93bmxvYWRzPy5iaW5hcnk/LnNpemUgfHwgMCksXG4gICAgICBkb3dubG9hZHM6IG1vZGVsLmRvd25sb2Fkcz8udG90YWwgfHwgMCxcbiAgICAgIGxpa2VzOiBtb2RlbC5saWtlcyB8fCAwLFxuICAgICAgdGFnczogW1xuICAgICAgICBtb2RlbC5waXBlbGluZV90YWcsXG4gICAgICAgIC4uLihtb2RlbC50YWdzIHx8IFtdKSxcbiAgICAgICAgbW9kZWwubGlicmFyeV9uYW1lXG4gICAgICBdLmZpbHRlcihCb29sZWFuKVxuICAgIH0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VhcmNoIG1vZGVsczonLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZU1vZGVsVHlwZShwaXBlbGluZVRhZzogc3RyaW5nKTogSEZNb2RlbFsndHlwZSddIHtcbiAgaWYgKCFwaXBlbGluZVRhZykgcmV0dXJuICd2aXNpb24nO1xuICBcbiAgY29uc3QgdmlzaW9uVGFza3MgPSBbJ2ltYWdlLWNsYXNzaWZpY2F0aW9uJywgJ29iamVjdC1kZXRlY3Rpb24nLCAnaW1hZ2Utc2VnbWVudGF0aW9uJ107XG4gIGNvbnN0IHRleHRUYXNrcyA9IFsndGV4dC1jbGFzc2lmaWNhdGlvbicsICd0ZXh0LWdlbmVyYXRpb24nLCAndHJhbnNsYXRpb24nXTtcbiAgY29uc3QgYXVkaW9UYXNrcyA9IFsnYXVkaW8tY2xhc3NpZmljYXRpb24nLCAnc3BlZWNoLXJlY29nbml0aW9uJ107XG4gIFxuICBpZiAodmlzaW9uVGFza3MuaW5jbHVkZXMocGlwZWxpbmVUYWcpKSByZXR1cm4gJ3Zpc2lvbic7XG4gIGlmICh0ZXh0VGFza3MuaW5jbHVkZXMocGlwZWxpbmVUYWcpKSByZXR1cm4gJ3RleHQnO1xuICBpZiAoYXVkaW9UYXNrcy5pbmNsdWRlcyhwaXBlbGluZVRhZykpIHJldHVybiAnYXVkaW8nO1xuICByZXR1cm4gJ211bHRpbW9kYWwnO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTaXplKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoYnl0ZXMgPT09IDApIHJldHVybiAnMCBCJztcbiAgY29uc3QgayA9IDEwMjQ7XG4gIGNvbnN0IHNpemVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ107XG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoKGJ5dGVzIC8gTWF0aC5wb3coaywgaSkpLnRvRml4ZWQoMSkpICsgJyAnICsgc2l6ZXNbaV07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2RlbEluZm8obW9kZWxJZDogc3RyaW5nKTogUHJvbWlzZTxIRk1vZGVsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9odWdnaW5nZmFjZS5jby9hcGkvbW9kZWxzLyR7bW9kZWxJZH1gLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIG5vdCBmb3VuZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IG1vZGVsID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogbW9kZWwubW9kZWxJZCB8fCBtb2RlbC5pZCxcbiAgICAgIG5hbWU6IChtb2RlbC5tb2RlbElkIHx8IG1vZGVsLmlkKT8uc3BsaXQoJy8nKS5wb3AoKSB8fCAnVW5rbm93biBNb2RlbCcsXG4gICAgICBkZXNjcmlwdGlvbjogbW9kZWwuZGVzY3JpcHRpb24gfHwgJ05vIGRlc2NyaXB0aW9uIGF2YWlsYWJsZScsXG4gICAgICB0eXBlOiBkZXRlcm1pbmVNb2RlbFR5cGUobW9kZWwucGlwZWxpbmVfdGFnKSxcbiAgICAgIHRhc2s6IG1vZGVsLnBpcGVsaW5lX3RhZyB8fCAndW5rbm93bicsXG4gICAgICBhcmNoaXRlY3R1cmU6IG1vZGVsLmNvbmZpZz8uYXJjaGl0ZWN0dXJlcz8uWzBdIHx8ICd1bmtub3duJyxcbiAgICAgIHNpemU6IGZvcm1hdFNpemUobW9kZWwuZG93bmxvYWRzPy5iaW5hcnk/LnNpemUgfHwgMCksXG4gICAgICBkb3dubG9hZHM6IG1vZGVsLmRvd25sb2Fkcz8udG90YWwgfHwgMCxcbiAgICAgIGxpa2VzOiBtb2RlbC5saWtlcyB8fCAwLFxuICAgICAgdGFnczogW1xuICAgICAgICBtb2RlbC5waXBlbGluZV90YWcsXG4gICAgICAgIC4uLihtb2RlbC50YWdzIHx8IFtdKSxcbiAgICAgICAgbW9kZWwubGlicmFyeV9uYW1lXG4gICAgICBdLmZpbHRlcihCb29sZWFuKVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGdldCBtb2RlbCBpbmZvOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TW9kZWxBcmNoaXRlY3R1cmUobW9kZWxJZDogc3RyaW5nKTogUHJvbWlzZTxNb2RlbEFyY2hpdGVjdHVyZT4ge1xuICBzd2l0Y2ggKG1vZGVsSWQpIHtcbiAgICBjYXNlICdtaWNyb3NvZnQvcmVzbmV0LTUwJzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVJlc05ldEFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ2ZhY2Vib29rL2JhcnQtbGFyZ2UtY25uJzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVRyYW5zZm9ybWVyQXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAnZ29vZ2xlL3ZpdC1iYXNlLXBhdGNoMTYtMjI0JzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZVZpVEFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ252aWRpYS9zdGFibGUtZGlmZnVzaW9uLXYxLjUnOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlU3RhYmxlRGlmZnVzaW9uQXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAnbWV0YS1sbGFtYS9sbGFtYS0yLTdiJzpcbiAgICAgIHJldHVybiBnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ3lvbG92OCc6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVZT0xPdjhBcmNoaXRlY3R1cmUoKTtcbiAgICBjYXNlICdvcGVuYWkvZ3B0LTInOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlR1BUMkFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ29wZW5haS93aGlzcGVyLWJhc2UnOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlV2hpc3BlckFyY2hpdGVjdHVyZSgpO1xuICAgIGNhc2UgJ2RtaXMtbGFiL2Jpb2JlcnQtYmFzZSc6XG4gICAgICByZXR1cm4gZ2VuZXJhdGVCaW9CRVJUQXJjaGl0ZWN0dXJlKCk7XG4gICAgY2FzZSAnZmFjZWJvb2svZGlub3YyLWJhc2UnOlxuICAgICAgcmV0dXJuIGdlbmVyYXRlRElOT3YyQXJjaGl0ZWN0dXJlKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBnZW5lcmF0ZURlZmF1bHRBcmNoaXRlY3R1cmUoKTtcbiAgfVxufVxuXG4vLyBJbXBvcnQgYXJjaGl0ZWN0dXJlIGdlbmVyYXRpb24gZnVuY3Rpb25zXG5pbXBvcnQge1xuICBnZW5lcmF0ZURlZmF1bHRBcmNoaXRlY3R1cmUsXG4gIGdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVRyYW5zZm9ybWVyQXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVZpVEFyY2hpdGVjdHVyZSxcbiAgZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUsXG4gIGdlbmVyYXRlTGxhbWEyQXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVlPTE92OEFyY2hpdGVjdHVyZSxcbiAgZ2VuZXJhdGVHUFQyQXJjaGl0ZWN0dXJlLFxuICBnZW5lcmF0ZVdoaXNwZXJBcmNoaXRlY3R1cmUsXG4gIGdlbmVyYXRlQmlvQkVSVEFyY2hpdGVjdHVyZSxcbiAgZ2VuZXJhdGVESU5PdjJBcmNoaXRlY3R1cmVcbn0gZnJvbSAnLi9tb2RlbC1hcmNoaXRlY3R1cmVzJzsiXSwibmFtZXMiOlsiRkVBVFVSRURfTU9ERUxTIiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJ0eXBlIiwidGFzayIsImFyY2hpdGVjdHVyZSIsInNpemUiLCJkb3dubG9hZHMiLCJsaWtlcyIsInRhZ3MiLCJzZWFyY2hNb2RlbHMiLCJxdWVyeSIsInJlc3BvbnNlIiwiZmV0Y2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJoZWFkZXJzIiwib2siLCJFcnJvciIsInN0YXR1cyIsInRleHQiLCJkYXRhIiwiSlNPTiIsInBhcnNlIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm1vZGVsIiwibW9kZWxJZCIsInNwbGl0IiwicG9wIiwiZGV0ZXJtaW5lTW9kZWxUeXBlIiwicGlwZWxpbmVfdGFnIiwiY29uZmlnIiwiYXJjaGl0ZWN0dXJlcyIsImZvcm1hdFNpemUiLCJiaW5hcnkiLCJ0b3RhbCIsImxpYnJhcnlfbmFtZSIsImZpbHRlciIsIkJvb2xlYW4iLCJwaXBlbGluZVRhZyIsInZpc2lvblRhc2tzIiwidGV4dFRhc2tzIiwiYXVkaW9UYXNrcyIsImluY2x1ZGVzIiwiYnl0ZXMiLCJrIiwic2l6ZXMiLCJpIiwiTWF0aCIsImZsb29yIiwibG9nIiwicGFyc2VGbG9hdCIsInBvdyIsInRvRml4ZWQiLCJnZXRNb2RlbEluZm8iLCJqc29uIiwiZ2V0TW9kZWxBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZVJlc05ldEFyY2hpdGVjdHVyZSIsImdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZVZpVEFyY2hpdGVjdHVyZSIsImdlbmVyYXRlU3RhYmxlRGlmZnVzaW9uQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVMbGFtYTJBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZVlPTE92OEFyY2hpdGVjdHVyZSIsImdlbmVyYXRlR1BUMkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlV2hpc3BlckFyY2hpdGVjdHVyZSIsImdlbmVyYXRlQmlvQkVSVEFyY2hpdGVjdHVyZSIsImdlbmVyYXRlRElOT3YyQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVEZWZhdWx0QXJjaGl0ZWN0dXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/huggingface.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./lib/model-architectures.ts":
/*!************************************!*\
  !*** ./lib/model-architectures.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateBioBERTArchitecture: function() { return /* binding */ generateBioBERTArchitecture; },\n/* harmony export */   generateDINOv2Architecture: function() { return /* binding */ generateDINOv2Architecture; },\n/* harmony export */   generateDefaultArchitecture: function() { return /* binding */ generateDefaultArchitecture; },\n/* harmony export */   generateGPT2Architecture: function() { return /* binding */ generateGPT2Architecture; },\n/* harmony export */   generateLlama2Architecture: function() { return /* binding */ generateLlama2Architecture; },\n/* harmony export */   generateResNetArchitecture: function() { return /* binding */ generateResNetArchitecture; },\n/* harmony export */   generateStableDiffusionArchitecture: function() { return /* binding */ generateStableDiffusionArchitecture; },\n/* harmony export */   generateTransformerArchitecture: function() { return /* binding */ generateTransformerArchitecture; },\n/* harmony export */   generateViTArchitecture: function() { return /* binding */ generateViTArchitecture; },\n/* harmony export */   generateWhisperArchitecture: function() { return /* binding */ generateWhisperArchitecture; },\n/* harmony export */   generateYOLOv8Architecture: function() { return /* binding */ generateYOLOv8Architecture; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ generateResNetArchitecture,generateTransformerArchitecture,generateViTArchitecture,generateYOLOv8Architecture,generateStableDiffusionArchitecture,generateLlama2Architecture,generateGPT2Architecture,generateWhisperArchitecture,generateBioBERTArchitecture,generateDINOv2Architecture,generateDefaultArchitecture auto */ function generateResNetArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Initial convolution\n    nodes.push({\n        id: \"conv1\",\n        type: \"cnn\",\n        name: \"Conv1\",\n        params: 9408,\n        flops: 118013952,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"conv1\"\n    });\n    prevId = \"conv1\";\n    // ResNet blocks\n    const blocks = [\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\"\n    ];\n    blocks.forEach((block, i)=>{\n        // Each block has multiple residual units\n        for(let unit = 0; unit < 3; unit++){\n            const blockId = \"res\".concat(block, \"_\").concat(unit);\n            nodes.push({\n                id: blockId,\n                type: \"residual\",\n                name: \"ResBlock \".concat(block, \".\").concat(unit),\n                params: 1024 * 1024 * (i + 1),\n                flops: 5 * 1024 * 1024 * (i + 1),\n                memoryUsage: 3 * 1024 * 1024 * (i + 1)\n            });\n            edges.push({\n                source: prevId,\n                target: blockId\n            });\n            prevId = blockId;\n        }\n    });\n    // Final layers\n    nodes.push({\n        id: \"pool\",\n        type: \"mlp\",\n        name: \"Global Pool\",\n        params: 2048,\n        flops: 2048,\n        memoryUsage: 1024 * 512\n    });\n    edges.push({\n        source: prevId,\n        target: \"pool\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"FC 1000\",\n        params: 2048000,\n        flops: 2048000,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"pool\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateTransformerArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Encoder layers\n    for(let i = 0; i < 6; i++){\n        const attentionId = \"enc_attn_\".concat(i);\n        const ffnId = \"enc_ffn_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"attention\",\n            name: \"Encoder Self-Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: ffnId,\n            type: \"mlp\",\n            name: \"Encoder FFN \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Layer Norm \".concat(i),\n            params: 1024,\n            flops: 2048,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: ffnId\n        });\n        edges.push({\n            source: ffnId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    // Output projection\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Projection\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateViTArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Patch Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Patch embedding\n    nodes.push({\n        id: \"patch_embed\",\n        type: \"cnn\",\n        name: \"Patch Embedding\",\n        params: 590592,\n        flops: 47185920,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"patch_embed\"\n    });\n    prevId = \"patch_embed\";\n    // Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attentionId = \"transformer_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"transformer\",\n            name: \"Transformer Block \".concat(i),\n            params: 7 * 1024 * 1024,\n            flops: 28 * 1024 * 1024,\n            memoryUsage: 14 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: mlpId\n        });\n        prevId = mlpId;\n    }\n    // Classification head\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Classification Head\",\n        params: 768000,\n        flops: 768000,\n        memoryUsage: 1024 * 768\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateYOLOv8Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024 // 1MB for input tensor\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Backbone: CSPDarknet\n    for(let i = 0; i < 4; i++){\n        const convId = \"conv_\".concat(i);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Conv Block \".concat(i + 1),\n            params: 64 * Math.pow(2, i) * 3 * 3,\n            flops: 64 * Math.pow(2, i) * 3 * 3 * 512 * 512 / Math.pow(2, i),\n            memoryUsage: 512 * 512 * 64 * Math.pow(2, i) / Math.pow(2, i) * 4 // 4 bytes per float\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    }\n    // Feature Pyramid Network (FPN)\n    const fpnLayers = [\n        \"P5\",\n        \"P4\",\n        \"P3\"\n    ];\n    fpnLayers.forEach((layer, i)=>{\n        const fpnId = \"fpn_\".concat(layer);\n        nodes.push({\n            id: fpnId,\n            type: \"graph\",\n            name: \"FPN \".concat(layer),\n            params: 256 * 256 * 3,\n            flops: 256 * 256 * 3 * 80 * 80 / Math.pow(2, i),\n            memoryUsage: 256 * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: prevId,\n            target: fpnId\n        });\n        prevId = fpnId;\n    });\n    // Detection Heads\n    [\n        \"small\",\n        \"medium\",\n        \"large\"\n    ].forEach((size, i)=>{\n        const headId = \"head_\".concat(size);\n        nodes.push({\n            id: headId,\n            type: \"mlp\",\n            name: \"Detection Head (\".concat(size, \")\"),\n            params: 256 * (80 + 4 + 1),\n            flops: 256 * (80 + 4 + 1) * 80 * 80 / Math.pow(2, i),\n            memoryUsage: (80 + 4 + 1) * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: \"fpn_\".concat(fpnLayers[i]),\n            target: headId\n        });\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Stable Diffusion\nfunction generateStableDiffusionArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Add UNet Encoder blocks\n    for(let i = 0; i < 4; i++){\n        const encoderId = \"encoder_\".concat(i);\n        const attnId = \"encoder_attn_\".concat(i);\n        nodes.push({\n            id: encoderId,\n            type: \"residual\",\n            name: \"UNet Encoder \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Cross Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: encoderId\n        });\n        edges.push({\n            source: encoderId,\n            target: attnId\n        });\n        prevId = attnId;\n    }\n    // Add UNet Decoder blocks with skip connections\n    for(let i = 3; i >= 0; i--){\n        const decoderId = \"decoder_\".concat(i);\n        nodes.push({\n            id: decoderId,\n            type: \"residual\",\n            name: \"UNet Decoder \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: decoderId\n        });\n        edges.push({\n            source: \"encoder_attn_\".concat(i),\n            target: decoderId\n        }); // Skip connection\n        prevId = decoderId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\n// Llama 2\nfunction generateLlama2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token Embedding\",\n        params: 32000 * 4096,\n        flops: 4096,\n        memoryUsage: 4 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // Transformer Blocks\n    for(let i = 0; i < 32; i++){\n        const attnId = \"attn_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId = \"norm_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 4 * 4096 * 4096,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 4096 * 11008,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"RMSNorm \".concat(i),\n            params: 4096,\n            flops: 4096,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 4096 * 32000,\n        flops: 4096 * 32000,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateGPT2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token Embedding\",\n        params: 50257 * 768,\n        flops: 768,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // 12 Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attnId = \"attn_\".concat(i);\n        const normId1 = \"norm1_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId2 = \"norm2_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 3 * 768 * 768,\n            flops: 12 * 1024 * 1024,\n            memoryUsage: 6 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId1,\n            type: \"normalization\",\n            name: \"Layer Norm 1 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 768 * 3072 + 3072 * 768,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId2,\n            type: \"normalization\",\n            name: \"Layer Norm 2 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: normId1\n        });\n        edges.push({\n            source: normId1,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId2\n        });\n        prevId = normId2;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 768 * 50257,\n        flops: 768 * 50257,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateWhisperArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Audio Input\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Conv Frontend\n    for(let i = 0; i < 2; i++){\n        const convId = \"conv_\".concat(i);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Conv Block \".concat(i),\n            params: 512 * 512 * 3 * 3,\n            flops: 512 * 512 * 3 * 3 * 80,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    }\n    // Encoder blocks (6 for base model)\n    for(let i = 0; i < 6; i++){\n        const attnId = \"enc_attn_\".concat(i);\n        const mlpId = \"enc_mlp_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Encoder Attention \".concat(i),\n            params: 3 * 512 * 512,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"Encoder MLP \".concat(i),\n            params: 512 * 2048 + 2048 * 512,\n            flops: 4 * 1024 * 1024,\n            memoryUsage: 2 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Encoder Norm \".concat(i),\n            params: 2 * 512,\n            flops: 512,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 512 * 51865,\n        flops: 512 * 51865,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateBioBERTArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Token & Position Embedding\n    nodes.push({\n        id: \"embedding\",\n        type: \"embedding\",\n        name: \"Token + Position Embedding\",\n        params: 28996 * 768 + 512 * 768,\n        flops: 768 * 2,\n        memoryUsage: 3 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"embedding\"\n    });\n    prevId = \"embedding\";\n    // 12 Transformer Encoder blocks\n    for(let i = 0; i < 12; i++){\n        const attnId = \"attn_\".concat(i);\n        const normId1 = \"norm1_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId2 = \"norm2_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Multi-Head Attention \".concat(i),\n            params: 768 * 768 * 4,\n            flops: 12 * 1024 * 1024,\n            memoryUsage: 6 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId1,\n            type: \"normalization\",\n            name: \"Layer Norm 1 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"Feed Forward \".concat(i),\n            params: 768 * 3072 + 3072 * 768,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId2,\n            type: \"normalization\",\n            name: \"Layer Norm 2 (\".concat(i, \")\"),\n            params: 2 * 768,\n            flops: 768,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: normId1\n        });\n        edges.push({\n            source: normId1,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId2\n        });\n        prevId = normId2;\n    }\n    // Pooler and Output\n    nodes.push({\n        id: \"pooler\",\n        type: \"mlp\",\n        name: \"Pooler\",\n        params: 768 * 768,\n        flops: 768 * 768,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"pooler\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Layer\",\n        params: 768 * 2,\n        flops: 768 * 2,\n        memoryUsage: 1024 * 64\n    });\n    edges.push({\n        source: \"pooler\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateDINOv2Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Patch Embedding\n    nodes.push({\n        id: \"patch_embed\",\n        type: \"cnn\",\n        name: \"Patch Embedding\",\n        params: 384 * (14 * 14 * 3),\n        flops: 384 * 196 * 3,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"patch_embed\"\n    });\n    prevId = \"patch_embed\";\n    // 12 Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attnId = \"attn_\".concat(i);\n        const normId1 = \"norm1_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        const normId2 = \"norm2_\".concat(i);\n        nodes.push({\n            id: attnId,\n            type: \"attention\",\n            name: \"Self-Attention \".concat(i),\n            params: 384 * 384 * 4,\n            flops: 8 * 1024 * 1024,\n            memoryUsage: 4 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId1,\n            type: \"normalization\",\n            name: \"Layer Norm 1 (\".concat(i, \")\"),\n            params: 2 * 384,\n            flops: 384,\n            memoryUsage: 1024 * 32\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 384 * 1536 + 1536 * 384,\n            flops: 6 * 1024 * 1024,\n            memoryUsage: 3 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId2,\n            type: \"normalization\",\n            name: \"Layer Norm 2 (\".concat(i, \")\"),\n            params: 2 * 384,\n            flops: 384,\n            memoryUsage: 1024 * 32\n        });\n        edges.push({\n            source: prevId,\n            target: attnId\n        });\n        edges.push({\n            source: attnId,\n            target: normId1\n        });\n        edges.push({\n            source: normId1,\n            target: mlpId\n        });\n        edges.push({\n            source: mlpId,\n            target: normId2\n        });\n        prevId = normId2;\n    }\n    // Projection head\n    nodes.push({\n        id: \"projection\",\n        type: \"mlp\",\n        name: \"Projection Head\",\n        params: 384 * 2048,\n        flops: 384 * 2048,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"projection\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Embeddings\",\n        params: 2048 * 256,\n        flops: 2048 * 256,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"projection\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateDefaultArchitecture() {\n    return generateResNetArchitecture();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC1hcmNoaXRlY3R1cmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OzBXQUlPLFNBQVNBO0lBQ2QsTUFBTUMsUUFBUTtRQUNaO1lBQ0VDLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLFFBQVE7WUFDUkMsT0FBTztZQUNQQyxhQUFhLE9BQU87UUFDdEI7S0FDRDtJQUVELE1BQU1DLFFBQVEsRUFBRTtJQUNoQixJQUFJQyxTQUFTO0lBRWIsc0JBQXNCO0lBQ3RCUixNQUFNUyxJQUFJLENBQUM7UUFDVFIsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLGFBQWEsSUFBSSxPQUFPO0lBQzFCO0lBQ0FDLE1BQU1FLElBQUksQ0FBQztRQUFFQyxRQUFRRjtRQUFRRyxRQUFRO0lBQVE7SUFDN0NILFNBQVM7SUFFVCxnQkFBZ0I7SUFDaEIsTUFBTUksU0FBUztRQUFDO1FBQUs7UUFBSztRQUFLO0tBQUk7SUFDbkNBLE9BQU9DLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUNyQix5Q0FBeUM7UUFDekMsSUFBSyxJQUFJQyxPQUFPLEdBQUdBLE9BQU8sR0FBR0EsT0FBUTtZQUNuQyxNQUFNQyxVQUFVLE1BQWVELE9BQVRGLE9BQU0sS0FBUSxPQUFMRTtZQUMvQmhCLE1BQU1TLElBQUksQ0FBQztnQkFDVFIsSUFBSWdCO2dCQUNKZixNQUFNO2dCQUNOQyxNQUFNLFlBQXFCYSxPQUFURixPQUFNLEtBQVEsT0FBTEU7Z0JBQzNCWixRQUFRLE9BQU8sT0FBUVcsQ0FBQUEsSUFBSTtnQkFDM0JWLE9BQU8sSUFBSSxPQUFPLE9BQVFVLENBQUFBLElBQUk7Z0JBQzlCVCxhQUFhLElBQUksT0FBTyxPQUFRUyxDQUFBQSxJQUFJO1lBQ3RDO1lBQ0FSLE1BQU1FLElBQUksQ0FBQztnQkFBRUMsUUFBUUY7Z0JBQVFHLFFBQVFNO1lBQVE7WUFDN0NULFNBQVNTO1FB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TVMsSUFBSSxDQUFDO1FBQ1RSLElBQUk7UUFDSkMsTUFBTTtRQUNOQyxNQUFNO1FBQ05DLFFBQVEsT0FBTztRQUNmQyxPQUFPLE9BQU87UUFDZEMsYUFBYSxPQUFPO0lBQ3RCO0lBQ0FDLE1BQU1FLElBQUksQ0FBQztRQUFFQyxRQUFRO1FBQWNDLFFBQVE7SUFBUztJQUVwRCxPQUFPO1FBQUVYO1FBQU9PO0lBQU07QUFDeEI7QUFFTyxTQUFTcUM7SUFDZCxPQUFPN0M7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbW9kZWwtYXJjaGl0ZWN0dXJlcy50cz84ZTBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBNb2RlbEFyY2hpdGVjdHVyZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gSW5pdGlhbCBjb252b2x1dGlvblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ2NvbnYxJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnQ29udjEnLFxuICAgIHBhcmFtczogOTQwOCxcbiAgICBmbG9wczogMTE4MDEzOTUyLFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnY29udjEnIH0pO1xuICBwcmV2SWQgPSAnY29udjEnO1xuXG4gIC8vIFJlc05ldCBibG9ja3NcbiAgY29uc3QgYmxvY2tzID0gWycyJywgJzMnLCAnNCcsICc1J107XG4gIGJsb2Nrcy5mb3JFYWNoKChibG9jaywgaSkgPT4ge1xuICAgIC8vIEVhY2ggYmxvY2sgaGFzIG11bHRpcGxlIHJlc2lkdWFsIHVuaXRzXG4gICAgZm9yIChsZXQgdW5pdCA9IDA7IHVuaXQgPCAzOyB1bml0KyspIHtcbiAgICAgIGNvbnN0IGJsb2NrSWQgPSBgcmVzJHtibG9ja31fJHt1bml0fWA7XG4gICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGJsb2NrSWQsXG4gICAgICAgIHR5cGU6ICdyZXNpZHVhbCcsXG4gICAgICAgIG5hbWU6IGBSZXNCbG9jayAke2Jsb2NrfS4ke3VuaXR9YCxcbiAgICAgICAgcGFyYW1zOiAxMDI0ICogMTAyNCAqIChpICsgMSksXG4gICAgICAgIGZsb3BzOiA1ICogMTAyNCAqIDEwMjQgKiAoaSArIDEpLFxuICAgICAgICBtZW1vcnlVc2FnZTogMyAqIDEwMjQgKiAxMDI0ICogKGkgKyAxKVxuICAgICAgfSk7XG4gICAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYmxvY2tJZCB9KTtcbiAgICAgIHByZXZJZCA9IGJsb2NrSWQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBGaW5hbCBsYXllcnNcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdwb29sJyxcbiAgICB0eXBlOiAnbWxwJyxcbiAgICBuYW1lOiAnR2xvYmFsIFBvb2wnLFxuICAgIHBhcmFtczogMjA0OCxcbiAgICBmbG9wczogMjA0OCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDUxMlxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwb29sJyB9KTtcblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0ZDIDEwMDAnLFxuICAgIHBhcmFtczogMjA0ODAwMCxcbiAgICBmbG9wczogMjA0ODAwMCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6ICdwb29sJywgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNmb3JtZXJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIEVuY29kZXIgbGF5ZXJzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgY29uc3QgYXR0ZW50aW9uSWQgPSBgZW5jX2F0dG5fJHtpfWA7XG4gICAgY29uc3QgZmZuSWQgPSBgZW5jX2Zmbl8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgZW5jX25vcm1fJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRlbnRpb25JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYEVuY29kZXIgU2VsZi1BdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogZmZuSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIEZGTiAke2l9YCxcbiAgICAgIHBhcmFtczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDMyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gJHtpfWAsXG4gICAgICBwYXJhbXM6IDEwMjQsXG4gICAgICBmbG9wczogMjA0OCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogNjRcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRlbnRpb25JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRlbnRpb25JZCwgdGFyZ2V0OiBmZm5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBmZm5JZCwgdGFyZ2V0OiBub3JtSWQgfSk7XG4gICAgcHJldklkID0gbm9ybUlkO1xuICB9XG5cbiAgLy8gT3V0cHV0IHByb2plY3Rpb25cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgUHJvamVjdGlvbicsXG4gICAgcGFyYW1zOiAxMDI0ICogMTAyNCxcbiAgICBmbG9wczogMiAqIDEwMjQgKiAxMDI0LFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVWaVRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIFBhdGNoIGVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ3BhdGNoX2VtYmVkJyxcbiAgICB0eXBlOiAnY25uJyxcbiAgICBuYW1lOiAnUGF0Y2ggRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDU5MDU5MixcbiAgICBmbG9wczogNDcxODU5MjAsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwYXRjaF9lbWJlZCcgfSk7XG4gIHByZXZJZCA9ICdwYXRjaF9lbWJlZCc7XG5cbiAgLy8gVHJhbnNmb3JtZXIgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIGNvbnN0IGF0dGVudGlvbklkID0gYHRyYW5zZm9ybWVyXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dGVudGlvbklkLFxuICAgICAgdHlwZTogJ3RyYW5zZm9ybWVyJyxcbiAgICAgIG5hbWU6IGBUcmFuc2Zvcm1lciBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogNyAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDI4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTQgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbWxwSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBNTFAgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dGVudGlvbklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dGVudGlvbklkLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIHByZXZJZCA9IG1scElkO1xuICB9XG5cbiAgLy8gQ2xhc3NpZmljYXRpb24gaGVhZFxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ0NsYXNzaWZpY2F0aW9uIEhlYWQnLFxuICAgIHBhcmFtczogNzY4MDAwLFxuICAgIGZsb3BzOiA3NjgwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiA3NjhcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWU9MT3Y4QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IExheWVyJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0ICAvLyAxTUIgZm9yIGlucHV0IHRlbnNvclxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBCYWNrYm9uZTogQ1NQRGFya25ldFxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IGNvbnZJZCA9IGBjb252XyR7aX1gO1xuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGNvbnZJZCxcbiAgICAgIHR5cGU6ICdjbm4nLFxuICAgICAgbmFtZTogYENvbnYgQmxvY2sgJHtpICsgMX1gLFxuICAgICAgcGFyYW1zOiA2NCAqIE1hdGgucG93KDIsIGkpICogMyAqIDMsICAvLyBSZWFsaXN0aWMgcGFyYW1ldGVyIGNvdW50XG4gICAgICBmbG9wczogNjQgKiBNYXRoLnBvdygyLCBpKSAqIDMgKiAzICogNTEyICogNTEyIC8gTWF0aC5wb3coMiwgaSksXG4gICAgICBtZW1vcnlVc2FnZTogNTEyICogNTEyICogNjQgKiBNYXRoLnBvdygyLCBpKSAvIE1hdGgucG93KDIsIGkpICogNCAgLy8gNCBieXRlcyBwZXIgZmxvYXRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogY29udklkIH0pO1xuICAgIHByZXZJZCA9IGNvbnZJZDtcbiAgfVxuXG4gIC8vIEZlYXR1cmUgUHlyYW1pZCBOZXR3b3JrIChGUE4pXG4gIGNvbnN0IGZwbkxheWVycyA9IFsnUDUnLCAnUDQnLCAnUDMnXTtcbiAgZnBuTGF5ZXJzLmZvckVhY2goKGxheWVyLCBpKSA9PiB7XG4gICAgY29uc3QgZnBuSWQgPSBgZnBuXyR7bGF5ZXJ9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBmcG5JZCxcbiAgICAgIHR5cGU6ICdncmFwaCcsXG4gICAgICBuYW1lOiBgRlBOICR7bGF5ZXJ9YCxcbiAgICAgIHBhcmFtczogMjU2ICogMjU2ICogMyxcbiAgICAgIGZsb3BzOiAyNTYgKiAyNTYgKiAzICogODAgKiA4MCAvIE1hdGgucG93KDIsIGkpLFxuICAgICAgbWVtb3J5VXNhZ2U6IDI1NiAqIDgwICogODAgLyBNYXRoLnBvdygyLCBpKSAqIDRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogZnBuSWQgfSk7XG4gICAgcHJldklkID0gZnBuSWQ7XG4gIH0pO1xuXG4gIC8vIERldGVjdGlvbiBIZWFkc1xuICBbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddLmZvckVhY2goKHNpemUsIGkpID0+IHtcbiAgICBjb25zdCBoZWFkSWQgPSBgaGVhZF8ke3NpemV9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBoZWFkSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBEZXRlY3Rpb24gSGVhZCAoJHtzaXplfSlgLFxuICAgICAgcGFyYW1zOiAyNTYgKiAoODAgKyA0ICsgMSksICAvLyBjbGFzc2VzICsgYmJveCArIG9iamVjdG5lc3NcbiAgICAgIGZsb3BzOiAyNTYgKiAoODAgKyA0ICsgMSkgKiA4MCAqIDgwIC8gTWF0aC5wb3coMiwgaSksXG4gICAgICBtZW1vcnlVc2FnZTogKDgwICsgNCArIDEpICogODAgKiA4MCAvIE1hdGgucG93KDIsIGkpICogNFxuICAgIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGBmcG5fJHtmcG5MYXllcnNbaV19YCwgdGFyZ2V0OiBoZWFkSWQgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG4vLyBTdGFibGUgRGlmZnVzaW9uXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVTdGFibGVEaWZmdXNpb25BcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gQWRkIFVOZXQgRW5jb2RlciBibG9ja3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBlbmNvZGVySWQgPSBgZW5jb2Rlcl8ke2l9YDtcbiAgICBjb25zdCBhdHRuSWQgPSBgZW5jb2Rlcl9hdHRuXyR7aX1gO1xuICAgIFxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGVuY29kZXJJZCxcbiAgICAgIHR5cGU6ICdyZXNpZHVhbCcsXG4gICAgICBuYW1lOiBgVU5ldCBFbmNvZGVyICR7aX1gLFxuICAgICAgcGFyYW1zOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBmbG9wczogMzIgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxNiAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBDcm9zcyBBdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAxNiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDggKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGVuY29kZXJJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBlbmNvZGVySWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIHByZXZJZCA9IGF0dG5JZDtcbiAgfVxuXG4gIC8vIEFkZCBVTmV0IERlY29kZXIgYmxvY2tzIHdpdGggc2tpcCBjb25uZWN0aW9uc1xuICBmb3IgKGxldCBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBkZWNvZGVySWQgPSBgZGVjb2Rlcl8ke2l9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBkZWNvZGVySWQsXG4gICAgICB0eXBlOiAncmVzaWR1YWwnLFxuICAgICAgbmFtZTogYFVOZXQgRGVjb2RlciAke2l9YCxcbiAgICAgIHBhcmFtczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgZmxvcHM6IDMyICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMTYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBkZWNvZGVySWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYGVuY29kZXJfYXR0bl8ke2l9YCwgdGFyZ2V0OiBkZWNvZGVySWQgfSk7IC8vIFNraXAgY29ubmVjdGlvblxuICAgIHByZXZJZCA9IGRlY29kZXJJZDtcbiAgfVxuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDEwMjQgKiAxMDI0LFxuICAgIGZsb3BzOiAyICogMTAyNCAqIDEwMjQsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbi8vIExsYW1hIDJcbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUxsYW1hMkFyY2hpdGVjdHVyZSgpOiBNb2RlbEFyY2hpdGVjdHVyZSB7XG4gIGNvbnN0IG5vZGVzID0gW1xuICAgIHtcbiAgICAgIGlkOiAnaW5wdXQnLFxuICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgIG5hbWU6ICdJbnB1dCBMYXllcicsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBUb2tlbiBFbWJlZGRpbmdcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdlbWJlZGRpbmcnLFxuICAgIHR5cGU6ICdlbWJlZGRpbmcnLFxuICAgIG5hbWU6ICdUb2tlbiBFbWJlZGRpbmcnLFxuICAgIHBhcmFtczogMzIwMDAgKiA0MDk2LFxuICAgIGZsb3BzOiA0MDk2LFxuICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnZW1iZWRkaW5nJyB9KTtcbiAgcHJldklkID0gJ2VtYmVkZGluZyc7XG5cbiAgLy8gVHJhbnNmb3JtZXIgQmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgIGNvbnN0IGF0dG5JZCA9IGBhdHRuXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQgPSBgbm9ybV8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dG5JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYFNlbGYtQXR0ZW50aW9uICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogNDA5NiAqIDQwOTYsXG4gICAgICBmbG9wczogMTYgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA4ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG1scElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgTUxQIEJsb2NrICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogNDA5NiAqIDExMDA4LFxuICAgICAgZmxvcHM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZCxcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBSTVNOb3JtICR7aX1gLFxuICAgICAgcGFyYW1zOiA0MDk2LFxuICAgICAgZmxvcHM6IDQwOTYsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDY0XG4gICAgfSk7XG5cbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dG5JZCwgdGFyZ2V0OiBtbHBJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBtbHBJZCwgdGFyZ2V0OiBub3JtSWQgfSk7XG4gICAgcHJldklkID0gbm9ybUlkO1xuICB9XG5cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgTGF5ZXInLFxuICAgIHBhcmFtczogNDA5NiAqIDMyMDAwLFxuICAgIGZsb3BzOiA0MDk2ICogMzIwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUdQVDJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gVG9rZW4gRW1iZWRkaW5nXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnZW1iZWRkaW5nJyxcbiAgICB0eXBlOiAnZW1iZWRkaW5nJyxcbiAgICBuYW1lOiAnVG9rZW4gRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDUwMjU3ICogNzY4LCAvLyBWb2NhYiBzaXplICogZW1iZWRkaW5nIGRpbVxuICAgIGZsb3BzOiA3NjgsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdlbWJlZGRpbmcnIH0pO1xuICBwcmV2SWQgPSAnZW1iZWRkaW5nJztcblxuICAvLyAxMiBUcmFuc2Zvcm1lciBibG9ja3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgY29uc3QgYXR0bklkID0gYGF0dG5fJHtpfWA7XG4gICAgY29uc3Qgbm9ybUlkMSA9IGBub3JtMV8ke2l9YDtcbiAgICBjb25zdCBtbHBJZCA9IGBtbHBfJHtpfWA7XG4gICAgY29uc3Qgbm9ybUlkMiA9IGBub3JtMl8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dG5JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYFNlbGYtQXR0ZW50aW9uICR7aX1gLFxuICAgICAgcGFyYW1zOiAzICogNzY4ICogNzY4LCAvLyAzID0gUSxLLFYgbWF0cmljZXNcbiAgICAgIGZsb3BzOiAxMiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDYgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkMSxcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBMYXllciBOb3JtIDEgKCR7aX0pYCxcbiAgICAgIHBhcmFtczogMiAqIDc2OCxcbiAgICAgIGZsb3BzOiA3NjgsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDMyXG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBtbHBJZCxcbiAgICAgIHR5cGU6ICdtbHAnLFxuICAgICAgbmFtZTogYE1MUCBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogNzY4ICogMzA3MiArIDMwNzIgKiA3NjgsXG4gICAgICBmbG9wczogOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDQgKiAxMDI0ICogMTAyNFxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbm9ybUlkMixcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBMYXllciBOb3JtIDIgKCR7aX0pYCxcbiAgICAgIHBhcmFtczogMiAqIDc2OCxcbiAgICAgIGZsb3BzOiA3NjgsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDMyXG4gICAgfSk7XG5cbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYXR0bklkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IGF0dG5JZCwgdGFyZ2V0OiBub3JtSWQxIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IG5vcm1JZDEsIHRhcmdldDogbWxwSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogbWxwSWQsIHRhcmdldDogbm9ybUlkMiB9KTtcbiAgICBwcmV2SWQgPSBub3JtSWQyO1xuICB9XG5cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdPdXRwdXQgTGF5ZXInLFxuICAgIHBhcmFtczogNzY4ICogNTAyNTcsXG4gICAgZmxvcHM6IDc2OCAqIDUwMjU3LFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlV2hpc3BlckFyY2hpdGVjdHVyZSgpOiBNb2RlbEFyY2hpdGVjdHVyZSB7XG4gIGNvbnN0IG5vZGVzID0gW1xuICAgIHtcbiAgICAgIGlkOiAnaW5wdXQnLFxuICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgIG5hbWU6ICdBdWRpbyBJbnB1dCcsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBDb252IEZyb250ZW5kXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgY29uc3QgY29udklkID0gYGNvbnZfJHtpfWA7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogY29udklkLFxuICAgICAgdHlwZTogJ2NubicsXG4gICAgICBuYW1lOiBgQ29udiBCbG9jayAke2l9YCxcbiAgICAgIHBhcmFtczogNTEyICogNTEyICogMyAqIDMsXG4gICAgICBmbG9wczogNTEyICogNTEyICogMyAqIDMgKiA4MCxcbiAgICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogY29udklkIH0pO1xuICAgIHByZXZJZCA9IGNvbnZJZDtcbiAgfVxuXG4gIC8vIEVuY29kZXIgYmxvY2tzICg2IGZvciBiYXNlIG1vZGVsKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGNvbnN0IGF0dG5JZCA9IGBlbmNfYXR0bl8ke2l9YDtcbiAgICBjb25zdCBtbHBJZCA9IGBlbmNfbWxwXyR7aX1gO1xuICAgIGNvbnN0IG5vcm1JZCA9IGBlbmNfbm9ybV8ke2l9YDtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGF0dG5JZCxcbiAgICAgIHR5cGU6ICdhdHRlbnRpb24nLFxuICAgICAgbmFtZTogYEVuY29kZXIgQXR0ZW50aW9uICR7aX1gLFxuICAgICAgcGFyYW1zOiAzICogNTEyICogNTEyLFxuICAgICAgZmxvcHM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG1scElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgRW5jb2RlciBNTFAgJHtpfWAsXG4gICAgICBwYXJhbXM6IDUxMiAqIDIwNDggKyAyMDQ4ICogNTEyLFxuICAgICAgZmxvcHM6IDQgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZCxcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIE5vcm0gJHtpfWAsXG4gICAgICBwYXJhbXM6IDIgKiA1MTIsXG4gICAgICBmbG9wczogNTEyLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAzMlxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dG5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRuSWQsIHRhcmdldDogbWxwSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogbWxwSWQsIHRhcmdldDogbm9ybUlkIH0pO1xuICAgIHByZXZJZCA9IG5vcm1JZDtcbiAgfVxuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDUxMiAqIDUxODY1LCAvLyB2b2NhYiBzaXplXG4gICAgZmxvcHM6IDUxMiAqIDUxODY1LFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQmlvQkVSVEFyY2hpdGVjdHVyZSgpOiBNb2RlbEFyY2hpdGVjdHVyZSB7XG4gIGNvbnN0IG5vZGVzID0gW1xuICAgIHtcbiAgICAgIGlkOiAnaW5wdXQnLFxuICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgIG5hbWU6ICdJbnB1dCBMYXllcicsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBUb2tlbiAmIFBvc2l0aW9uIEVtYmVkZGluZ1xuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ2VtYmVkZGluZycsXG4gICAgdHlwZTogJ2VtYmVkZGluZycsXG4gICAgbmFtZTogJ1Rva2VuICsgUG9zaXRpb24gRW1iZWRkaW5nJyxcbiAgICBwYXJhbXM6IDI4OTk2ICogNzY4ICsgNTEyICogNzY4LCAvLyB2b2NhYl9zaXplICogaGlkZGVuX2RpbSArIG1heF9wb3MgKiBoaWRkZW5fZGltXG4gICAgZmxvcHM6IDc2OCAqIDIsXG4gICAgbWVtb3J5VXNhZ2U6IDMgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdlbWJlZGRpbmcnIH0pO1xuICBwcmV2SWQgPSAnZW1iZWRkaW5nJztcblxuICAvLyAxMiBUcmFuc2Zvcm1lciBFbmNvZGVyIGJsb2Nrc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICBjb25zdCBhdHRuSWQgPSBgYXR0bl8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQxID0gYG5vcm0xXyR7aX1gO1xuICAgIGNvbnN0IG1scElkID0gYG1scF8ke2l9YDtcbiAgICBjb25zdCBub3JtSWQyID0gYG5vcm0yXyR7aX1gO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogYXR0bklkLFxuICAgICAgdHlwZTogJ2F0dGVudGlvbicsXG4gICAgICBuYW1lOiBgTXVsdGktSGVhZCBBdHRlbnRpb24gJHtpfWAsXG4gICAgICBwYXJhbXM6IDc2OCAqIDc2OCAqIDQsIC8vIDQgPSBRLEssVixPIG1hdHJpY2VzXG4gICAgICBmbG9wczogMTIgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA2ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZDEsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgTGF5ZXIgTm9ybSAxICgke2l9KWAsXG4gICAgICBwYXJhbXM6IDIgKiA3NjgsXG4gICAgICBmbG9wczogNzY4LFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAzMlxuICAgIH0pO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogbWxwSWQsXG4gICAgICB0eXBlOiAnbWxwJyxcbiAgICAgIG5hbWU6IGBGZWVkIEZvcndhcmQgJHtpfWAsXG4gICAgICBwYXJhbXM6IDc2OCAqIDMwNzIgKyAzMDcyICogNzY4LFxuICAgICAgZmxvcHM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZDIsXG4gICAgICB0eXBlOiAnbm9ybWFsaXphdGlvbicsXG4gICAgICBuYW1lOiBgTGF5ZXIgTm9ybSAyICgke2l9KWAsXG4gICAgICBwYXJhbXM6IDIgKiA3NjgsXG4gICAgICBmbG9wczogNzY4LFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAzMlxuICAgIH0pO1xuXG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGF0dG5JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRuSWQsIHRhcmdldDogbm9ybUlkMSB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBub3JtSWQxLCB0YXJnZXQ6IG1scElkIH0pO1xuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IG1scElkLCB0YXJnZXQ6IG5vcm1JZDIgfSk7XG4gICAgcHJldklkID0gbm9ybUlkMjtcbiAgfVxuXG4gIC8vIFBvb2xlciBhbmQgT3V0cHV0XG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAncG9vbGVyJyxcbiAgICB0eXBlOiAnbWxwJyxcbiAgICBuYW1lOiAnUG9vbGVyJyxcbiAgICBwYXJhbXM6IDc2OCAqIDc2OCxcbiAgICBmbG9wczogNzY4ICogNzY4LFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwb29sZXInIH0pO1xuXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IExheWVyJyxcbiAgICBwYXJhbXM6IDc2OCAqIDIsIC8vIGJpbmFyeSBjbGFzc2lmaWNhdGlvblxuICAgIGZsb3BzOiA3NjggKiAyLFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogNjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6ICdwb29sZXInLCB0YXJnZXQ6ICdvdXRwdXQnIH0pO1xuXG4gIHJldHVybiB7IG5vZGVzLCBlZGdlcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVESU5PdjJBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICBjb25zdCBub2RlcyA9IFtcbiAgICB7XG4gICAgICBpZDogJ2lucHV0JyxcbiAgICAgIHR5cGU6ICdpbnB1dCcsXG4gICAgICBuYW1lOiAnSW5wdXQgTGF5ZXInLFxuICAgICAgcGFyYW1zOiAwLFxuICAgICAgZmxvcHM6IDAsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gUGF0Y2ggRW1iZWRkaW5nXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAncGF0Y2hfZW1iZWQnLFxuICAgIHR5cGU6ICdjbm4nLFxuICAgIG5hbWU6ICdQYXRjaCBFbWJlZGRpbmcnLFxuICAgIHBhcmFtczogMzg0ICogKDE0ICogMTQgKiAzKSwgLy8gaGlkZGVuX2RpbSAqIHBhdGNoX3NpemVeMiAqIGNoYW5uZWxzXG4gICAgZmxvcHM6IDM4NCAqIDE5NiAqIDMsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwYXRjaF9lbWJlZCcgfSk7XG4gIHByZXZJZCA9ICdwYXRjaF9lbWJlZCc7XG5cbiAgLy8gMTIgVHJhbnNmb3JtZXIgYmxvY2tzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIGNvbnN0IGF0dG5JZCA9IGBhdHRuXyR7aX1gO1xuICAgIGNvbnN0IG5vcm1JZDEgPSBgbm9ybTFfJHtpfWA7XG4gICAgY29uc3QgbWxwSWQgPSBgbWxwXyR7aX1gO1xuICAgIGNvbnN0IG5vcm1JZDIgPSBgbm9ybTJfJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRuSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBTZWxmLUF0dGVudGlvbiAke2l9YCxcbiAgICAgIHBhcmFtczogMzg0ICogMzg0ICogNCxcbiAgICAgIGZsb3BzOiA4ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogNCAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBub3JtSWQxLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gMSAoJHtpfSlgLFxuICAgICAgcGFyYW1zOiAyICogMzg0LFxuICAgICAgZmxvcHM6IDM4NCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMzJcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG1scElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgTUxQIEJsb2NrICR7aX1gLFxuICAgICAgcGFyYW1zOiAzODQgKiAxNTM2ICsgMTUzNiAqIDM4NCxcbiAgICAgIGZsb3BzOiA2ICogMTAyNCAqIDEwMjQsXG4gICAgICBtZW1vcnlVc2FnZTogMyAqIDEwMjQgKiAxMDI0XG4gICAgfSk7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBub3JtSWQyLFxuICAgICAgdHlwZTogJ25vcm1hbGl6YXRpb24nLFxuICAgICAgbmFtZTogYExheWVyIE5vcm0gMiAoJHtpfSlgLFxuICAgICAgcGFyYW1zOiAyICogMzg0LFxuICAgICAgZmxvcHM6IDM4NCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMzJcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRuSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYXR0bklkLCB0YXJnZXQ6IG5vcm1JZDEgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogbm9ybUlkMSwgdGFyZ2V0OiBtbHBJZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBtbHBJZCwgdGFyZ2V0OiBub3JtSWQyIH0pO1xuICAgIHByZXZJZCA9IG5vcm1JZDI7XG4gIH1cblxuICAvLyBQcm9qZWN0aW9uIGhlYWRcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdwcm9qZWN0aW9uJyxcbiAgICB0eXBlOiAnbWxwJyxcbiAgICBuYW1lOiAnUHJvamVjdGlvbiBIZWFkJyxcbiAgICBwYXJhbXM6IDM4NCAqIDIwNDgsXG4gICAgZmxvcHM6IDM4NCAqIDIwNDgsXG4gICAgbWVtb3J5VXNhZ2U6IDIgKiAxMDI0ICogMTAyNFxuICB9KTtcbiAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6ICdwcm9qZWN0aW9uJyB9KTtcblxuICBub2Rlcy5wdXNoKHtcbiAgICBpZDogJ291dHB1dCcsXG4gICAgdHlwZTogJ291dHB1dCcsXG4gICAgbmFtZTogJ091dHB1dCBFbWJlZGRpbmdzJyxcbiAgICBwYXJhbXM6IDIwNDggKiAyNTYsXG4gICAgZmxvcHM6IDIwNDggKiAyNTYsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiAncHJvamVjdGlvbicsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZURlZmF1bHRBcmNoaXRlY3R1cmUoKTogTW9kZWxBcmNoaXRlY3R1cmUge1xuICByZXR1cm4gZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUoKTtcbn0iXSwibmFtZXMiOlsiZ2VuZXJhdGVSZXNOZXRBcmNoaXRlY3R1cmUiLCJub2RlcyIsImlkIiwidHlwZSIsIm5hbWUiLCJwYXJhbXMiLCJmbG9wcyIsIm1lbW9yeVVzYWdlIiwiZWRnZXMiLCJwcmV2SWQiLCJwdXNoIiwic291cmNlIiwidGFyZ2V0IiwiYmxvY2tzIiwiZm9yRWFjaCIsImJsb2NrIiwiaSIsInVuaXQiLCJibG9ja0lkIiwiZ2VuZXJhdGVUcmFuc2Zvcm1lckFyY2hpdGVjdHVyZSIsImF0dGVudGlvbklkIiwiZmZuSWQiLCJub3JtSWQiLCJnZW5lcmF0ZVZpVEFyY2hpdGVjdHVyZSIsIm1scElkIiwiZ2VuZXJhdGVZT0xPdjhBcmNoaXRlY3R1cmUiLCJjb252SWQiLCJNYXRoIiwicG93IiwiZnBuTGF5ZXJzIiwibGF5ZXIiLCJmcG5JZCIsInNpemUiLCJoZWFkSWQiLCJnZW5lcmF0ZVN0YWJsZURpZmZ1c2lvbkFyY2hpdGVjdHVyZSIsImVuY29kZXJJZCIsImF0dG5JZCIsImRlY29kZXJJZCIsImdlbmVyYXRlTGxhbWEyQXJjaGl0ZWN0dXJlIiwiZ2VuZXJhdGVHUFQyQXJjaGl0ZWN0dXJlIiwibm9ybUlkMSIsIm5vcm1JZDIiLCJnZW5lcmF0ZVdoaXNwZXJBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZUJpb0JFUlRBcmNoaXRlY3R1cmUiLCJnZW5lcmF0ZURJTk92MkFyY2hpdGVjdHVyZSIsImdlbmVyYXRlRGVmYXVsdEFyY2hpdGVjdHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model-architectures.ts\n"));

/***/ })

});