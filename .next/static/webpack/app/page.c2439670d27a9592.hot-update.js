"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/model-architectures.ts":
/*!************************************!*\
  !*** ./lib/model-architectures.ts ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDefaultArchitecture: function() { return /* binding */ generateDefaultArchitecture; },\n/* harmony export */   generateResNetArchitecture: function() { return /* binding */ generateResNetArchitecture; },\n/* harmony export */   generateTransformerArchitecture: function() { return /* binding */ generateTransformerArchitecture; },\n/* harmony export */   generateViTArchitecture: function() { return /* binding */ generateViTArchitecture; },\n/* harmony export */   generateYOLOv8Architecture: function() { return /* binding */ generateYOLOv8Architecture; }\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ generateResNetArchitecture,generateTransformerArchitecture,generateViTArchitecture,generateYOLOv8Architecture,generateDefaultArchitecture auto */ function generateResNetArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Initial convolution\n    nodes.push({\n        id: \"conv1\",\n        type: \"cnn\",\n        name: \"Conv1\",\n        params: 9408,\n        flops: 118013952,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"conv1\"\n    });\n    prevId = \"conv1\";\n    // ResNet blocks\n    const blocks = [\n        \"2\",\n        \"3\",\n        \"4\",\n        \"5\"\n    ];\n    blocks.forEach((block, i)=>{\n        // Each block has multiple residual units\n        for(let unit = 0; unit < 3; unit++){\n            const blockId = \"res\".concat(block, \"_\").concat(unit);\n            nodes.push({\n                id: blockId,\n                type: \"residual\",\n                name: \"ResBlock \".concat(block, \".\").concat(unit),\n                params: 1024 * 1024 * (i + 1),\n                flops: 5 * 1024 * 1024 * (i + 1),\n                memoryUsage: 3 * 1024 * 1024 * (i + 1)\n            });\n            edges.push({\n                source: prevId,\n                target: blockId\n            });\n            prevId = blockId;\n        }\n    });\n    // Final layers\n    nodes.push({\n        id: \"pool\",\n        type: \"mlp\",\n        name: \"Global Pool\",\n        params: 2048,\n        flops: 2048,\n        memoryUsage: 1024 * 512\n    });\n    edges.push({\n        source: prevId,\n        target: \"pool\"\n    });\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"FC 1000\",\n        params: 2048000,\n        flops: 2048000,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: \"pool\",\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateTransformerArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Encoder layers\n    for(let i = 0; i < 6; i++){\n        const attentionId = \"enc_attn_\".concat(i);\n        const ffnId = \"enc_ffn_\".concat(i);\n        const normId = \"enc_norm_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"attention\",\n            name: \"Encoder Self-Attention \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        nodes.push({\n            id: ffnId,\n            type: \"mlp\",\n            name: \"Encoder FFN \".concat(i),\n            params: 8 * 1024 * 1024,\n            flops: 32 * 1024 * 1024,\n            memoryUsage: 16 * 1024 * 1024\n        });\n        nodes.push({\n            id: normId,\n            type: \"normalization\",\n            name: \"Layer Norm \".concat(i),\n            params: 1024,\n            flops: 2048,\n            memoryUsage: 1024 * 64\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: ffnId\n        });\n        edges.push({\n            source: ffnId,\n            target: normId\n        });\n        prevId = normId;\n    }\n    // Output projection\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Output Projection\",\n        params: 1024 * 1024,\n        flops: 2 * 1024 * 1024,\n        memoryUsage: 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateViTArchitecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Patch Embedding\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Patch embedding\n    nodes.push({\n        id: \"patch_embed\",\n        type: \"cnn\",\n        name: \"Patch Embedding\",\n        params: 590592,\n        flops: 47185920,\n        memoryUsage: 2 * 1024 * 1024\n    });\n    edges.push({\n        source: prevId,\n        target: \"patch_embed\"\n    });\n    prevId = \"patch_embed\";\n    // Transformer blocks\n    for(let i = 0; i < 12; i++){\n        const attentionId = \"transformer_\".concat(i);\n        const mlpId = \"mlp_\".concat(i);\n        nodes.push({\n            id: attentionId,\n            type: \"transformer\",\n            name: \"Transformer Block \".concat(i),\n            params: 7 * 1024 * 1024,\n            flops: 28 * 1024 * 1024,\n            memoryUsage: 14 * 1024 * 1024\n        });\n        nodes.push({\n            id: mlpId,\n            type: \"mlp\",\n            name: \"MLP Block \".concat(i),\n            params: 4 * 1024 * 1024,\n            flops: 16 * 1024 * 1024,\n            memoryUsage: 8 * 1024 * 1024\n        });\n        edges.push({\n            source: prevId,\n            target: attentionId\n        });\n        edges.push({\n            source: attentionId,\n            target: mlpId\n        });\n        prevId = mlpId;\n    }\n    // Classification head\n    nodes.push({\n        id: \"output\",\n        type: \"output\",\n        name: \"Classification Head\",\n        params: 768000,\n        flops: 768000,\n        memoryUsage: 1024 * 768\n    });\n    edges.push({\n        source: prevId,\n        target: \"output\"\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateYOLOv8Architecture() {\n    const nodes = [\n        {\n            id: \"input\",\n            type: \"input\",\n            name: \"Input Layer\",\n            params: 0,\n            flops: 0,\n            memoryUsage: 1024 * 1024 // 1MB for input tensor\n        }\n    ];\n    const edges = [];\n    let prevId = \"input\";\n    // Backbone: CSPDarknet\n    for(let i = 0; i < 4; i++){\n        const convId = \"conv_\".concat(i);\n        nodes.push({\n            id: convId,\n            type: \"cnn\",\n            name: \"Conv Block \".concat(i + 1),\n            params: 64 * Math.pow(2, i) * 3 * 3,\n            flops: 64 * Math.pow(2, i) * 3 * 3 * 512 * 512 / Math.pow(2, i),\n            memoryUsage: 512 * 512 * 64 * Math.pow(2, i) / Math.pow(2, i) * 4 // 4 bytes per float\n        });\n        edges.push({\n            source: prevId,\n            target: convId\n        });\n        prevId = convId;\n    }\n    // Feature Pyramid Network (FPN)\n    const fpnLayers = [\n        \"P5\",\n        \"P4\",\n        \"P3\"\n    ];\n    fpnLayers.forEach((layer, i)=>{\n        const fpnId = \"fpn_\".concat(layer);\n        nodes.push({\n            id: fpnId,\n            type: \"graph\",\n            name: \"FPN \".concat(layer),\n            params: 256 * 256 * 3,\n            flops: 256 * 256 * 3 * 80 * 80 / Math.pow(2, i),\n            memoryUsage: 256 * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: prevId,\n            target: fpnId\n        });\n        prevId = fpnId;\n    });\n    // Detection Heads\n    [\n        \"small\",\n        \"medium\",\n        \"large\"\n    ].forEach((size, i)=>{\n        const headId = \"head_\".concat(size);\n        nodes.push({\n            id: headId,\n            type: \"mlp\",\n            name: \"Detection Head (\".concat(size, \")\"),\n            params: 256 * (80 + 4 + 1),\n            flops: 256 * (80 + 4 + 1) * 80 * 80 / Math.pow(2, i),\n            memoryUsage: (80 + 4 + 1) * 80 * 80 / Math.pow(2, i) * 4\n        });\n        edges.push({\n            source: \"fpn_\".concat(fpnLayers[i]),\n            target: headId\n        });\n    });\n    return {\n        nodes,\n        edges\n    };\n}\nfunction generateDefaultArchitecture() {\n    return generateResNetArchitecture();\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9tb2RlbC1hcmNoaXRlY3R1cmVzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OytMQUlPLFNBQVNBO0lBQ2QsTUFBTUMsUUFBUTtRQUNaO1lBQ0VDLElBQUk7WUFDSkMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLFFBQVE7WUFDUkMsT0FBTztZQUNQQyxhQUFhLE9BQU87UUFDdEI7S0FDRDtJQUVELE1BQU1DLFFBQVEsRUFBRTtJQUNoQixJQUFJQyxTQUFTO0lBRWIsc0JBQXNCO0lBQ3RCUixNQUFNUyxJQUFJLENBQUM7UUFDVFIsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE1BQU07UUFDTkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLGFBQWEsSUFBSSxPQUFPO0lBQzFCO0lBQ0FDLE1BQU1FLElBQUksQ0FBQztRQUFFQyxRQUFRRjtRQUFRRyxRQUFRO0lBQVE7SUFDN0NILFNBQVM7SUFFVCxnQkFBZ0I7SUFDaEIsTUFBTUksU0FBUztRQUFDO1FBQUs7UUFBSztRQUFLO0tBQUk7SUFDbkNBLE9BQU9DLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUNyQix5Q0FBeUM7UUFDekMsSUFBSyxJQUFJQyxPQUFPLEdBQUdBLE9BQU8sR0FBR0EsT0FBUTtZQUNuQyxNQUFNQyxVQUFVLE1BQWVELE9BQVRGLE9BQU0sS0FBUSxPQUFMRTtZQUMvQmhCLE1BQU1TLElBQUksQ0FBQztnQkFDVFIsSUFBSWdCO2dCQUNKZixNQUFNO2dCQUNOQyxNQUFNLFlBQXFCYSxPQUFURixPQUFNLEtBQVEsT0FBTEU7Z0JBQzNCWixRQUFRLE9BQU8sT0FBUVcsQ0FBQUEsSUFBSTtnQkFDM0JWLE9BQU8sSUFBSSxPQUFPLE9BQVFVLENBQUFBLElBQUk7Z0JBQzlCVCxhQUFhLElBQUksT0FBTyxPQUFRUyxDQUFBQSxJQUFJO1lBQ3RDO1lBQ0FSLE1BQU1FLElBQUksQ0FBQztnQkFBRUMsUUFBUUY7Z0JBQVFHLFFBQVFNO1lBQVE7WUFDN0NULFNBQVNTO1FBQ1g7SUFD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LFFBQWEsT0FBTEQ7UUFDdkIvQixNQUFNUyxJQUFJLENBQUM7WUFDVFIsSUFBSStCO1lBQ0o5QixNQUFNO1lBQ05DLE1BQU0sbUJBQXdCLE9BQUw0QixNQUFLO1lBQzlCM0IsUUFBUSxNQUFPLE1BQUssSUFBSTtZQUN4QkMsT0FBTyxNQUFPLE1BQUssSUFBSSxLQUFLLEtBQUssS0FBS3FCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHWjtZQUNsRFQsYUFBYSxDQUFDLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBS29CLEtBQUtDLEdBQUcsQ0FBQyxHQUFHWixLQUFLO1FBQ3pEO1FBQ0FSLE1BQU1FLElBQUksQ0FBQztZQUFFQyxRQUFRLE9BQW9CLE9BQWJrQixTQUFTLENBQUNiLEVBQUU7WUFBSUosUUFBUXFCO1FBQU87SUFDN0Q7SUFFQSxPQUFPO1FBQUVoQztRQUFPTztJQUFNO0FBQ3hCO0FBRU8sU0FBUzBCO0lBQ2QsT0FBT2xDO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL21vZGVsLWFyY2hpdGVjdHVyZXMudHM/OGUwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgTW9kZWxBcmNoaXRlY3R1cmUgfSBmcm9tICcuL2h1Z2dpbmdmYWNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmVzTmV0QXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IExheWVyJyxcbiAgICAgIHBhcmFtczogMCxcbiAgICAgIGZsb3BzOiAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gICAgfVxuICBdO1xuXG4gIGNvbnN0IGVkZ2VzID0gW107XG4gIGxldCBwcmV2SWQgPSAnaW5wdXQnO1xuXG4gIC8vIEluaXRpYWwgY29udm9sdXRpb25cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdjb252MScsXG4gICAgdHlwZTogJ2NubicsXG4gICAgbmFtZTogJ0NvbnYxJyxcbiAgICBwYXJhbXM6IDk0MDgsXG4gICAgZmxvcHM6IDExODAxMzk1MixcbiAgICBtZW1vcnlVc2FnZTogMiAqIDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ2NvbnYxJyB9KTtcbiAgcHJldklkID0gJ2NvbnYxJztcblxuICAvLyBSZXNOZXQgYmxvY2tzXG4gIGNvbnN0IGJsb2NrcyA9IFsnMicsICczJywgJzQnLCAnNSddO1xuICBibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAvLyBFYWNoIGJsb2NrIGhhcyBtdWx0aXBsZSByZXNpZHVhbCB1bml0c1xuICAgIGZvciAobGV0IHVuaXQgPSAwOyB1bml0IDwgMzsgdW5pdCsrKSB7XG4gICAgICBjb25zdCBibG9ja0lkID0gYHJlcyR7YmxvY2t9XyR7dW5pdH1gO1xuICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgIGlkOiBibG9ja0lkLFxuICAgICAgICB0eXBlOiAncmVzaWR1YWwnLFxuICAgICAgICBuYW1lOiBgUmVzQmxvY2sgJHtibG9ja30uJHt1bml0fWAsXG4gICAgICAgIHBhcmFtczogMTAyNCAqIDEwMjQgKiAoaSArIDEpLFxuICAgICAgICBmbG9wczogNSAqIDEwMjQgKiAxMDI0ICogKGkgKyAxKSxcbiAgICAgICAgbWVtb3J5VXNhZ2U6IDMgKiAxMDI0ICogMTAyNCAqIChpICsgMSlcbiAgICAgIH0pO1xuICAgICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGJsb2NrSWQgfSk7XG4gICAgICBwcmV2SWQgPSBibG9ja0lkO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRmluYWwgbGF5ZXJzXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAncG9vbCcsXG4gICAgdHlwZTogJ21scCcsXG4gICAgbmFtZTogJ0dsb2JhbCBQb29sJyxcbiAgICBwYXJhbXM6IDIwNDgsXG4gICAgZmxvcHM6IDIwNDgsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiA1MTJcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAncG9vbCcgfSk7XG5cbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdGQyAxMDAwJyxcbiAgICBwYXJhbXM6IDIwNDgwMDAsXG4gICAgZmxvcHM6IDIwNDgwMDAsXG4gICAgbWVtb3J5VXNhZ2U6IDEwMjQgKiAxMDI0XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiAncG9vbCcsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRyYW5zZm9ybWVyQXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ0lucHV0IEVtYmVkZGluZycsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBFbmNvZGVyIGxheWVyc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGNvbnN0IGF0dGVudGlvbklkID0gYGVuY19hdHRuXyR7aX1gO1xuICAgIGNvbnN0IGZmbklkID0gYGVuY19mZm5fJHtpfWA7XG4gICAgY29uc3Qgbm9ybUlkID0gYGVuY19ub3JtXyR7aX1gO1xuXG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogYXR0ZW50aW9uSWQsXG4gICAgICB0eXBlOiAnYXR0ZW50aW9uJyxcbiAgICAgIG5hbWU6IGBFbmNvZGVyIFNlbGYtQXR0ZW50aW9uICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogMTAyNCAqIDEwMjQsXG4gICAgICBmbG9wczogMTYgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA4ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IGZmbklkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgRW5jb2RlciBGRk4gJHtpfWAsXG4gICAgICBwYXJhbXM6IDggKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAzMiAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDE2ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG5vcm1JZCxcbiAgICAgIHR5cGU6ICdub3JtYWxpemF0aW9uJyxcbiAgICAgIG5hbWU6IGBMYXllciBOb3JtICR7aX1gLFxuICAgICAgcGFyYW1zOiAxMDI0LFxuICAgICAgZmxvcHM6IDIwNDgsXG4gICAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDY0XG4gICAgfSk7XG5cbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogYXR0ZW50aW9uSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogYXR0ZW50aW9uSWQsIHRhcmdldDogZmZuSWQgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogZmZuSWQsIHRhcmdldDogbm9ybUlkIH0pO1xuICAgIHByZXZJZCA9IG5vcm1JZDtcbiAgfVxuXG4gIC8vIE91dHB1dCBwcm9qZWN0aW9uXG4gIG5vZGVzLnB1c2goe1xuICAgIGlkOiAnb3V0cHV0JyxcbiAgICB0eXBlOiAnb3V0cHV0JyxcbiAgICBuYW1lOiAnT3V0cHV0IFByb2plY3Rpb24nLFxuICAgIHBhcmFtczogMTAyNCAqIDEwMjQsXG4gICAgZmxvcHM6IDIgKiAxMDI0ICogMTAyNCxcbiAgICBtZW1vcnlVc2FnZTogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAnb3V0cHV0JyB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVmlUQXJjaGl0ZWN0dXJlKCk6IE1vZGVsQXJjaGl0ZWN0dXJlIHtcbiAgY29uc3Qgbm9kZXMgPSBbXG4gICAge1xuICAgICAgaWQ6ICdpbnB1dCcsXG4gICAgICB0eXBlOiAnaW5wdXQnLFxuICAgICAgbmFtZTogJ1BhdGNoIEVtYmVkZGluZycsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNFxuICAgIH1cbiAgXTtcblxuICBjb25zdCBlZGdlcyA9IFtdO1xuICBsZXQgcHJldklkID0gJ2lucHV0JztcblxuICAvLyBQYXRjaCBlbWJlZGRpbmdcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdwYXRjaF9lbWJlZCcsXG4gICAgdHlwZTogJ2NubicsXG4gICAgbmFtZTogJ1BhdGNoIEVtYmVkZGluZycsXG4gICAgcGFyYW1zOiA1OTA1OTIsXG4gICAgZmxvcHM6IDQ3MTg1OTIwLFxuICAgIG1lbW9yeVVzYWdlOiAyICogMTAyNCAqIDEwMjRcbiAgfSk7XG4gIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiAncGF0Y2hfZW1iZWQnIH0pO1xuICBwcmV2SWQgPSAncGF0Y2hfZW1iZWQnO1xuXG4gIC8vIFRyYW5zZm9ybWVyIGJsb2Nrc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICBjb25zdCBhdHRlbnRpb25JZCA9IGB0cmFuc2Zvcm1lcl8ke2l9YDtcbiAgICBjb25zdCBtbHBJZCA9IGBtbHBfJHtpfWA7XG5cbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBhdHRlbnRpb25JZCxcbiAgICAgIHR5cGU6ICd0cmFuc2Zvcm1lcicsXG4gICAgICBuYW1lOiBgVHJhbnNmb3JtZXIgQmxvY2sgJHtpfWAsXG4gICAgICBwYXJhbXM6IDcgKiAxMDI0ICogMTAyNCxcbiAgICAgIGZsb3BzOiAyOCAqIDEwMjQgKiAxMDI0LFxuICAgICAgbWVtb3J5VXNhZ2U6IDE0ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIG5vZGVzLnB1c2goe1xuICAgICAgaWQ6IG1scElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgTUxQIEJsb2NrICR7aX1gLFxuICAgICAgcGFyYW1zOiA0ICogMTAyNCAqIDEwMjQsXG4gICAgICBmbG9wczogMTYgKiAxMDI0ICogMTAyNCxcbiAgICAgIG1lbW9yeVVzYWdlOiA4ICogMTAyNCAqIDEwMjRcbiAgICB9KTtcblxuICAgIGVkZ2VzLnB1c2goeyBzb3VyY2U6IHByZXZJZCwgdGFyZ2V0OiBhdHRlbnRpb25JZCB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBhdHRlbnRpb25JZCwgdGFyZ2V0OiBtbHBJZCB9KTtcbiAgICBwcmV2SWQgPSBtbHBJZDtcbiAgfVxuXG4gIC8vIENsYXNzaWZpY2F0aW9uIGhlYWRcbiAgbm9kZXMucHVzaCh7XG4gICAgaWQ6ICdvdXRwdXQnLFxuICAgIHR5cGU6ICdvdXRwdXQnLFxuICAgIG5hbWU6ICdDbGFzc2lmaWNhdGlvbiBIZWFkJyxcbiAgICBwYXJhbXM6IDc2ODAwMCxcbiAgICBmbG9wczogNzY4MDAwLFxuICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogNzY4XG4gIH0pO1xuICBlZGdlcy5wdXNoKHsgc291cmNlOiBwcmV2SWQsIHRhcmdldDogJ291dHB1dCcgfSk7XG5cbiAgcmV0dXJuIHsgbm9kZXMsIGVkZ2VzIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVlPTE92OEFyY2hpdGVjdHVyZSgpOiBNb2RlbEFyY2hpdGVjdHVyZSB7XG4gIGNvbnN0IG5vZGVzID0gW1xuICAgIHtcbiAgICAgIGlkOiAnaW5wdXQnLFxuICAgICAgdHlwZTogJ2lucHV0JyxcbiAgICAgIG5hbWU6ICdJbnB1dCBMYXllcicsXG4gICAgICBwYXJhbXM6IDAsXG4gICAgICBmbG9wczogMCxcbiAgICAgIG1lbW9yeVVzYWdlOiAxMDI0ICogMTAyNCAgLy8gMU1CIGZvciBpbnB1dCB0ZW5zb3JcbiAgICB9XG4gIF07XG5cbiAgY29uc3QgZWRnZXMgPSBbXTtcbiAgbGV0IHByZXZJZCA9ICdpbnB1dCc7XG5cbiAgLy8gQmFja2JvbmU6IENTUERhcmtuZXRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBjb252SWQgPSBgY29udl8ke2l9YDtcbiAgICBub2Rlcy5wdXNoKHtcbiAgICAgIGlkOiBjb252SWQsXG4gICAgICB0eXBlOiAnY25uJyxcbiAgICAgIG5hbWU6IGBDb252IEJsb2NrICR7aSArIDF9YCxcbiAgICAgIHBhcmFtczogNjQgKiBNYXRoLnBvdygyLCBpKSAqIDMgKiAzLCAgLy8gUmVhbGlzdGljIHBhcmFtZXRlciBjb3VudFxuICAgICAgZmxvcHM6IDY0ICogTWF0aC5wb3coMiwgaSkgKiAzICogMyAqIDUxMiAqIDUxMiAvIE1hdGgucG93KDIsIGkpLFxuICAgICAgbWVtb3J5VXNhZ2U6IDUxMiAqIDUxMiAqIDY0ICogTWF0aC5wb3coMiwgaSkgLyBNYXRoLnBvdygyLCBpKSAqIDQgIC8vIDQgYnl0ZXMgcGVyIGZsb2F0XG4gICAgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGNvbnZJZCB9KTtcbiAgICBwcmV2SWQgPSBjb252SWQ7XG4gIH1cblxuICAvLyBGZWF0dXJlIFB5cmFtaWQgTmV0d29yayAoRlBOKVxuICBjb25zdCBmcG5MYXllcnMgPSBbJ1A1JywgJ1A0JywgJ1AzJ107XG4gIGZwbkxheWVycy5mb3JFYWNoKChsYXllciwgaSkgPT4ge1xuICAgIGNvbnN0IGZwbklkID0gYGZwbl8ke2xheWVyfWA7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogZnBuSWQsXG4gICAgICB0eXBlOiAnZ3JhcGgnLFxuICAgICAgbmFtZTogYEZQTiAke2xheWVyfWAsXG4gICAgICBwYXJhbXM6IDI1NiAqIDI1NiAqIDMsXG4gICAgICBmbG9wczogMjU2ICogMjU2ICogMyAqIDgwICogODAgLyBNYXRoLnBvdygyLCBpKSxcbiAgICAgIG1lbW9yeVVzYWdlOiAyNTYgKiA4MCAqIDgwIC8gTWF0aC5wb3coMiwgaSkgKiA0XG4gICAgfSk7XG4gICAgZWRnZXMucHVzaCh7IHNvdXJjZTogcHJldklkLCB0YXJnZXQ6IGZwbklkIH0pO1xuICAgIHByZXZJZCA9IGZwbklkO1xuICB9KTtcblxuICAvLyBEZXRlY3Rpb24gSGVhZHNcbiAgWydzbWFsbCcsICdtZWRpdW0nLCAnbGFyZ2UnXS5mb3JFYWNoKChzaXplLCBpKSA9PiB7XG4gICAgY29uc3QgaGVhZElkID0gYGhlYWRfJHtzaXplfWA7XG4gICAgbm9kZXMucHVzaCh7XG4gICAgICBpZDogaGVhZElkLFxuICAgICAgdHlwZTogJ21scCcsXG4gICAgICBuYW1lOiBgRGV0ZWN0aW9uIEhlYWQgKCR7c2l6ZX0pYCxcbiAgICAgIHBhcmFtczogMjU2ICogKDgwICsgNCArIDEpLCAgLy8gY2xhc3NlcyArIGJib3ggKyBvYmplY3RuZXNzXG4gICAgICBmbG9wczogMjU2ICogKDgwICsgNCArIDEpICogODAgKiA4MCAvIE1hdGgucG93KDIsIGkpLFxuICAgICAgbWVtb3J5VXNhZ2U6ICg4MCArIDQgKyAxKSAqIDgwICogODAgLyBNYXRoLnBvdygyLCBpKSAqIDRcbiAgICB9KTtcbiAgICBlZGdlcy5wdXNoKHsgc291cmNlOiBgZnBuXyR7ZnBuTGF5ZXJzW2ldfWAsIHRhcmdldDogaGVhZElkIH0pO1xuICB9KTtcblxuICByZXR1cm4geyBub2RlcywgZWRnZXMgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRGVmYXVsdEFyY2hpdGVjdHVyZSgpOiBNb2RlbEFyY2hpdGVjdHVyZSB7XG4gIHJldHVybiBnZW5lcmF0ZVJlc05ldEFyY2hpdGVjdHVyZSgpO1xufSJdLCJuYW1lcyI6WyJnZW5lcmF0ZVJlc05ldEFyY2hpdGVjdHVyZSIsIm5vZGVzIiwiaWQiLCJ0eXBlIiwibmFtZSIsInBhcmFtcyIsImZsb3BzIiwibWVtb3J5VXNhZ2UiLCJlZGdlcyIsInByZXZJZCIsInB1c2giLCJzb3VyY2UiLCJ0YXJnZXQiLCJibG9ja3MiLCJmb3JFYWNoIiwiYmxvY2siLCJpIiwidW5pdCIsImJsb2NrSWQiLCJnZW5lcmF0ZVRyYW5zZm9ybWVyQXJjaGl0ZWN0dXJlIiwiYXR0ZW50aW9uSWQiLCJmZm5JZCIsIm5vcm1JZCIsImdlbmVyYXRlVmlUQXJjaGl0ZWN0dXJlIiwibWxwSWQiLCJnZW5lcmF0ZVlPTE92OEFyY2hpdGVjdHVyZSIsImNvbnZJZCIsIk1hdGgiLCJwb3ciLCJmcG5MYXllcnMiLCJsYXllciIsImZwbklkIiwic2l6ZSIsImhlYWRJZCIsImdlbmVyYXRlRGVmYXVsdEFyY2hpdGVjdHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/model-architectures.ts\n"));

/***/ })

});